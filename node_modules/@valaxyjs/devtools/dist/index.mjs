import { colors } from 'consola/utils';
import sirv from 'sirv';
import { createRPCServer } from 'vite-dev-rpc';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import bodyParser from 'body-parser';
import fs from 'fs-extra';
import matter from 'gray-matter';
import { JSON_SCHEMA } from 'js-yaml';
import process from 'node:process';
import dayjs from 'dayjs';
import fg from 'fast-glob';
import pathe from 'pathe';

const NAMESPACE = "valaxy:devtools";

const DIR_DIST = typeof __dirname !== "undefined" ? __dirname : dirname(fileURLToPath(import.meta.url));
const DEVTOOLS_CLIENT_FOLDER = resolve(DIR_DIST, "../dist/client");
const DIR_CLIENT = DEVTOOLS_CLIENT_FOLDER;

async function migration(path, frontmatter) {
  if (fs.existsSync(path)) {
    const rawMd = await fs.readFile(path, "utf-8");
    const matterFile = matter(rawMd, { schema: JSON_SCHEMA });
    let mod = false;
    for (const key in frontmatter) {
      if (key in matterFile.data) {
        matterFile.data[frontmatter[key]] = matterFile.data[key];
        delete matterFile.data[key];
        mod = true;
      }
    }
    if (mod) {
      const newMd = matter.stringify(matterFile.content, matterFile.data);
      await fs.writeFile(path, newMd);
    }
  }
}

const prefix = "/valaxy-devtools-api";
const apis = [
  {
    route: "/frontmatter",
    fn: async (req, res) => {
      if (req.method === "POST") {
        const { pageData, frontmatter: newFm } = await req.body;
        const path = pageData.path;
        if (fs.existsSync(path)) {
          const rawMd = await fs.readFile(path, "utf-8");
          const matterFile = matter(rawMd);
          matterFile.data = newFm;
          const newMd = matter.stringify(matterFile.content, matterFile.data);
          await fs.writeFile(path, newMd);
        }
      }
    }
  },
  {
    route: "/migration",
    fn: async (req, res) => {
      if (req.method === "POST") {
        const { pageData, frontmatter } = await req.body;
        const worker = [];
        for (const item of pageData) {
          const path = item;
          worker.push(migration(path, frontmatter));
        }
        Promise.all(worker).then(() => {
          res.end("ok");
        }).catch((_) => {
          res.end("migration error");
        });
      }
    }
  }
];
function registerApi(server, _viteConfig) {
  const app = server.middlewares;
  app.use(bodyParser.json());
  apis.forEach(({ route, fn }) => {
    app.use(prefix + route, fn);
  });
}

function ensurePrefix(prefix, str) {
  if (!str.startsWith(prefix))
    return prefix + str;
}
function getFunctions(server, devtoolsOptions) {
  const userRoot = (devtoolsOptions.userRoot || process.cwd()).replace(/\\/g, "/");
  function getRoutePath(filePath) {
    const relativePath = pathe.relative(pathe.resolve(userRoot, "pages"), filePath).slice(0, -".md".length);
    return ensurePrefix("/", relativePath);
  }
  return {
    async getOptions() {
      return {
        userRoot
      };
    },
    async getPostList() {
      const files = await fg(`${userRoot}/pages/posts/**/*.md`);
      const posts = [];
      for await (const file of files) {
        const md = await fs.readFile(file, "utf-8");
        const { data } = matter(md);
        posts.push({
          routePath: getRoutePath(file),
          frontmatter: data,
          filePath: file
        });
      }
      return {
        // sort by updated
        posts: posts.sort((a, b) => {
          const bDateValue = dayjs(b.frontmatter.updated || b.frontmatter.date).valueOf();
          const aDateValue = dayjs(a.frontmatter.updated || a.frontmatter.date).valueOf();
          return bDateValue - aDateValue;
        }),
        root: userRoot
      };
    },
    async getPageData(pagePath) {
      const relativePath = pagePath.startsWith("/") ? pagePath.slice(1) : pagePath;
      const file = pathe.resolve(userRoot, relativePath);
      const { data } = matter(file);
      return {
        routePath: getRoutePath(file),
        filePath: file,
        frontmatter: data
      };
    }
  };
}

function ValaxyDevtools(options = {}) {
  let config;
  const isDevDevtools = import.meta.env?.VITE_VALAXY_DEVTOOLS_DEV === "true";
  function configureServer(server) {
    const _print = server.printUrls;
    const base = (options.base ?? server.config.base) || "/";
    const functions = getFunctions(server, options);
    createRPCServer(NAMESPACE, server.ws, functions);
    const devtoolsUrl = `${base}__valaxy_devtools__/`;
    if (!isDevDevtools) {
      server.middlewares.use(devtoolsUrl, sirv(DIR_CLIENT, {
        single: true,
        dev: true
      }));
    }
    server.printUrls = () => {
      let host = `${config.server.https ? "https" : "http"}://localhost:${config.server.port || "80"}`;
      const url = server.resolvedUrls?.local[0];
      if (url) {
        try {
          const u = new URL(url);
          host = `${u.protocol}//${u.host}`;
        } catch (error) {
          console.warn("Parse resolved url failed:", error);
        }
      }
      _print();
      const colorUrl = (url2) => colors.green(url2.replace(/:(\d+)\//, (_, port) => `:${colors.bold(port)}/`));
      console.log(`  ${colors.green("\u279C")}  ${colors.bold("Inspect")}: ${colorUrl(`${host}${base}__inspect/`)}`);
    };
    registerApi(server);
  }
  const plugin = {
    name: NAMESPACE,
    enforce: "pre",
    // config: () => { },
    configResolved(_config) {
      config = _config;
    },
    configureServer(server) {
      configureServer(server);
    }
  };
  return plugin;
}

const safelist = [];

export { ValaxyDevtools, ValaxyDevtools as default, safelist };
