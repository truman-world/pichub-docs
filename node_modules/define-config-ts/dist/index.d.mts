declare function defineDefineConfig<T>(): (config: T) => T;

type UserInputConfig = Record<string, any>;

interface ResolvedConfig<T extends UserInputConfig = UserInputConfig> {
    config: T;
    configFile: string;
}
type ConfigFunction<T, Options> = (options: Options) => (T | Promise<T>);
/**
 * load *.config.ts
 */
type LoadConfigOptions = {
    /**
     * The directory to resolve the config file from.
     *
     * @default process.cwd()
     */
    cwd?: string;
    /**
     * if the config file not found, throw error
     * if false, return empty config
     * @default true
     */
    throwOnNotFound?: boolean;
} & ({
    /**
     * The name of the config file to load.
     *
     * load {name}.config.ts
     */
    name: string;
    /**
     * full/relative config file path
     * override cwd/name.config.ts
     */
    configFile?: string;
} | {
    /**
     * The name of the config file to load.
     *
     * load {name}.config.ts
     */
    name?: string;
    /**
     * full/relative config file path
     * override cwd/name.config.ts
     */
    configFile: string;
});
/**
 * load `{name}.config.ts` file
 * @param options
 */
declare function loadConfig<T extends UserInputConfig = UserInputConfig>(options: LoadConfigOptions): Promise<ResolvedConfig<T>>;

export { defineDefineConfig, loadConfig };
export type { ConfigFunction, LoadConfigOptions, ResolvedConfig, UserInputConfig };
