import{createRequire as _pkgrollCR}from"node:module";const require=_pkgrollCR(import.meta.url);import { writeFileSync } from 'node:fs';
import require$$0 from 'stream';
import require$$0$1 from 'fs';
import require$$2 from 'readline';
import require$$3 from 'url';
import require$$0$2 from 'path';
import require$$1 from 'child_process';
import require$$1$1 from 'string_decoder';
import require$$3$1 from 'zlib';
import require$$0$3 from 'util';
import { isAbsolute, resolve, parse, join } from 'node:path';
import require$$0$4 from 'os';
import require$$0$5 from 'events';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var dist = {};

var sitemapItemStream = {};

var errors = {};

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;
	/*!
	 * Sitemap
	 * Copyright(c) 2011 Eugene Kalinin
	 * MIT Licensed
	 */
	Object.defineProperty(errors, "__esModule", { value: true });
	errors.EmptySitemap = errors.EmptyStream = errors.InvalidVideoPriceCurrency = errors.InvalidVideoResolution = errors.InvalidVideoPriceType = errors.InvalidVideoRestrictionRelationship = errors.InvalidVideoRestriction = errors.InvalidVideoFamilyFriendly = errors.InvalidVideoCategory = errors.InvalidVideoTagCount = errors.InvalidVideoViewCount = errors.InvalidVideoTitle = errors.XMLLintUnavailable = errors.InvalidNewsAccessValue = errors.InvalidNewsFormat = errors.InvalidAttr = errors.InvalidAttrValue = errors.InvalidVideoRating = errors.InvalidVideoDescription = errors.InvalidVideoDuration = errors.InvalidVideoFormat = errors.UndefinedTargetFolder = errors.PriorityInvalidError = errors.ChangeFreqInvalidError = errors.NoConfigError = errors.NoURLError = void 0;
	class NoURLError extends Error {
	  constructor(message) {
	    super(message || "URL is required");
	    this.name = "NoURLError";
	    Error.captureStackTrace(this, NoURLError);
	  }
	}
	errors.NoURLError = NoURLError;
	class NoConfigError extends Error {
	  constructor(message) {
	    super(message || "SitemapItem requires a configuration");
	    this.name = "NoConfigError";
	    Error.captureStackTrace(this, NoConfigError);
	  }
	}
	errors.NoConfigError = NoConfigError;
	class ChangeFreqInvalidError extends Error {
	  constructor(url, changefreq) {
	    super(`${url}: changefreq "${changefreq}" is invalid`);
	    this.name = "ChangeFreqInvalidError";
	    Error.captureStackTrace(this, ChangeFreqInvalidError);
	  }
	}
	errors.ChangeFreqInvalidError = ChangeFreqInvalidError;
	class PriorityInvalidError extends Error {
	  constructor(url, priority) {
	    super(`${url}: priority "${priority}" must be a number between 0 and 1 inclusive`);
	    this.name = "PriorityInvalidError";
	    Error.captureStackTrace(this, PriorityInvalidError);
	  }
	}
	errors.PriorityInvalidError = PriorityInvalidError;
	class UndefinedTargetFolder extends Error {
	  constructor(message) {
	    super(message || "Target folder must exist");
	    this.name = "UndefinedTargetFolder";
	    Error.captureStackTrace(this, UndefinedTargetFolder);
	  }
	}
	errors.UndefinedTargetFolder = UndefinedTargetFolder;
	class InvalidVideoFormat extends Error {
	  constructor(url) {
	    super(`${url} video must include thumbnail_loc, title and description fields for videos`);
	    this.name = "InvalidVideoFormat";
	    Error.captureStackTrace(this, InvalidVideoFormat);
	  }
	}
	errors.InvalidVideoFormat = InvalidVideoFormat;
	class InvalidVideoDuration extends Error {
	  constructor(url, duration) {
	    super(`${url} duration "${duration}" must be an integer of seconds between 0 and 28800`);
	    this.name = "InvalidVideoDuration";
	    Error.captureStackTrace(this, InvalidVideoDuration);
	  }
	}
	errors.InvalidVideoDuration = InvalidVideoDuration;
	class InvalidVideoDescription extends Error {
	  constructor(url, length) {
	    const message = `${url}: video description is too long ${length} vs limit of 2048 characters.`;
	    super(message);
	    this.name = "InvalidVideoDescription";
	    Error.captureStackTrace(this, InvalidVideoDescription);
	  }
	}
	errors.InvalidVideoDescription = InvalidVideoDescription;
	class InvalidVideoRating extends Error {
	  constructor(url, title, rating) {
	    super(`${url}: video "${title}" rating "${rating}" must be between 0 and 5 inclusive`);
	    this.name = "InvalidVideoRating";
	    Error.captureStackTrace(this, InvalidVideoRating);
	  }
	}
	errors.InvalidVideoRating = InvalidVideoRating;
	class InvalidAttrValue extends Error {
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  constructor(key, val, validator) {
	    super('"' + val + '" tested against: ' + validator + ' is not a valid value for attr: "' + key + '"');
	    this.name = "InvalidAttrValue";
	    Error.captureStackTrace(this, InvalidAttrValue);
	  }
	}
	errors.InvalidAttrValue = InvalidAttrValue;
	class InvalidAttr extends Error {
	  constructor(key) {
	    super('"' + key + '" is malformed');
	    this.name = "InvalidAttr";
	    Error.captureStackTrace(this, InvalidAttr);
	  }
	}
	errors.InvalidAttr = InvalidAttr;
	class InvalidNewsFormat extends Error {
	  constructor(url) {
	    super(`${url} News must include publication, publication name, publication language, title, and publication_date for news`);
	    this.name = "InvalidNewsFormat";
	    Error.captureStackTrace(this, InvalidNewsFormat);
	  }
	}
	errors.InvalidNewsFormat = InvalidNewsFormat;
	class InvalidNewsAccessValue extends Error {
	  constructor(url, access) {
	    super(`${url} News access "${access}" must be either Registration, Subscription or not be present`);
	    this.name = "InvalidNewsAccessValue";
	    Error.captureStackTrace(this, InvalidNewsAccessValue);
	  }
	}
	errors.InvalidNewsAccessValue = InvalidNewsAccessValue;
	class XMLLintUnavailable extends Error {
	  constructor(message) {
	    super(message || "xmlLint is not installed. XMLLint is required to validate");
	    this.name = "XMLLintUnavailable";
	    Error.captureStackTrace(this, XMLLintUnavailable);
	  }
	}
	errors.XMLLintUnavailable = XMLLintUnavailable;
	class InvalidVideoTitle extends Error {
	  constructor(url, length) {
	    super(`${url}: video title is too long ${length} vs 100 character limit`);
	    this.name = "InvalidVideoTitle";
	    Error.captureStackTrace(this, InvalidVideoTitle);
	  }
	}
	errors.InvalidVideoTitle = InvalidVideoTitle;
	class InvalidVideoViewCount extends Error {
	  constructor(url, count) {
	    super(`${url}: video view count must be positive, view count was ${count}`);
	    this.name = "InvalidVideoViewCount";
	    Error.captureStackTrace(this, InvalidVideoViewCount);
	  }
	}
	errors.InvalidVideoViewCount = InvalidVideoViewCount;
	class InvalidVideoTagCount extends Error {
	  constructor(url, count) {
	    super(`${url}: video can have no more than 32 tags, this has ${count}`);
	    this.name = "InvalidVideoTagCount";
	    Error.captureStackTrace(this, InvalidVideoTagCount);
	  }
	}
	errors.InvalidVideoTagCount = InvalidVideoTagCount;
	class InvalidVideoCategory extends Error {
	  constructor(url, count) {
	    super(`${url}: video category can only be 256 characters but was passed ${count}`);
	    this.name = "InvalidVideoCategory";
	    Error.captureStackTrace(this, InvalidVideoCategory);
	  }
	}
	errors.InvalidVideoCategory = InvalidVideoCategory;
	class InvalidVideoFamilyFriendly extends Error {
	  constructor(url, fam) {
	    super(`${url}: video family friendly must be yes or no, was passed "${fam}"`);
	    this.name = "InvalidVideoFamilyFriendly";
	    Error.captureStackTrace(this, InvalidVideoFamilyFriendly);
	  }
	}
	errors.InvalidVideoFamilyFriendly = InvalidVideoFamilyFriendly;
	class InvalidVideoRestriction extends Error {
	  constructor(url, code) {
	    super(`${url}: video restriction must be one or more two letter country codes. Was passed "${code}"`);
	    this.name = "InvalidVideoRestriction";
	    Error.captureStackTrace(this, InvalidVideoRestriction);
	  }
	}
	errors.InvalidVideoRestriction = InvalidVideoRestriction;
	class InvalidVideoRestrictionRelationship extends Error {
	  constructor(url, val) {
	    super(`${url}: video restriction relationship must be either allow or deny. Was passed "${val}"`);
	    this.name = "InvalidVideoRestrictionRelationship";
	    Error.captureStackTrace(this, InvalidVideoRestrictionRelationship);
	  }
	}
	errors.InvalidVideoRestrictionRelationship = InvalidVideoRestrictionRelationship;
	class InvalidVideoPriceType extends Error {
	  constructor(url, priceType, price) {
	    super(priceType === void 0 && price === "" ? `${url}: video priceType is required when price is not provided` : `${url}: video price type "${priceType}" is not "rent" or "purchase"`);
	    this.name = "InvalidVideoPriceType";
	    Error.captureStackTrace(this, InvalidVideoPriceType);
	  }
	}
	errors.InvalidVideoPriceType = InvalidVideoPriceType;
	class InvalidVideoResolution extends Error {
	  constructor(url, resolution) {
	    super(`${url}: video price resolution "${resolution}" is not hd or sd`);
	    this.name = "InvalidVideoResolution";
	    Error.captureStackTrace(this, InvalidVideoResolution);
	  }
	}
	errors.InvalidVideoResolution = InvalidVideoResolution;
	class InvalidVideoPriceCurrency extends Error {
	  constructor(url, currency) {
	    super(`${url}: video price currency "${currency}" must be a three capital letter abbrieviation for the country currency`);
	    this.name = "InvalidVideoPriceCurrency";
	    Error.captureStackTrace(this, InvalidVideoPriceCurrency);
	  }
	}
	errors.InvalidVideoPriceCurrency = InvalidVideoPriceCurrency;
	class EmptyStream extends Error {
	  constructor() {
	    super("You have ended the stream before anything was written. streamToPromise MUST be called before ending the stream.");
	    this.name = "EmptyStream";
	    Error.captureStackTrace(this, EmptyStream);
	  }
	}
	errors.EmptyStream = EmptyStream;
	class EmptySitemap extends Error {
	  constructor() {
	    super("You ended the stream without writing anything.");
	    this.name = "EmptySitemap";
	    Error.captureStackTrace(this, EmptyStream);
	  }
	}
	errors.EmptySitemap = EmptySitemap;
	return errors;
}

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.IndexTagNames = exports.TagNames = exports.ErrorLevel = exports.isAllowDeny = exports.EnumAllowDeny = exports.isValidYesNo = exports.EnumYesNo = exports.isValidChangeFreq = exports.CHANGEFREQ = exports.isResolution = exports.isPriceType = exports.validators = exports.EnumChangefreq = void 0;
		var EnumChangefreq;
		(function(EnumChangefreq2) {
		  EnumChangefreq2["DAILY"] = "daily";
		  EnumChangefreq2["MONTHLY"] = "monthly";
		  EnumChangefreq2["ALWAYS"] = "always";
		  EnumChangefreq2["HOURLY"] = "hourly";
		  EnumChangefreq2["WEEKLY"] = "weekly";
		  EnumChangefreq2["YEARLY"] = "yearly";
		  EnumChangefreq2["NEVER"] = "never";
		})(EnumChangefreq = exports.EnumChangefreq || (exports.EnumChangefreq = {}));
		const allowDeny = /^(?:allow|deny)$/;
		exports.validators = {
		  "price:currency": /^[A-Z]{3}$/,
		  "price:type": /^(?:rent|purchase|RENT|PURCHASE)$/,
		  "price:resolution": /^(?:HD|hd|sd|SD)$/,
		  "platform:relationship": allowDeny,
		  "restriction:relationship": allowDeny,
		  restriction: /^([A-Z]{2}( +[A-Z]{2})*)?$/,
		  platform: /^((web|mobile|tv)( (web|mobile|tv))*)?$/,
		  language: /^zh-cn|zh-tw|([a-z]{2,3})$/,
		  genres: /^(PressRelease|Satire|Blog|OpEd|Opinion|UserGenerated)(, *(PressRelease|Satire|Blog|OpEd|Opinion|UserGenerated))*$/,
		  stock_tickers: /^(\w+:\w+(, *\w+:\w+){0,4})?$/
		};
		function isPriceType(pt) {
		  return exports.validators["price:type"].test(pt);
		}
		exports.isPriceType = isPriceType;
		function isResolution(res) {
		  return exports.validators["price:resolution"].test(res);
		}
		exports.isResolution = isResolution;
		exports.CHANGEFREQ = Object.values(EnumChangefreq);
		function isValidChangeFreq(freq) {
		  return exports.CHANGEFREQ.includes(freq);
		}
		exports.isValidChangeFreq = isValidChangeFreq;
		(function(EnumYesNo2) {
		  EnumYesNo2["YES"] = "YES";
		  EnumYesNo2["NO"] = "NO";
		  EnumYesNo2["Yes"] = "Yes";
		  EnumYesNo2["No"] = "No";
		  EnumYesNo2["yes"] = "yes";
		  EnumYesNo2["no"] = "no";
		})(exports.EnumYesNo || (exports.EnumYesNo = {}));
		function isValidYesNo(yn) {
		  return /^YES|NO|[Yy]es|[Nn]o$/.test(yn);
		}
		exports.isValidYesNo = isValidYesNo;
		(function(EnumAllowDeny2) {
		  EnumAllowDeny2["ALLOW"] = "allow";
		  EnumAllowDeny2["DENY"] = "deny";
		})(exports.EnumAllowDeny || (exports.EnumAllowDeny = {}));
		function isAllowDeny(ad) {
		  return allowDeny.test(ad);
		}
		exports.isAllowDeny = isAllowDeny;
		(function(ErrorLevel2) {
		  ErrorLevel2["SILENT"] = "silent";
		  ErrorLevel2["WARN"] = "warn";
		  ErrorLevel2["THROW"] = "throw";
		})(exports.ErrorLevel || (exports.ErrorLevel = {}));
		(function(TagNames2) {
		  TagNames2["url"] = "url";
		  TagNames2["loc"] = "loc";
		  TagNames2["urlset"] = "urlset";
		  TagNames2["lastmod"] = "lastmod";
		  TagNames2["changefreq"] = "changefreq";
		  TagNames2["priority"] = "priority";
		  TagNames2["video:thumbnail_loc"] = "video:thumbnail_loc";
		  TagNames2["video:video"] = "video:video";
		  TagNames2["video:title"] = "video:title";
		  TagNames2["video:description"] = "video:description";
		  TagNames2["video:tag"] = "video:tag";
		  TagNames2["video:duration"] = "video:duration";
		  TagNames2["video:player_loc"] = "video:player_loc";
		  TagNames2["video:content_loc"] = "video:content_loc";
		  TagNames2["image:image"] = "image:image";
		  TagNames2["image:loc"] = "image:loc";
		  TagNames2["image:geo_location"] = "image:geo_location";
		  TagNames2["image:license"] = "image:license";
		  TagNames2["image:title"] = "image:title";
		  TagNames2["image:caption"] = "image:caption";
		  TagNames2["video:requires_subscription"] = "video:requires_subscription";
		  TagNames2["video:publication_date"] = "video:publication_date";
		  TagNames2["video:id"] = "video:id";
		  TagNames2["video:restriction"] = "video:restriction";
		  TagNames2["video:family_friendly"] = "video:family_friendly";
		  TagNames2["video:view_count"] = "video:view_count";
		  TagNames2["video:uploader"] = "video:uploader";
		  TagNames2["video:expiration_date"] = "video:expiration_date";
		  TagNames2["video:platform"] = "video:platform";
		  TagNames2["video:price"] = "video:price";
		  TagNames2["video:rating"] = "video:rating";
		  TagNames2["video:category"] = "video:category";
		  TagNames2["video:live"] = "video:live";
		  TagNames2["video:gallery_loc"] = "video:gallery_loc";
		  TagNames2["news:news"] = "news:news";
		  TagNames2["news:publication"] = "news:publication";
		  TagNames2["news:name"] = "news:name";
		  TagNames2["news:access"] = "news:access";
		  TagNames2["news:genres"] = "news:genres";
		  TagNames2["news:publication_date"] = "news:publication_date";
		  TagNames2["news:title"] = "news:title";
		  TagNames2["news:keywords"] = "news:keywords";
		  TagNames2["news:stock_tickers"] = "news:stock_tickers";
		  TagNames2["news:language"] = "news:language";
		  TagNames2["mobile:mobile"] = "mobile:mobile";
		  TagNames2["xhtml:link"] = "xhtml:link";
		  TagNames2["expires"] = "expires";
		})(exports.TagNames || (exports.TagNames = {}));
		(function(IndexTagNames2) {
		  IndexTagNames2["sitemap"] = "sitemap";
		  IndexTagNames2["sitemapindex"] = "sitemapindex";
		  IndexTagNames2["loc"] = "loc";
		  IndexTagNames2["lastmod"] = "lastmod";
		})(exports.IndexTagNames || (exports.IndexTagNames = {})); 
	} (types));
	return types;
}

var sitemapXml = {};

var hasRequiredSitemapXml;

function requireSitemapXml () {
	if (hasRequiredSitemapXml) return sitemapXml;
	hasRequiredSitemapXml = 1;
	Object.defineProperty(sitemapXml, "__esModule", { value: true });
	sitemapXml.element = sitemapXml.ctag = sitemapXml.otag = sitemapXml.text = void 0;
	const invalidXMLUnicodeRegex = (
	  // eslint-disable-next-line no-control-regex
	  /[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u0084\u0086-\u009F\uD800-\uDFFF\uFDD0-\uFDDF\u{1FFFE}-\u{1FFFF}\u{2FFFE}-\u{2FFFF}\u{3FFFE}-\u{3FFFF}\u{4FFFE}-\u{4FFFF}\u{5FFFE}-\u{5FFFF}\u{6FFFE}-\u{6FFFF}\u{7FFFE}-\u{7FFFF}\u{8FFFE}-\u{8FFFF}\u{9FFFE}-\u{9FFFF}\u{AFFFE}-\u{AFFFF}\u{BFFFE}-\u{BFFFF}\u{CFFFE}-\u{CFFFF}\u{DFFFE}-\u{DFFFF}\u{EFFFE}-\u{EFFFF}\u{FFFFE}-\u{FFFFF}\u{10FFFE}-\u{10FFFF}]/gu
	);
	const amp = /&/g;
	const lt = /</g;
	const apos = /'/g;
	const quot = /"/g;
	function text(txt) {
	  return txt.replace(amp, "&amp;").replace(lt, "&lt;").replace(invalidXMLUnicodeRegex, "");
	}
	sitemapXml.text = text;
	function otag(nodeName, attrs, selfClose = false) {
	  let attrstr = "";
	  for (const k in attrs) {
	    const val = attrs[k].replace(amp, "&amp;").replace(lt, "&lt;").replace(apos, "&apos;").replace(quot, "&quot;").replace(invalidXMLUnicodeRegex, "");
	    attrstr += ` ${k}="${val}"`;
	  }
	  return `<${nodeName}${attrstr}${selfClose ? "/" : ""}>`;
	}
	sitemapXml.otag = otag;
	function ctag(nodeName) {
	  return `</${nodeName}>`;
	}
	sitemapXml.ctag = ctag;
	function element(nodeName, attrs, innerText) {
	  if (typeof attrs === "string") {
	    return otag(nodeName) + text(attrs) + ctag(nodeName);
	  } else if (innerText) {
	    return otag(nodeName, attrs) + text(innerText) + ctag(nodeName);
	  } else {
	    return otag(nodeName, attrs, true);
	  }
	}
	sitemapXml.element = element;
	return sitemapXml;
}

var hasRequiredSitemapItemStream;

function requireSitemapItemStream () {
	if (hasRequiredSitemapItemStream) return sitemapItemStream;
	hasRequiredSitemapItemStream = 1;
	Object.defineProperty(sitemapItemStream, "__esModule", { value: true });
	sitemapItemStream.SitemapItemStream = void 0;
	const stream_1 = require$$0;
	const errors_1 = requireErrors();
	const types_1 = requireTypes();
	const sitemap_xml_1 = requireSitemapXml();
	function attrBuilder(conf, keys) {
	  if (typeof keys === "string") {
	    keys = [keys];
	  }
	  const iv = {};
	  return keys.reduce((attrs, key) => {
	    if (conf[key] !== void 0) {
	      const keyAr = key.split(":");
	      if (keyAr.length !== 2) {
	        throw new errors_1.InvalidAttr(key);
	      }
	      attrs[keyAr[1]] = conf[key];
	    }
	    return attrs;
	  }, iv);
	}
	class SitemapItemStream extends stream_1.Transform {
	  constructor(opts = { level: types_1.ErrorLevel.WARN }) {
	    opts.objectMode = true;
	    super(opts);
	    this.level = opts.level || types_1.ErrorLevel.WARN;
	  }
	  _transform(item, encoding, callback) {
	    this.push((0, sitemap_xml_1.otag)(types_1.TagNames.url));
	    this.push((0, sitemap_xml_1.element)(types_1.TagNames.loc, item.url));
	    if (item.lastmod) {
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames.lastmod, item.lastmod));
	    }
	    if (item.changefreq) {
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames.changefreq, item.changefreq));
	    }
	    if (item.priority !== void 0 && item.priority !== null) {
	      if (item.fullPrecisionPriority) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames.priority, item.priority.toString()));
	      } else {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames.priority, item.priority.toFixed(1)));
	      }
	    }
	    item.video.forEach((video) => {
	      this.push((0, sitemap_xml_1.otag)(types_1.TagNames["video:video"]));
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:thumbnail_loc"], video.thumbnail_loc));
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:title"], video.title));
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:description"], video.description));
	      if (video.content_loc) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:content_loc"], video.content_loc));
	      }
	      if (video.player_loc) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:player_loc"], attrBuilder(video, [
	          "player_loc:autoplay",
	          "player_loc:allow_embed"
	        ]), video.player_loc));
	      }
	      if (video.duration) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:duration"], video.duration.toString()));
	      }
	      if (video.expiration_date) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:expiration_date"], video.expiration_date));
	      }
	      if (video.rating !== void 0) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:rating"], video.rating.toString()));
	      }
	      if (video.view_count !== void 0) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:view_count"], video.view_count.toString()));
	      }
	      if (video.publication_date) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:publication_date"], video.publication_date));
	      }
	      for (const tag of video.tag) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:tag"], tag));
	      }
	      if (video.category) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:category"], video.category));
	      }
	      if (video.family_friendly) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:family_friendly"], video.family_friendly));
	      }
	      if (video.restriction) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:restriction"], attrBuilder(video, "restriction:relationship"), video.restriction));
	      }
	      if (video.gallery_loc) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:gallery_loc"], { title: video["gallery_loc:title"] }, video.gallery_loc));
	      }
	      if (video.price) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:price"], attrBuilder(video, [
	          "price:resolution",
	          "price:currency",
	          "price:type"
	        ]), video.price));
	      }
	      if (video.requires_subscription) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:requires_subscription"], video.requires_subscription));
	      }
	      if (video.uploader) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:uploader"], attrBuilder(video, "uploader:info"), video.uploader));
	      }
	      if (video.platform) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:platform"], attrBuilder(video, "platform:relationship"), video.platform));
	      }
	      if (video.live) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:live"], video.live));
	      }
	      if (video.id) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:id"], { type: "url" }, video.id));
	      }
	      this.push((0, sitemap_xml_1.ctag)(types_1.TagNames["video:video"]));
	    });
	    item.links.forEach((link) => {
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames["xhtml:link"], {
	        rel: "alternate",
	        hreflang: link.lang || link.hreflang,
	        href: link.url
	      }));
	    });
	    if (item.expires) {
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames.expires, new Date(item.expires).toISOString()));
	    }
	    if (item.androidLink) {
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames["xhtml:link"], {
	        rel: "alternate",
	        href: item.androidLink
	      }));
	    }
	    if (item.ampLink) {
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames["xhtml:link"], {
	        rel: "amphtml",
	        href: item.ampLink
	      }));
	    }
	    if (item.news) {
	      this.push((0, sitemap_xml_1.otag)(types_1.TagNames["news:news"]));
	      this.push((0, sitemap_xml_1.otag)(types_1.TagNames["news:publication"]));
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:name"], item.news.publication.name));
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:language"], item.news.publication.language));
	      this.push((0, sitemap_xml_1.ctag)(types_1.TagNames["news:publication"]));
	      if (item.news.access) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:access"], item.news.access));
	      }
	      if (item.news.genres) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:genres"], item.news.genres));
	      }
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:publication_date"], item.news.publication_date));
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:title"], item.news.title));
	      if (item.news.keywords) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:keywords"], item.news.keywords));
	      }
	      if (item.news.stock_tickers) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:stock_tickers"], item.news.stock_tickers));
	      }
	      this.push((0, sitemap_xml_1.ctag)(types_1.TagNames["news:news"]));
	    }
	    item.img.forEach((image) => {
	      this.push((0, sitemap_xml_1.otag)(types_1.TagNames["image:image"]));
	      this.push((0, sitemap_xml_1.element)(types_1.TagNames["image:loc"], image.url));
	      if (image.caption) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["image:caption"], image.caption));
	      }
	      if (image.geoLocation) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["image:geo_location"], image.geoLocation));
	      }
	      if (image.title) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["image:title"], image.title));
	      }
	      if (image.license) {
	        this.push((0, sitemap_xml_1.element)(types_1.TagNames["image:license"], image.license));
	      }
	      this.push((0, sitemap_xml_1.ctag)(types_1.TagNames["image:image"]));
	    });
	    this.push((0, sitemap_xml_1.ctag)(types_1.TagNames.url));
	    callback();
	  }
	}
	sitemapItemStream.SitemapItemStream = SitemapItemStream;
	return sitemapItemStream;
}

var sitemapIndexStream = {};

var sitemapStream = {};

var utils$4 = {};

var hasRequiredUtils$4;

function requireUtils$4 () {
	if (hasRequiredUtils$4) return utils$4;
	hasRequiredUtils$4 = 1;
	var __defProp = Object.defineProperty;
	var __defProps = Object.defineProperties;
	var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols = Object.getOwnPropertySymbols;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __propIsEnum = Object.prototype.propertyIsEnumerable;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp.call(b, prop))
	      __defNormalProp(a, prop, b[prop]);
	  if (__getOwnPropSymbols)
	    for (var prop of __getOwnPropSymbols(b)) {
	      if (__propIsEnum.call(b, prop))
	        __defNormalProp(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
	Object.defineProperty(utils$4, "__esModule", { value: true });
	utils$4.normalizeURL = utils$4.chunk = utils$4.lineSeparatedURLsToSitemapOptions = utils$4.ReadlineStream = utils$4.mergeStreams = utils$4.validateSMIOptions = void 0;
	/*!
	 * Sitemap
	 * Copyright(c) 2011 Eugene Kalinin
	 * MIT Licensed
	 */
	const fs_1 = require$$0$1;
	const stream_1 = require$$0;
	const readline_1 = require$$2;
	const url_1 = require$$3;
	const types_1 = requireTypes();
	const errors_1 = requireErrors();
	const types_2 = requireTypes();
	function validate(subject, name, url, level) {
	  Object.keys(subject).forEach((key) => {
	    const val = subject[key];
	    if (types_2.validators[key] && !types_2.validators[key].test(val)) {
	      if (level === types_1.ErrorLevel.THROW) {
	        throw new errors_1.InvalidAttrValue(key, val, types_2.validators[key]);
	      } else {
	        console.warn(`${url}: ${name} key ${key} has invalid value: ${val}`);
	      }
	    }
	  });
	}
	function handleError(error, level) {
	  if (level === types_1.ErrorLevel.THROW) {
	    throw error;
	  } else if (level === types_1.ErrorLevel.WARN) {
	    console.warn(error.name, error.message);
	  }
	}
	function validateSMIOptions(conf, level = types_1.ErrorLevel.WARN, errorHandler = handleError) {
	  if (!conf) {
	    throw new errors_1.NoConfigError();
	  }
	  if (level === types_1.ErrorLevel.SILENT) {
	    return conf;
	  }
	  const { url, changefreq, priority, news, video } = conf;
	  if (!url) {
	    errorHandler(new errors_1.NoURLError(), level);
	  }
	  if (changefreq) {
	    if (!(0, types_1.isValidChangeFreq)(changefreq)) {
	      errorHandler(new errors_1.ChangeFreqInvalidError(url, changefreq), level);
	    }
	  }
	  if (priority) {
	    if (!(priority >= 0 && priority <= 1)) {
	      errorHandler(new errors_1.PriorityInvalidError(url, priority), level);
	    }
	  }
	  if (news) {
	    if (news.access && news.access !== "Registration" && news.access !== "Subscription") {
	      errorHandler(new errors_1.InvalidNewsAccessValue(url, news.access), level);
	    }
	    if (!news.publication || !news.publication.name || !news.publication.language || !news.publication_date || !news.title) {
	      errorHandler(new errors_1.InvalidNewsFormat(url), level);
	    }
	    validate(news, "news", url, level);
	    validate(news.publication, "publication", url, level);
	  }
	  if (video) {
	    video.forEach((vid) => {
	      var _a;
	      if (vid.duration !== void 0) {
	        if (vid.duration < 0 || vid.duration > 28800) {
	          errorHandler(new errors_1.InvalidVideoDuration(url, vid.duration), level);
	        }
	      }
	      if (vid.rating !== void 0 && (vid.rating < 0 || vid.rating > 5)) {
	        errorHandler(new errors_1.InvalidVideoRating(url, vid.title, vid.rating), level);
	      }
	      if (typeof vid !== "object" || !vid.thumbnail_loc || !vid.title || !vid.description) {
	        errorHandler(new errors_1.InvalidVideoFormat(url), level);
	      }
	      if (vid.title.length > 100) {
	        errorHandler(new errors_1.InvalidVideoTitle(url, vid.title.length), level);
	      }
	      if (vid.description.length > 2048) {
	        errorHandler(new errors_1.InvalidVideoDescription(url, vid.description.length), level);
	      }
	      if (vid.view_count !== void 0 && vid.view_count < 0) {
	        errorHandler(new errors_1.InvalidVideoViewCount(url, vid.view_count), level);
	      }
	      if (vid.tag.length > 32) {
	        errorHandler(new errors_1.InvalidVideoTagCount(url, vid.tag.length), level);
	      }
	      if (vid.category !== void 0 && ((_a = vid.category) === null || _a === void 0 ? void 0 : _a.length) > 256) {
	        errorHandler(new errors_1.InvalidVideoCategory(url, vid.category.length), level);
	      }
	      if (vid.family_friendly !== void 0 && !(0, types_1.isValidYesNo)(vid.family_friendly)) {
	        errorHandler(new errors_1.InvalidVideoFamilyFriendly(url, vid.family_friendly), level);
	      }
	      if (vid.restriction) {
	        if (!types_2.validators.restriction.test(vid.restriction)) {
	          errorHandler(new errors_1.InvalidVideoRestriction(url, vid.restriction), level);
	        }
	        if (!vid["restriction:relationship"] || !(0, types_1.isAllowDeny)(vid["restriction:relationship"])) {
	          errorHandler(new errors_1.InvalidVideoRestrictionRelationship(url, vid["restriction:relationship"]), level);
	        }
	      }
	      if (vid.price === "" && vid["price:type"] === void 0 || vid["price:type"] !== void 0 && !(0, types_1.isPriceType)(vid["price:type"])) {
	        errorHandler(new errors_1.InvalidVideoPriceType(url, vid["price:type"], vid.price), level);
	      }
	      if (vid["price:resolution"] !== void 0 && !(0, types_1.isResolution)(vid["price:resolution"])) {
	        errorHandler(new errors_1.InvalidVideoResolution(url, vid["price:resolution"]), level);
	      }
	      if (vid["price:currency"] !== void 0 && !types_2.validators["price:currency"].test(vid["price:currency"])) {
	        errorHandler(new errors_1.InvalidVideoPriceCurrency(url, vid["price:currency"]), level);
	      }
	      validate(vid, "video", url, level);
	    });
	  }
	  return conf;
	}
	utils$4.validateSMIOptions = validateSMIOptions;
	function mergeStreams(streams, options) {
	  let pass = new stream_1.PassThrough(options);
	  let waiting = streams.length;
	  for (const stream of streams) {
	    pass = stream.pipe(pass, { end: false });
	    stream.once("end", () => --waiting === 0 && pass.emit("end"));
	  }
	  return pass;
	}
	utils$4.mergeStreams = mergeStreams;
	class ReadlineStream extends stream_1.Readable {
	  constructor(options) {
	    if (options.autoDestroy === void 0) {
	      options.autoDestroy = true;
	    }
	    options.objectMode = true;
	    super(options);
	    this._source = (0, readline_1.createInterface)({
	      input: options.input,
	      terminal: false,
	      crlfDelay: Infinity
	    });
	    this._source.on("line", (chunk2) => {
	      if (!this.push(chunk2))
	        this._source.pause();
	    });
	    this._source.on("close", () => {
	      this.push(null);
	    });
	  }
	  // _read() will be called when the stream wants to pull more data in.
	  // The advisory size argument is ignored in this case.
	  _read(size) {
	    this._source.resume();
	  }
	}
	utils$4.ReadlineStream = ReadlineStream;
	function lineSeparatedURLsToSitemapOptions(stream, { isJSON } = {}) {
	  return new ReadlineStream({ input: stream }).pipe(new stream_1.Transform({
	    objectMode: true,
	    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
	    transform: (line, encoding, cb) => {
	      if (isJSON || isJSON === void 0 && line[0] === "{") {
	        cb(null, JSON.parse(line));
	      } else {
	        cb(null, line);
	      }
	    }
	  }));
	}
	utils$4.lineSeparatedURLsToSitemapOptions = lineSeparatedURLsToSitemapOptions;
	function chunk(array, size = 1) {
	  size = Math.max(Math.trunc(size), 0);
	  const length = array ? array.length : 0;
	  if (!length || size < 1) {
	    return [];
	  }
	  const result = Array(Math.ceil(length / size));
	  let index = 0, resIndex = 0;
	  while (index < length) {
	    result[resIndex++] = array.slice(index, index += size);
	  }
	  return result;
	}
	utils$4.chunk = chunk;
	function boolToYESNO(bool) {
	  if (bool === void 0) {
	    return bool;
	  }
	  if (typeof bool === "boolean") {
	    return bool ? types_1.EnumYesNo.yes : types_1.EnumYesNo.no;
	  }
	  return bool;
	}
	function normalizeURL(elem, hostname, lastmodDateOnly = false) {
	  let smi = {
	    img: [],
	    video: [],
	    links: [],
	    url: ""
	  };
	  let smiLoose;
	  if (typeof elem === "string") {
	    smi.url = elem;
	    smiLoose = { url: elem };
	  } else {
	    smiLoose = elem;
	  }
	  smi.url = new url_1.URL(smiLoose.url, hostname).toString();
	  let img = [];
	  if (smiLoose.img) {
	    if (typeof smiLoose.img === "string") {
	      smiLoose.img = [{ url: smiLoose.img }];
	    } else if (!Array.isArray(smiLoose.img)) {
	      smiLoose.img = [smiLoose.img];
	    }
	    img = smiLoose.img.map((el) => typeof el === "string" ? { url: el } : el);
	  }
	  smi.img = img.map((el) => __spreadProps(__spreadValues({}, el), {
	    url: new url_1.URL(el.url, hostname).toString()
	  }));
	  let links = [];
	  if (smiLoose.links) {
	    links = smiLoose.links;
	  }
	  smi.links = links.map((link) => {
	    return __spreadProps(__spreadValues({}, link), { url: new url_1.URL(link.url, hostname).toString() });
	  });
	  if (smiLoose.video) {
	    if (!Array.isArray(smiLoose.video)) {
	      smiLoose.video = [smiLoose.video];
	    }
	    smi.video = smiLoose.video.map((video) => {
	      const nv = __spreadProps(__spreadValues({}, video), {
	        family_friendly: boolToYESNO(video.family_friendly),
	        live: boolToYESNO(video.live),
	        requires_subscription: boolToYESNO(video.requires_subscription),
	        tag: [],
	        rating: void 0
	      });
	      if (video.tag !== void 0) {
	        nv.tag = !Array.isArray(video.tag) ? [video.tag] : video.tag;
	      }
	      if (video.rating !== void 0) {
	        if (typeof video.rating === "string") {
	          nv.rating = parseFloat(video.rating);
	        } else {
	          nv.rating = video.rating;
	        }
	      }
	      if (typeof video.view_count === "string") {
	        nv.view_count = parseInt(video.view_count, 10);
	      } else if (typeof video.view_count === "number") {
	        nv.view_count = video.view_count;
	      }
	      return nv;
	    });
	  }
	  if (smiLoose.lastmodfile) {
	    const { mtime } = (0, fs_1.statSync)(smiLoose.lastmodfile);
	    smi.lastmod = new Date(mtime).toISOString();
	  } else if (smiLoose.lastmodISO) {
	    smi.lastmod = new Date(smiLoose.lastmodISO).toISOString();
	  } else if (smiLoose.lastmod) {
	    smi.lastmod = new Date(smiLoose.lastmod).toISOString();
	  }
	  if (lastmodDateOnly && smi.lastmod) {
	    smi.lastmod = smi.lastmod.slice(0, 10);
	  }
	  delete smiLoose.lastmodfile;
	  delete smiLoose.lastmodISO;
	  smi = __spreadValues(__spreadValues({}, smiLoose), smi);
	  return smi;
	}
	utils$4.normalizeURL = normalizeURL;
	return utils$4;
}

var hasRequiredSitemapStream;

function requireSitemapStream () {
	if (hasRequiredSitemapStream) return sitemapStream;
	hasRequiredSitemapStream = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.streamToPromise = exports.SitemapStream = exports.closetag = exports.stylesheetInclude = void 0;
		const stream_1 = require$$0;
		const types_1 = requireTypes();
		const utils_1 = requireUtils$4();
		const sitemap_item_stream_1 = requireSitemapItemStream();
		const errors_1 = requireErrors();
		const xmlDec = '<?xml version="1.0" encoding="UTF-8"?>';
		const stylesheetInclude = (url) => {
		  return `<?xml-stylesheet type="text/xsl" href="${url}"?>`;
		};
		exports.stylesheetInclude = stylesheetInclude;
		const urlsetTagStart = '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"';
		const getURLSetNs = ({ news, video, image, xhtml, custom }, xslURL) => {
		  let ns = xmlDec;
		  if (xslURL) {
		    ns += (0, exports.stylesheetInclude)(xslURL);
		  }
		  ns += urlsetTagStart;
		  if (news) {
		    ns += ' xmlns:news="http://www.google.com/schemas/sitemap-news/0.9"';
		  }
		  if (xhtml) {
		    ns += ' xmlns:xhtml="http://www.w3.org/1999/xhtml"';
		  }
		  if (image) {
		    ns += ' xmlns:image="http://www.google.com/schemas/sitemap-image/1.1"';
		  }
		  if (video) {
		    ns += ' xmlns:video="http://www.google.com/schemas/sitemap-video/1.1"';
		  }
		  if (custom) {
		    ns += " " + custom.join(" ");
		  }
		  return ns + ">";
		};
		exports.closetag = "</urlset>";
		const defaultXMLNS = {
		  news: true,
		  xhtml: true,
		  image: true,
		  video: true
		};
		const defaultStreamOpts = {
		  xmlns: defaultXMLNS
		};
		class SitemapStream extends stream_1.Transform {
		  constructor(opts = defaultStreamOpts) {
		    opts.objectMode = true;
		    super(opts);
		    this.hasHeadOutput = false;
		    this.hostname = opts.hostname;
		    this.level = opts.level || types_1.ErrorLevel.WARN;
		    this.errorHandler = opts.errorHandler;
		    this.smiStream = new sitemap_item_stream_1.SitemapItemStream({ level: opts.level });
		    this.smiStream.on("data", (data) => this.push(data));
		    this.lastmodDateOnly = opts.lastmodDateOnly || false;
		    this.xmlNS = opts.xmlns || defaultXMLNS;
		    this.xslUrl = opts.xslUrl;
		  }
		  _transform(item, encoding, callback) {
		    if (!this.hasHeadOutput) {
		      this.hasHeadOutput = true;
		      this.push(getURLSetNs(this.xmlNS, this.xslUrl));
		    }
		    if (!this.smiStream.write((0, utils_1.validateSMIOptions)((0, utils_1.normalizeURL)(item, this.hostname, this.lastmodDateOnly), this.level, this.errorHandler))) {
		      this.smiStream.once("drain", callback);
		    } else {
		      process.nextTick(callback);
		    }
		  }
		  _flush(cb) {
		    if (!this.hasHeadOutput) {
		      cb(new errors_1.EmptySitemap());
		    } else {
		      this.push(exports.closetag);
		      cb();
		    }
		  }
		}
		exports.SitemapStream = SitemapStream;
		function streamToPromise(stream) {
		  return new Promise((resolve, reject) => {
		    const drain = [];
		    stream.on("error", reject).pipe(new stream_1.Writable({
		      write(chunk, enc, next) {
		        drain.push(chunk);
		        next();
		      }
		    })).on("error", reject).on("finish", () => {
		      if (!drain.length) {
		        reject(new errors_1.EmptyStream());
		      } else {
		        resolve(Buffer.concat(drain));
		      }
		    });
		  });
		}
		exports.streamToPromise = streamToPromise; 
	} (sitemapStream));
	return sitemapStream;
}

var hasRequiredSitemapIndexStream;

function requireSitemapIndexStream () {
	if (hasRequiredSitemapIndexStream) return sitemapIndexStream;
	hasRequiredSitemapIndexStream = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SitemapAndIndexStream = exports.SitemapIndexStream = exports.IndexTagNames = void 0;
		const stream_1 = require$$0;
		const types_1 = requireTypes();
		const sitemap_stream_1 = requireSitemapStream();
		const sitemap_xml_1 = requireSitemapXml();
		var IndexTagNames;
		(function(IndexTagNames2) {
		  IndexTagNames2["sitemap"] = "sitemap";
		  IndexTagNames2["loc"] = "loc";
		  IndexTagNames2["lastmod"] = "lastmod";
		})(IndexTagNames = exports.IndexTagNames || (exports.IndexTagNames = {}));
		const xmlDec = '<?xml version="1.0" encoding="UTF-8"?>';
		const sitemapIndexTagStart = '<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">';
		const closetag = "</sitemapindex>";
		const defaultStreamOpts = {};
		class SitemapIndexStream extends stream_1.Transform {
		  /**
		   * `SitemapIndexStream` is a Transform stream that takes `IndexItem`s or sitemap URL strings and outputs a stream of sitemap index XML.
		   *
		   * It automatically handles the XML declaration and the opening and closing tags for the sitemap index.
		   *
		   * ⚠️ CAUTION: This object is `readable` and must be read (e.g. piped to a file or to /dev/null)
		   * before `finish` will be emitted. Failure to read the stream will result in hangs.
		   *
		   * @param {SitemapIndexStreamOptions} [opts=defaultStreamOpts] - Stream options.
		   */
		  constructor(opts = defaultStreamOpts) {
		    var _a;
		    opts.objectMode = true;
		    super(opts);
		    this.hasHeadOutput = false;
		    this.lastmodDateOnly = opts.lastmodDateOnly || false;
		    this.level = (_a = opts.level) !== null && _a !== void 0 ? _a : types_1.ErrorLevel.WARN;
		    this.xslUrl = opts.xslUrl;
		  }
		  writeHeadOutput() {
		    this.hasHeadOutput = true;
		    let stylesheet = "";
		    if (this.xslUrl) {
		      stylesheet = (0, sitemap_stream_1.stylesheetInclude)(this.xslUrl);
		    }
		    this.push(xmlDec + stylesheet + sitemapIndexTagStart);
		  }
		  _transform(item, encoding, callback) {
		    if (!this.hasHeadOutput) {
		      this.writeHeadOutput();
		    }
		    this.push((0, sitemap_xml_1.otag)(IndexTagNames.sitemap));
		    if (typeof item === "string") {
		      this.push((0, sitemap_xml_1.element)(IndexTagNames.loc, item));
		    } else {
		      this.push((0, sitemap_xml_1.element)(IndexTagNames.loc, item.url));
		      if (item.lastmod) {
		        const lastmod = new Date(item.lastmod).toISOString();
		        this.push((0, sitemap_xml_1.element)(IndexTagNames.lastmod, this.lastmodDateOnly ? lastmod.slice(0, 10) : lastmod));
		      }
		    }
		    this.push((0, sitemap_xml_1.ctag)(IndexTagNames.sitemap));
		    callback();
		  }
		  _flush(cb) {
		    if (!this.hasHeadOutput) {
		      this.writeHeadOutput();
		    }
		    this.push(closetag);
		    cb();
		  }
		}
		exports.SitemapIndexStream = SitemapIndexStream;
		class SitemapAndIndexStream extends SitemapIndexStream {
		  /**
		   * `SitemapAndIndexStream` is a Transform stream that takes in sitemap items,
		   * writes them to sitemap files, adds the sitemap files to a sitemap index,
		   * and creates new sitemap files when the count limit is reached.
		   *
		   * It waits for the target stream of the current sitemap file to finish before
		   * moving on to the next if the target stream is returned by the `getSitemapStream`
		   * callback in the 3rd position of the tuple.
		   *
		   * ⚠️ CAUTION: This object is `readable` and must be read (e.g. piped to a file or to /dev/null)
		   * before `finish` will be emitted. Failure to read the stream will result in hangs.
		   *
		   * @param {SitemapAndIndexStreamOptions} opts - Stream options.
		   */
		  constructor(opts) {
		    var _a;
		    opts.objectMode = true;
		    super(opts);
		    this.itemsWritten = 0;
		    this.getSitemapStream = opts.getSitemapStream;
		    this.limit = (_a = opts.limit) !== null && _a !== void 0 ? _a : 45e3;
		  }
		  _transform(item, encoding, callback) {
		    if (this.itemsWritten % this.limit === 0) {
		      if (this.currentSitemap) {
		        const onFinish = new Promise((resolve, reject) => {
		          var _a, _b, _c;
		          (_a = this.currentSitemap) === null || _a === void 0 ? void 0 : _a.on("finish", resolve);
		          (_b = this.currentSitemap) === null || _b === void 0 ? void 0 : _b.on("error", reject);
		          (_c = this.currentSitemap) === null || _c === void 0 ? void 0 : _c.end();
		        });
		        const onPipelineFinish = this.currentSitemapPipeline ? new Promise((resolve, reject) => {
		          var _a, _b;
		          (_a = this.currentSitemapPipeline) === null || _a === void 0 ? void 0 : _a.on("finish", resolve);
		          (_b = this.currentSitemapPipeline) === null || _b === void 0 ? void 0 : _b.on("error", reject);
		        }) : Promise.resolve();
		        Promise.all([onFinish, onPipelineFinish]).then(() => {
		          this.createSitemap(encoding);
		          this.writeItem(item, callback);
		        }).catch(callback);
		        return;
		      } else {
		        this.createSitemap(encoding);
		      }
		    }
		    this.writeItem(item, callback);
		  }
		  writeItem(item, callback) {
		    if (!this.currentSitemap) {
		      callback(new Error("No sitemap stream available"));
		      return;
		    }
		    if (!this.currentSitemap.write(item)) {
		      this.currentSitemap.once("drain", callback);
		    } else {
		      process.nextTick(callback);
		    }
		    this.itemsWritten++;
		  }
		  /**
		   * Called when the stream is finished.
		   * If there is a current sitemap, we wait for it to finish before calling the callback.
		   *
		   * @param cb
		   */
		  _flush(cb) {
		    const onFinish = new Promise((resolve, reject) => {
		      if (this.currentSitemap) {
		        this.currentSitemap.on("finish", resolve);
		        this.currentSitemap.on("error", reject);
		        this.currentSitemap.end();
		      } else {
		        resolve();
		      }
		    });
		    const onPipelineFinish = new Promise((resolve, reject) => {
		      if (this.currentSitemapPipeline) {
		        this.currentSitemapPipeline.on("finish", resolve);
		        this.currentSitemapPipeline.on("error", reject);
		      } else {
		        resolve();
		      }
		    });
		    Promise.all([onFinish, onPipelineFinish]).then(() => {
		      super._flush(cb);
		    }).catch((err) => {
		      cb(err);
		    });
		  }
		  createSitemap(encoding) {
		    const [idxItem, currentSitemap, currentSitemapPipeline] = this.getSitemapStream(this.itemsWritten / this.limit);
		    currentSitemap.on("error", (err) => this.emit("error", err));
		    this.currentSitemap = currentSitemap;
		    this.currentSitemapPipeline = currentSitemapPipeline;
		    super._transform(idxItem, encoding, () => {
		    });
		  }
		}
		exports.SitemapAndIndexStream = SitemapAndIndexStream; 
	} (sitemapIndexStream));
	return sitemapIndexStream;
}

var xmllint = {};

var hasRequiredXmllint;

function requireXmllint () {
	if (hasRequiredXmllint) return xmllint;
	hasRequiredXmllint = 1;
	Object.defineProperty(xmllint, "__esModule", { value: true });
	xmllint.xmlLint = void 0;
	const path_1 = require$$0$2;
	const child_process_1 = require$$1;
	const errors_1 = requireErrors();
	function xmlLint(xml) {
	  const args = [
	    "--schema",
	    (0, path_1.resolve)(__dirname, "..", "..", "schema", "all.xsd"),
	    "--noout",
	    "-"
	  ];
	  if (typeof xml === "string") {
	    args[args.length - 1] = xml;
	  }
	  return new Promise((resolve, reject) => {
	    (0, child_process_1.execFile)("which", ["xmllint"], (error, stdout, stderr) => {
	      if (error) {
	        reject([new errors_1.XMLLintUnavailable()]);
	        return;
	      }
	      const xmllint = (0, child_process_1.execFile)("xmllint", args, (error2, stdout2, stderr2) => {
	        if (error2) {
	          reject([error2, stderr2]);
	        }
	        resolve();
	      });
	      if (xmllint.stdout) {
	        xmllint.stdout.unpipe();
	        if (typeof xml !== "string" && xml && xmllint.stdin) {
	          xml.pipe(xmllint.stdin);
	        }
	      }
	    });
	  });
	}
	xmllint.xmlLint = xmlLint;
	return xmllint;
}

var sitemapParser = {};

var sax = {};

var hasRequiredSax;

function requireSax () {
	if (hasRequiredSax) return sax;
	hasRequiredSax = 1;
	(function (exports) {
		(function(sax) {
		  sax.parser = function(strict, opt) {
		    return new SAXParser(strict, opt);
		  };
		  sax.SAXParser = SAXParser;
		  sax.SAXStream = SAXStream;
		  sax.createStream = createStream;
		  sax.MAX_BUFFER_LENGTH = 64 * 1024;
		  var buffers = [
		    "comment",
		    "sgmlDecl",
		    "textNode",
		    "tagName",
		    "doctype",
		    "procInstName",
		    "procInstBody",
		    "entity",
		    "attribName",
		    "attribValue",
		    "cdata",
		    "script"
		  ];
		  sax.EVENTS = [
		    "text",
		    "processinginstruction",
		    "sgmldeclaration",
		    "doctype",
		    "comment",
		    "opentagstart",
		    "attribute",
		    "opentag",
		    "closetag",
		    "opencdata",
		    "cdata",
		    "closecdata",
		    "error",
		    "end",
		    "ready",
		    "script",
		    "opennamespace",
		    "closenamespace"
		  ];
		  function SAXParser(strict, opt) {
		    if (!(this instanceof SAXParser)) {
		      return new SAXParser(strict, opt);
		    }
		    var parser = this;
		    clearBuffers(parser);
		    parser.q = parser.c = "";
		    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
		    parser.opt = opt || {};
		    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
		    parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
		    parser.tags = [];
		    parser.closed = parser.closedRoot = parser.sawRoot = false;
		    parser.tag = parser.error = null;
		    parser.strict = !!strict;
		    parser.noscript = !!(strict || parser.opt.noscript);
		    parser.state = S.BEGIN;
		    parser.strictEntities = parser.opt.strictEntities;
		    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
		    parser.attribList = [];
		    if (parser.opt.xmlns) {
		      parser.ns = Object.create(rootNS);
		    }
		    parser.trackPosition = parser.opt.position !== false;
		    if (parser.trackPosition) {
		      parser.position = parser.line = parser.column = 0;
		    }
		    emit(parser, "onready");
		  }
		  if (!Object.create) {
		    Object.create = function(o) {
		      function F() {
		      }
		      F.prototype = o;
		      var newf = new F();
		      return newf;
		    };
		  }
		  if (!Object.keys) {
		    Object.keys = function(o) {
		      var a = [];
		      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
		      return a;
		    };
		  }
		  function checkBufferLength(parser) {
		    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
		    var maxActual = 0;
		    for (var i = 0, l = buffers.length; i < l; i++) {
		      var len = parser[buffers[i]].length;
		      if (len > maxAllowed) {
		        switch (buffers[i]) {
		          case "textNode":
		            closeText(parser);
		            break;
		          case "cdata":
		            emitNode(parser, "oncdata", parser.cdata);
		            parser.cdata = "";
		            break;
		          case "script":
		            emitNode(parser, "onscript", parser.script);
		            parser.script = "";
		            break;
		          default:
		            error(parser, "Max buffer length exceeded: " + buffers[i]);
		        }
		      }
		      maxActual = Math.max(maxActual, len);
		    }
		    var m = sax.MAX_BUFFER_LENGTH - maxActual;
		    parser.bufferCheckPosition = m + parser.position;
		  }
		  function clearBuffers(parser) {
		    for (var i = 0, l = buffers.length; i < l; i++) {
		      parser[buffers[i]] = "";
		    }
		  }
		  function flushBuffers(parser) {
		    closeText(parser);
		    if (parser.cdata !== "") {
		      emitNode(parser, "oncdata", parser.cdata);
		      parser.cdata = "";
		    }
		    if (parser.script !== "") {
		      emitNode(parser, "onscript", parser.script);
		      parser.script = "";
		    }
		  }
		  SAXParser.prototype = {
		    end: function() {
		      end(this);
		    },
		    write,
		    resume: function() {
		      this.error = null;
		      return this;
		    },
		    close: function() {
		      return this.write(null);
		    },
		    flush: function() {
		      flushBuffers(this);
		    }
		  };
		  var Stream;
		  try {
		    Stream = require("stream").Stream;
		  } catch (ex) {
		    Stream = function() {
		    };
		  }
		  if (!Stream) Stream = function() {
		  };
		  var streamWraps = sax.EVENTS.filter(function(ev) {
		    return ev !== "error" && ev !== "end";
		  });
		  function createStream(strict, opt) {
		    return new SAXStream(strict, opt);
		  }
		  function SAXStream(strict, opt) {
		    if (!(this instanceof SAXStream)) {
		      return new SAXStream(strict, opt);
		    }
		    Stream.apply(this);
		    this._parser = new SAXParser(strict, opt);
		    this.writable = true;
		    this.readable = true;
		    var me = this;
		    this._parser.onend = function() {
		      me.emit("end");
		    };
		    this._parser.onerror = function(er) {
		      me.emit("error", er);
		      me._parser.error = null;
		    };
		    this._decoder = null;
		    streamWraps.forEach(function(ev) {
		      Object.defineProperty(me, "on" + ev, {
		        get: function() {
		          return me._parser["on" + ev];
		        },
		        set: function(h) {
		          if (!h) {
		            me.removeAllListeners(ev);
		            me._parser["on" + ev] = h;
		            return h;
		          }
		          me.on(ev, h);
		        },
		        enumerable: true,
		        configurable: false
		      });
		    });
		  }
		  SAXStream.prototype = Object.create(Stream.prototype, {
		    constructor: {
		      value: SAXStream
		    }
		  });
		  SAXStream.prototype.write = function(data) {
		    if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
		      if (!this._decoder) {
		        var SD = require$$1$1.StringDecoder;
		        this._decoder = new SD("utf8");
		      }
		      data = this._decoder.write(data);
		    }
		    this._parser.write(data.toString());
		    this.emit("data", data);
		    return true;
		  };
		  SAXStream.prototype.end = function(chunk) {
		    if (chunk && chunk.length) {
		      this.write(chunk);
		    }
		    this._parser.end();
		    return true;
		  };
		  SAXStream.prototype.on = function(ev, handler) {
		    var me = this;
		    if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
		      me._parser["on" + ev] = function() {
		        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
		        args.splice(0, 0, ev);
		        me.emit.apply(me, args);
		      };
		    }
		    return Stream.prototype.on.call(me, ev, handler);
		  };
		  var CDATA = "[CDATA[";
		  var DOCTYPE = "DOCTYPE";
		  var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
		  var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
		  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
		  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
		  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
		  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
		  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
		  function isWhitespace(c) {
		    return c === " " || c === "\n" || c === "\r" || c === "	";
		  }
		  function isQuote(c) {
		    return c === '"' || c === "'";
		  }
		  function isAttribEnd(c) {
		    return c === ">" || isWhitespace(c);
		  }
		  function isMatch(regex, c) {
		    return regex.test(c);
		  }
		  function notMatch(regex, c) {
		    return !isMatch(regex, c);
		  }
		  var S = 0;
		  sax.STATE = {
		    BEGIN: S++,
		    // leading byte order mark or whitespace
		    BEGIN_WHITESPACE: S++,
		    // leading whitespace
		    TEXT: S++,
		    // general stuff
		    TEXT_ENTITY: S++,
		    // &amp and such.
		    OPEN_WAKA: S++,
		    // <
		    SGML_DECL: S++,
		    // <!BLARG
		    SGML_DECL_QUOTED: S++,
		    // <!BLARG foo "bar
		    DOCTYPE: S++,
		    // <!DOCTYPE
		    DOCTYPE_QUOTED: S++,
		    // <!DOCTYPE "//blah
		    DOCTYPE_DTD: S++,
		    // <!DOCTYPE "//blah" [ ...
		    DOCTYPE_DTD_QUOTED: S++,
		    // <!DOCTYPE "//blah" [ "foo
		    COMMENT_STARTING: S++,
		    // <!-
		    COMMENT: S++,
		    // <!--
		    COMMENT_ENDING: S++,
		    // <!-- blah -
		    COMMENT_ENDED: S++,
		    // <!-- blah --
		    CDATA: S++,
		    // <![CDATA[ something
		    CDATA_ENDING: S++,
		    // ]
		    CDATA_ENDING_2: S++,
		    // ]]
		    PROC_INST: S++,
		    // <?hi
		    PROC_INST_BODY: S++,
		    // <?hi there
		    PROC_INST_ENDING: S++,
		    // <?hi "there" ?
		    OPEN_TAG: S++,
		    // <strong
		    OPEN_TAG_SLASH: S++,
		    // <strong /
		    ATTRIB: S++,
		    // <a
		    ATTRIB_NAME: S++,
		    // <a foo
		    ATTRIB_NAME_SAW_WHITE: S++,
		    // <a foo _
		    ATTRIB_VALUE: S++,
		    // <a foo=
		    ATTRIB_VALUE_QUOTED: S++,
		    // <a foo="bar
		    ATTRIB_VALUE_CLOSED: S++,
		    // <a foo="bar"
		    ATTRIB_VALUE_UNQUOTED: S++,
		    // <a foo=bar
		    ATTRIB_VALUE_ENTITY_Q: S++,
		    // <foo bar="&quot;"
		    ATTRIB_VALUE_ENTITY_U: S++,
		    // <foo bar=&quot
		    CLOSE_TAG: S++,
		    // </a
		    CLOSE_TAG_SAW_WHITE: S++,
		    // </a   >
		    SCRIPT: S++,
		    // <script> ...
		    SCRIPT_ENDING: S++
		    // <script> ... <
		  };
		  sax.XML_ENTITIES = {
		    "amp": "&",
		    "gt": ">",
		    "lt": "<",
		    "quot": '"',
		    "apos": "'"
		  };
		  sax.ENTITIES = {
		    "amp": "&",
		    "gt": ">",
		    "lt": "<",
		    "quot": '"',
		    "apos": "'",
		    "AElig": 198,
		    "Aacute": 193,
		    "Acirc": 194,
		    "Agrave": 192,
		    "Aring": 197,
		    "Atilde": 195,
		    "Auml": 196,
		    "Ccedil": 199,
		    "ETH": 208,
		    "Eacute": 201,
		    "Ecirc": 202,
		    "Egrave": 200,
		    "Euml": 203,
		    "Iacute": 205,
		    "Icirc": 206,
		    "Igrave": 204,
		    "Iuml": 207,
		    "Ntilde": 209,
		    "Oacute": 211,
		    "Ocirc": 212,
		    "Ograve": 210,
		    "Oslash": 216,
		    "Otilde": 213,
		    "Ouml": 214,
		    "THORN": 222,
		    "Uacute": 218,
		    "Ucirc": 219,
		    "Ugrave": 217,
		    "Uuml": 220,
		    "Yacute": 221,
		    "aacute": 225,
		    "acirc": 226,
		    "aelig": 230,
		    "agrave": 224,
		    "aring": 229,
		    "atilde": 227,
		    "auml": 228,
		    "ccedil": 231,
		    "eacute": 233,
		    "ecirc": 234,
		    "egrave": 232,
		    "eth": 240,
		    "euml": 235,
		    "iacute": 237,
		    "icirc": 238,
		    "igrave": 236,
		    "iuml": 239,
		    "ntilde": 241,
		    "oacute": 243,
		    "ocirc": 244,
		    "ograve": 242,
		    "oslash": 248,
		    "otilde": 245,
		    "ouml": 246,
		    "szlig": 223,
		    "thorn": 254,
		    "uacute": 250,
		    "ucirc": 251,
		    "ugrave": 249,
		    "uuml": 252,
		    "yacute": 253,
		    "yuml": 255,
		    "copy": 169,
		    "reg": 174,
		    "nbsp": 160,
		    "iexcl": 161,
		    "cent": 162,
		    "pound": 163,
		    "curren": 164,
		    "yen": 165,
		    "brvbar": 166,
		    "sect": 167,
		    "uml": 168,
		    "ordf": 170,
		    "laquo": 171,
		    "not": 172,
		    "shy": 173,
		    "macr": 175,
		    "deg": 176,
		    "plusmn": 177,
		    "sup1": 185,
		    "sup2": 178,
		    "sup3": 179,
		    "acute": 180,
		    "micro": 181,
		    "para": 182,
		    "middot": 183,
		    "cedil": 184,
		    "ordm": 186,
		    "raquo": 187,
		    "frac14": 188,
		    "frac12": 189,
		    "frac34": 190,
		    "iquest": 191,
		    "times": 215,
		    "divide": 247,
		    "OElig": 338,
		    "oelig": 339,
		    "Scaron": 352,
		    "scaron": 353,
		    "Yuml": 376,
		    "fnof": 402,
		    "circ": 710,
		    "tilde": 732,
		    "Alpha": 913,
		    "Beta": 914,
		    "Gamma": 915,
		    "Delta": 916,
		    "Epsilon": 917,
		    "Zeta": 918,
		    "Eta": 919,
		    "Theta": 920,
		    "Iota": 921,
		    "Kappa": 922,
		    "Lambda": 923,
		    "Mu": 924,
		    "Nu": 925,
		    "Xi": 926,
		    "Omicron": 927,
		    "Pi": 928,
		    "Rho": 929,
		    "Sigma": 931,
		    "Tau": 932,
		    "Upsilon": 933,
		    "Phi": 934,
		    "Chi": 935,
		    "Psi": 936,
		    "Omega": 937,
		    "alpha": 945,
		    "beta": 946,
		    "gamma": 947,
		    "delta": 948,
		    "epsilon": 949,
		    "zeta": 950,
		    "eta": 951,
		    "theta": 952,
		    "iota": 953,
		    "kappa": 954,
		    "lambda": 955,
		    "mu": 956,
		    "nu": 957,
		    "xi": 958,
		    "omicron": 959,
		    "pi": 960,
		    "rho": 961,
		    "sigmaf": 962,
		    "sigma": 963,
		    "tau": 964,
		    "upsilon": 965,
		    "phi": 966,
		    "chi": 967,
		    "psi": 968,
		    "omega": 969,
		    "thetasym": 977,
		    "upsih": 978,
		    "piv": 982,
		    "ensp": 8194,
		    "emsp": 8195,
		    "thinsp": 8201,
		    "zwnj": 8204,
		    "zwj": 8205,
		    "lrm": 8206,
		    "rlm": 8207,
		    "ndash": 8211,
		    "mdash": 8212,
		    "lsquo": 8216,
		    "rsquo": 8217,
		    "sbquo": 8218,
		    "ldquo": 8220,
		    "rdquo": 8221,
		    "bdquo": 8222,
		    "dagger": 8224,
		    "Dagger": 8225,
		    "bull": 8226,
		    "hellip": 8230,
		    "permil": 8240,
		    "prime": 8242,
		    "Prime": 8243,
		    "lsaquo": 8249,
		    "rsaquo": 8250,
		    "oline": 8254,
		    "frasl": 8260,
		    "euro": 8364,
		    "image": 8465,
		    "weierp": 8472,
		    "real": 8476,
		    "trade": 8482,
		    "alefsym": 8501,
		    "larr": 8592,
		    "uarr": 8593,
		    "rarr": 8594,
		    "darr": 8595,
		    "harr": 8596,
		    "crarr": 8629,
		    "lArr": 8656,
		    "uArr": 8657,
		    "rArr": 8658,
		    "dArr": 8659,
		    "hArr": 8660,
		    "forall": 8704,
		    "part": 8706,
		    "exist": 8707,
		    "empty": 8709,
		    "nabla": 8711,
		    "isin": 8712,
		    "notin": 8713,
		    "ni": 8715,
		    "prod": 8719,
		    "sum": 8721,
		    "minus": 8722,
		    "lowast": 8727,
		    "radic": 8730,
		    "prop": 8733,
		    "infin": 8734,
		    "ang": 8736,
		    "and": 8743,
		    "or": 8744,
		    "cap": 8745,
		    "cup": 8746,
		    "int": 8747,
		    "there4": 8756,
		    "sim": 8764,
		    "cong": 8773,
		    "asymp": 8776,
		    "ne": 8800,
		    "equiv": 8801,
		    "le": 8804,
		    "ge": 8805,
		    "sub": 8834,
		    "sup": 8835,
		    "nsub": 8836,
		    "sube": 8838,
		    "supe": 8839,
		    "oplus": 8853,
		    "otimes": 8855,
		    "perp": 8869,
		    "sdot": 8901,
		    "lceil": 8968,
		    "rceil": 8969,
		    "lfloor": 8970,
		    "rfloor": 8971,
		    "lang": 9001,
		    "rang": 9002,
		    "loz": 9674,
		    "spades": 9824,
		    "clubs": 9827,
		    "hearts": 9829,
		    "diams": 9830
		  };
		  Object.keys(sax.ENTITIES).forEach(function(key) {
		    var e = sax.ENTITIES[key];
		    var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
		    sax.ENTITIES[key] = s2;
		  });
		  for (var s in sax.STATE) {
		    sax.STATE[sax.STATE[s]] = s;
		  }
		  S = sax.STATE;
		  function emit(parser, event, data) {
		    parser[event] && parser[event](data);
		  }
		  function emitNode(parser, nodeType, data) {
		    if (parser.textNode) closeText(parser);
		    emit(parser, nodeType, data);
		  }
		  function closeText(parser) {
		    parser.textNode = textopts(parser.opt, parser.textNode);
		    if (parser.textNode) emit(parser, "ontext", parser.textNode);
		    parser.textNode = "";
		  }
		  function textopts(opt, text) {
		    if (opt.trim) text = text.trim();
		    if (opt.normalize) text = text.replace(/\s+/g, " ");
		    return text;
		  }
		  function error(parser, er) {
		    closeText(parser);
		    if (parser.trackPosition) {
		      er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
		    }
		    er = new Error(er);
		    parser.error = er;
		    emit(parser, "onerror", er);
		    return parser;
		  }
		  function end(parser) {
		    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
		    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
		      error(parser, "Unexpected end");
		    }
		    closeText(parser);
		    parser.c = "";
		    parser.closed = true;
		    emit(parser, "onend");
		    SAXParser.call(parser, parser.strict, parser.opt);
		    return parser;
		  }
		  function strictFail(parser, message) {
		    if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
		      throw new Error("bad call to strictFail");
		    }
		    if (parser.strict) {
		      error(parser, message);
		    }
		  }
		  function newTag(parser) {
		    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
		    var parent = parser.tags[parser.tags.length - 1] || parser;
		    var tag = parser.tag = { name: parser.tagName, attributes: {} };
		    if (parser.opt.xmlns) {
		      tag.ns = parent.ns;
		    }
		    parser.attribList.length = 0;
		    emitNode(parser, "onopentagstart", tag);
		  }
		  function qname(name, attribute) {
		    var i = name.indexOf(":");
		    var qualName = i < 0 ? ["", name] : name.split(":");
		    var prefix = qualName[0];
		    var local = qualName[1];
		    if (attribute && name === "xmlns") {
		      prefix = "xmlns";
		      local = "";
		    }
		    return { prefix, local };
		  }
		  function attrib(parser) {
		    if (!parser.strict) {
		      parser.attribName = parser.attribName[parser.looseCase]();
		    }
		    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
		      parser.attribName = parser.attribValue = "";
		      return;
		    }
		    if (parser.opt.xmlns) {
		      var qn = qname(parser.attribName, true);
		      var prefix = qn.prefix;
		      var local = qn.local;
		      if (prefix === "xmlns") {
		        if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
		          strictFail(
		            parser,
		            "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
		          );
		        } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
		          strictFail(
		            parser,
		            "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
		          );
		        } else {
		          var tag = parser.tag;
		          var parent = parser.tags[parser.tags.length - 1] || parser;
		          if (tag.ns === parent.ns) {
		            tag.ns = Object.create(parent.ns);
		          }
		          tag.ns[local] = parser.attribValue;
		        }
		      }
		      parser.attribList.push([parser.attribName, parser.attribValue]);
		    } else {
		      parser.tag.attributes[parser.attribName] = parser.attribValue;
		      emitNode(parser, "onattribute", {
		        name: parser.attribName,
		        value: parser.attribValue
		      });
		    }
		    parser.attribName = parser.attribValue = "";
		  }
		  function openTag(parser, selfClosing) {
		    if (parser.opt.xmlns) {
		      var tag = parser.tag;
		      var qn = qname(parser.tagName);
		      tag.prefix = qn.prefix;
		      tag.local = qn.local;
		      tag.uri = tag.ns[qn.prefix] || "";
		      if (tag.prefix && !tag.uri) {
		        strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
		        tag.uri = qn.prefix;
		      }
		      var parent = parser.tags[parser.tags.length - 1] || parser;
		      if (tag.ns && parent.ns !== tag.ns) {
		        Object.keys(tag.ns).forEach(function(p) {
		          emitNode(parser, "onopennamespace", {
		            prefix: p,
		            uri: tag.ns[p]
		          });
		        });
		      }
		      for (var i = 0, l = parser.attribList.length; i < l; i++) {
		        var nv = parser.attribList[i];
		        var name = nv[0];
		        var value = nv[1];
		        var qualName = qname(name, true);
		        var prefix = qualName.prefix;
		        var local = qualName.local;
		        var uri = prefix === "" ? "" : tag.ns[prefix] || "";
		        var a = {
		          name,
		          value,
		          prefix,
		          local,
		          uri
		        };
		        if (prefix && prefix !== "xmlns" && !uri) {
		          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
		          a.uri = prefix;
		        }
		        parser.tag.attributes[name] = a;
		        emitNode(parser, "onattribute", a);
		      }
		      parser.attribList.length = 0;
		    }
		    parser.tag.isSelfClosing = !!selfClosing;
		    parser.sawRoot = true;
		    parser.tags.push(parser.tag);
		    emitNode(parser, "onopentag", parser.tag);
		    if (!selfClosing) {
		      if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
		        parser.state = S.SCRIPT;
		      } else {
		        parser.state = S.TEXT;
		      }
		      parser.tag = null;
		      parser.tagName = "";
		    }
		    parser.attribName = parser.attribValue = "";
		    parser.attribList.length = 0;
		  }
		  function closeTag(parser) {
		    if (!parser.tagName) {
		      strictFail(parser, "Weird empty close tag.");
		      parser.textNode += "</>";
		      parser.state = S.TEXT;
		      return;
		    }
		    if (parser.script) {
		      if (parser.tagName !== "script") {
		        parser.script += "</" + parser.tagName + ">";
		        parser.tagName = "";
		        parser.state = S.SCRIPT;
		        return;
		      }
		      emitNode(parser, "onscript", parser.script);
		      parser.script = "";
		    }
		    var t = parser.tags.length;
		    var tagName = parser.tagName;
		    if (!parser.strict) {
		      tagName = tagName[parser.looseCase]();
		    }
		    var closeTo = tagName;
		    while (t--) {
		      var close = parser.tags[t];
		      if (close.name !== closeTo) {
		        strictFail(parser, "Unexpected close tag");
		      } else {
		        break;
		      }
		    }
		    if (t < 0) {
		      strictFail(parser, "Unmatched closing tag: " + parser.tagName);
		      parser.textNode += "</" + parser.tagName + ">";
		      parser.state = S.TEXT;
		      return;
		    }
		    parser.tagName = tagName;
		    var s2 = parser.tags.length;
		    while (s2-- > t) {
		      var tag = parser.tag = parser.tags.pop();
		      parser.tagName = parser.tag.name;
		      emitNode(parser, "onclosetag", parser.tagName);
		      var x = {};
		      for (var i in tag.ns) {
		        x[i] = tag.ns[i];
		      }
		      var parent = parser.tags[parser.tags.length - 1] || parser;
		      if (parser.opt.xmlns && tag.ns !== parent.ns) {
		        Object.keys(tag.ns).forEach(function(p) {
		          var n = tag.ns[p];
		          emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
		        });
		      }
		    }
		    if (t === 0) parser.closedRoot = true;
		    parser.tagName = parser.attribValue = parser.attribName = "";
		    parser.attribList.length = 0;
		    parser.state = S.TEXT;
		  }
		  function parseEntity(parser) {
		    var entity = parser.entity;
		    var entityLC = entity.toLowerCase();
		    var num;
		    var numStr = "";
		    if (parser.ENTITIES[entity]) {
		      return parser.ENTITIES[entity];
		    }
		    if (parser.ENTITIES[entityLC]) {
		      return parser.ENTITIES[entityLC];
		    }
		    entity = entityLC;
		    if (entity.charAt(0) === "#") {
		      if (entity.charAt(1) === "x") {
		        entity = entity.slice(2);
		        num = parseInt(entity, 16);
		        numStr = num.toString(16);
		      } else {
		        entity = entity.slice(1);
		        num = parseInt(entity, 10);
		        numStr = num.toString(10);
		      }
		    }
		    entity = entity.replace(/^0+/, "");
		    if (isNaN(num) || numStr.toLowerCase() !== entity) {
		      strictFail(parser, "Invalid character entity");
		      return "&" + parser.entity + ";";
		    }
		    return String.fromCodePoint(num);
		  }
		  function beginWhiteSpace(parser, c) {
		    if (c === "<") {
		      parser.state = S.OPEN_WAKA;
		      parser.startTagPosition = parser.position;
		    } else if (!isWhitespace(c)) {
		      strictFail(parser, "Non-whitespace before first tag.");
		      parser.textNode = c;
		      parser.state = S.TEXT;
		    }
		  }
		  function charAt(chunk, i) {
		    var result = "";
		    if (i < chunk.length) {
		      result = chunk.charAt(i);
		    }
		    return result;
		  }
		  function write(chunk) {
		    var parser = this;
		    if (this.error) {
		      throw this.error;
		    }
		    if (parser.closed) {
		      return error(
		        parser,
		        "Cannot write after close. Assign an onready handler."
		      );
		    }
		    if (chunk === null) {
		      return end(parser);
		    }
		    if (typeof chunk === "object") {
		      chunk = chunk.toString();
		    }
		    var i = 0;
		    var c = "";
		    while (true) {
		      c = charAt(chunk, i++);
		      parser.c = c;
		      if (!c) {
		        break;
		      }
		      if (parser.trackPosition) {
		        parser.position++;
		        if (c === "\n") {
		          parser.line++;
		          parser.column = 0;
		        } else {
		          parser.column++;
		        }
		      }
		      switch (parser.state) {
		        case S.BEGIN:
		          parser.state = S.BEGIN_WHITESPACE;
		          if (c === "\uFEFF") {
		            continue;
		          }
		          beginWhiteSpace(parser, c);
		          continue;
		        case S.BEGIN_WHITESPACE:
		          beginWhiteSpace(parser, c);
		          continue;
		        case S.TEXT:
		          if (parser.sawRoot && !parser.closedRoot) {
		            var starti = i - 1;
		            while (c && c !== "<" && c !== "&") {
		              c = charAt(chunk, i++);
		              if (c && parser.trackPosition) {
		                parser.position++;
		                if (c === "\n") {
		                  parser.line++;
		                  parser.column = 0;
		                } else {
		                  parser.column++;
		                }
		              }
		            }
		            parser.textNode += chunk.substring(starti, i - 1);
		          }
		          if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
		            parser.state = S.OPEN_WAKA;
		            parser.startTagPosition = parser.position;
		          } else {
		            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
		              strictFail(parser, "Text data outside of root node.");
		            }
		            if (c === "&") {
		              parser.state = S.TEXT_ENTITY;
		            } else {
		              parser.textNode += c;
		            }
		          }
		          continue;
		        case S.SCRIPT:
		          if (c === "<") {
		            parser.state = S.SCRIPT_ENDING;
		          } else {
		            parser.script += c;
		          }
		          continue;
		        case S.SCRIPT_ENDING:
		          if (c === "/") {
		            parser.state = S.CLOSE_TAG;
		          } else {
		            parser.script += "<" + c;
		            parser.state = S.SCRIPT;
		          }
		          continue;
		        case S.OPEN_WAKA:
		          if (c === "!") {
		            parser.state = S.SGML_DECL;
		            parser.sgmlDecl = "";
		          } else if (isWhitespace(c)) ; else if (isMatch(nameStart, c)) {
		            parser.state = S.OPEN_TAG;
		            parser.tagName = c;
		          } else if (c === "/") {
		            parser.state = S.CLOSE_TAG;
		            parser.tagName = "";
		          } else if (c === "?") {
		            parser.state = S.PROC_INST;
		            parser.procInstName = parser.procInstBody = "";
		          } else {
		            strictFail(parser, "Unencoded <");
		            if (parser.startTagPosition + 1 < parser.position) {
		              var pad = parser.position - parser.startTagPosition;
		              c = new Array(pad).join(" ") + c;
		            }
		            parser.textNode += "<" + c;
		            parser.state = S.TEXT;
		          }
		          continue;
		        case S.SGML_DECL:
		          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
		            emitNode(parser, "onopencdata");
		            parser.state = S.CDATA;
		            parser.sgmlDecl = "";
		            parser.cdata = "";
		          } else if (parser.sgmlDecl + c === "--") {
		            parser.state = S.COMMENT;
		            parser.comment = "";
		            parser.sgmlDecl = "";
		          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
		            parser.state = S.DOCTYPE;
		            if (parser.doctype || parser.sawRoot) {
		              strictFail(
		                parser,
		                "Inappropriately located doctype declaration"
		              );
		            }
		            parser.doctype = "";
		            parser.sgmlDecl = "";
		          } else if (c === ">") {
		            emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
		            parser.sgmlDecl = "";
		            parser.state = S.TEXT;
		          } else if (isQuote(c)) {
		            parser.state = S.SGML_DECL_QUOTED;
		            parser.sgmlDecl += c;
		          } else {
		            parser.sgmlDecl += c;
		          }
		          continue;
		        case S.SGML_DECL_QUOTED:
		          if (c === parser.q) {
		            parser.state = S.SGML_DECL;
		            parser.q = "";
		          }
		          parser.sgmlDecl += c;
		          continue;
		        case S.DOCTYPE:
		          if (c === ">") {
		            parser.state = S.TEXT;
		            emitNode(parser, "ondoctype", parser.doctype);
		            parser.doctype = true;
		          } else {
		            parser.doctype += c;
		            if (c === "[") {
		              parser.state = S.DOCTYPE_DTD;
		            } else if (isQuote(c)) {
		              parser.state = S.DOCTYPE_QUOTED;
		              parser.q = c;
		            }
		          }
		          continue;
		        case S.DOCTYPE_QUOTED:
		          parser.doctype += c;
		          if (c === parser.q) {
		            parser.q = "";
		            parser.state = S.DOCTYPE;
		          }
		          continue;
		        case S.DOCTYPE_DTD:
		          parser.doctype += c;
		          if (c === "]") {
		            parser.state = S.DOCTYPE;
		          } else if (isQuote(c)) {
		            parser.state = S.DOCTYPE_DTD_QUOTED;
		            parser.q = c;
		          }
		          continue;
		        case S.DOCTYPE_DTD_QUOTED:
		          parser.doctype += c;
		          if (c === parser.q) {
		            parser.state = S.DOCTYPE_DTD;
		            parser.q = "";
		          }
		          continue;
		        case S.COMMENT:
		          if (c === "-") {
		            parser.state = S.COMMENT_ENDING;
		          } else {
		            parser.comment += c;
		          }
		          continue;
		        case S.COMMENT_ENDING:
		          if (c === "-") {
		            parser.state = S.COMMENT_ENDED;
		            parser.comment = textopts(parser.opt, parser.comment);
		            if (parser.comment) {
		              emitNode(parser, "oncomment", parser.comment);
		            }
		            parser.comment = "";
		          } else {
		            parser.comment += "-" + c;
		            parser.state = S.COMMENT;
		          }
		          continue;
		        case S.COMMENT_ENDED:
		          if (c !== ">") {
		            strictFail(parser, "Malformed comment");
		            parser.comment += "--" + c;
		            parser.state = S.COMMENT;
		          } else {
		            parser.state = S.TEXT;
		          }
		          continue;
		        case S.CDATA:
		          if (c === "]") {
		            parser.state = S.CDATA_ENDING;
		          } else {
		            parser.cdata += c;
		          }
		          continue;
		        case S.CDATA_ENDING:
		          if (c === "]") {
		            parser.state = S.CDATA_ENDING_2;
		          } else {
		            parser.cdata += "]" + c;
		            parser.state = S.CDATA;
		          }
		          continue;
		        case S.CDATA_ENDING_2:
		          if (c === ">") {
		            if (parser.cdata) {
		              emitNode(parser, "oncdata", parser.cdata);
		            }
		            emitNode(parser, "onclosecdata");
		            parser.cdata = "";
		            parser.state = S.TEXT;
		          } else if (c === "]") {
		            parser.cdata += "]";
		          } else {
		            parser.cdata += "]]" + c;
		            parser.state = S.CDATA;
		          }
		          continue;
		        case S.PROC_INST:
		          if (c === "?") {
		            parser.state = S.PROC_INST_ENDING;
		          } else if (isWhitespace(c)) {
		            parser.state = S.PROC_INST_BODY;
		          } else {
		            parser.procInstName += c;
		          }
		          continue;
		        case S.PROC_INST_BODY:
		          if (!parser.procInstBody && isWhitespace(c)) {
		            continue;
		          } else if (c === "?") {
		            parser.state = S.PROC_INST_ENDING;
		          } else {
		            parser.procInstBody += c;
		          }
		          continue;
		        case S.PROC_INST_ENDING:
		          if (c === ">") {
		            emitNode(parser, "onprocessinginstruction", {
		              name: parser.procInstName,
		              body: parser.procInstBody
		            });
		            parser.procInstName = parser.procInstBody = "";
		            parser.state = S.TEXT;
		          } else {
		            parser.procInstBody += "?" + c;
		            parser.state = S.PROC_INST_BODY;
		          }
		          continue;
		        case S.OPEN_TAG:
		          if (isMatch(nameBody, c)) {
		            parser.tagName += c;
		          } else {
		            newTag(parser);
		            if (c === ">") {
		              openTag(parser);
		            } else if (c === "/") {
		              parser.state = S.OPEN_TAG_SLASH;
		            } else {
		              if (!isWhitespace(c)) {
		                strictFail(parser, "Invalid character in tag name");
		              }
		              parser.state = S.ATTRIB;
		            }
		          }
		          continue;
		        case S.OPEN_TAG_SLASH:
		          if (c === ">") {
		            openTag(parser, true);
		            closeTag(parser);
		          } else {
		            strictFail(parser, "Forward-slash in opening tag not followed by >");
		            parser.state = S.ATTRIB;
		          }
		          continue;
		        case S.ATTRIB:
		          if (isWhitespace(c)) {
		            continue;
		          } else if (c === ">") {
		            openTag(parser);
		          } else if (c === "/") {
		            parser.state = S.OPEN_TAG_SLASH;
		          } else if (isMatch(nameStart, c)) {
		            parser.attribName = c;
		            parser.attribValue = "";
		            parser.state = S.ATTRIB_NAME;
		          } else {
		            strictFail(parser, "Invalid attribute name");
		          }
		          continue;
		        case S.ATTRIB_NAME:
		          if (c === "=") {
		            parser.state = S.ATTRIB_VALUE;
		          } else if (c === ">") {
		            strictFail(parser, "Attribute without value");
		            parser.attribValue = parser.attribName;
		            attrib(parser);
		            openTag(parser);
		          } else if (isWhitespace(c)) {
		            parser.state = S.ATTRIB_NAME_SAW_WHITE;
		          } else if (isMatch(nameBody, c)) {
		            parser.attribName += c;
		          } else {
		            strictFail(parser, "Invalid attribute name");
		          }
		          continue;
		        case S.ATTRIB_NAME_SAW_WHITE:
		          if (c === "=") {
		            parser.state = S.ATTRIB_VALUE;
		          } else if (isWhitespace(c)) {
		            continue;
		          } else {
		            strictFail(parser, "Attribute without value");
		            parser.tag.attributes[parser.attribName] = "";
		            parser.attribValue = "";
		            emitNode(parser, "onattribute", {
		              name: parser.attribName,
		              value: ""
		            });
		            parser.attribName = "";
		            if (c === ">") {
		              openTag(parser);
		            } else if (isMatch(nameStart, c)) {
		              parser.attribName = c;
		              parser.state = S.ATTRIB_NAME;
		            } else {
		              strictFail(parser, "Invalid attribute name");
		              parser.state = S.ATTRIB;
		            }
		          }
		          continue;
		        case S.ATTRIB_VALUE:
		          if (isWhitespace(c)) {
		            continue;
		          } else if (isQuote(c)) {
		            parser.q = c;
		            parser.state = S.ATTRIB_VALUE_QUOTED;
		          } else {
		            strictFail(parser, "Unquoted attribute value");
		            parser.state = S.ATTRIB_VALUE_UNQUOTED;
		            parser.attribValue = c;
		          }
		          continue;
		        case S.ATTRIB_VALUE_QUOTED:
		          if (c !== parser.q) {
		            if (c === "&") {
		              parser.state = S.ATTRIB_VALUE_ENTITY_Q;
		            } else {
		              parser.attribValue += c;
		            }
		            continue;
		          }
		          attrib(parser);
		          parser.q = "";
		          parser.state = S.ATTRIB_VALUE_CLOSED;
		          continue;
		        case S.ATTRIB_VALUE_CLOSED:
		          if (isWhitespace(c)) {
		            parser.state = S.ATTRIB;
		          } else if (c === ">") {
		            openTag(parser);
		          } else if (c === "/") {
		            parser.state = S.OPEN_TAG_SLASH;
		          } else if (isMatch(nameStart, c)) {
		            strictFail(parser, "No whitespace between attributes");
		            parser.attribName = c;
		            parser.attribValue = "";
		            parser.state = S.ATTRIB_NAME;
		          } else {
		            strictFail(parser, "Invalid attribute name");
		          }
		          continue;
		        case S.ATTRIB_VALUE_UNQUOTED:
		          if (!isAttribEnd(c)) {
		            if (c === "&") {
		              parser.state = S.ATTRIB_VALUE_ENTITY_U;
		            } else {
		              parser.attribValue += c;
		            }
		            continue;
		          }
		          attrib(parser);
		          if (c === ">") {
		            openTag(parser);
		          } else {
		            parser.state = S.ATTRIB;
		          }
		          continue;
		        case S.CLOSE_TAG:
		          if (!parser.tagName) {
		            if (isWhitespace(c)) {
		              continue;
		            } else if (notMatch(nameStart, c)) {
		              if (parser.script) {
		                parser.script += "</" + c;
		                parser.state = S.SCRIPT;
		              } else {
		                strictFail(parser, "Invalid tagname in closing tag.");
		              }
		            } else {
		              parser.tagName = c;
		            }
		          } else if (c === ">") {
		            closeTag(parser);
		          } else if (isMatch(nameBody, c)) {
		            parser.tagName += c;
		          } else if (parser.script) {
		            parser.script += "</" + parser.tagName;
		            parser.tagName = "";
		            parser.state = S.SCRIPT;
		          } else {
		            if (!isWhitespace(c)) {
		              strictFail(parser, "Invalid tagname in closing tag");
		            }
		            parser.state = S.CLOSE_TAG_SAW_WHITE;
		          }
		          continue;
		        case S.CLOSE_TAG_SAW_WHITE:
		          if (isWhitespace(c)) {
		            continue;
		          }
		          if (c === ">") {
		            closeTag(parser);
		          } else {
		            strictFail(parser, "Invalid characters in closing tag");
		          }
		          continue;
		        case S.TEXT_ENTITY:
		        case S.ATTRIB_VALUE_ENTITY_Q:
		        case S.ATTRIB_VALUE_ENTITY_U:
		          var returnState;
		          var buffer;
		          switch (parser.state) {
		            case S.TEXT_ENTITY:
		              returnState = S.TEXT;
		              buffer = "textNode";
		              break;
		            case S.ATTRIB_VALUE_ENTITY_Q:
		              returnState = S.ATTRIB_VALUE_QUOTED;
		              buffer = "attribValue";
		              break;
		            case S.ATTRIB_VALUE_ENTITY_U:
		              returnState = S.ATTRIB_VALUE_UNQUOTED;
		              buffer = "attribValue";
		              break;
		          }
		          if (c === ";") {
		            if (parser.opt.unparsedEntities) {
		              var parsedEntity = parseEntity(parser);
		              parser.entity = "";
		              parser.state = returnState;
		              parser.write(parsedEntity);
		            } else {
		              parser[buffer] += parseEntity(parser);
		              parser.entity = "";
		              parser.state = returnState;
		            }
		          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
		            parser.entity += c;
		          } else {
		            strictFail(parser, "Invalid character in entity name");
		            parser[buffer] += "&" + parser.entity + c;
		            parser.entity = "";
		            parser.state = returnState;
		          }
		          continue;
		        default: {
		          throw new Error(parser, "Unknown state: " + parser.state);
		        }
		      }
		    }
		    if (parser.position >= parser.bufferCheckPosition) {
		      checkBufferLength(parser);
		    }
		    return parser;
		  }
		  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
		  if (!String.fromCodePoint) {
		    (function() {
		      var stringFromCharCode = String.fromCharCode;
		      var floor = Math.floor;
		      var fromCodePoint = function() {
		        var MAX_SIZE = 16384;
		        var codeUnits = [];
		        var highSurrogate;
		        var lowSurrogate;
		        var index = -1;
		        var length = arguments.length;
		        if (!length) {
		          return "";
		        }
		        var result = "";
		        while (++index < length) {
		          var codePoint = Number(arguments[index]);
		          if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
		          codePoint < 0 || // not a valid Unicode code point
		          codePoint > 1114111 || // not a valid Unicode code point
		          floor(codePoint) !== codePoint) {
		            throw RangeError("Invalid code point: " + codePoint);
		          }
		          if (codePoint <= 65535) {
		            codeUnits.push(codePoint);
		          } else {
		            codePoint -= 65536;
		            highSurrogate = (codePoint >> 10) + 55296;
		            lowSurrogate = codePoint % 1024 + 56320;
		            codeUnits.push(highSurrogate, lowSurrogate);
		          }
		          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
		            result += stringFromCharCode.apply(null, codeUnits);
		            codeUnits.length = 0;
		          }
		        }
		        return result;
		      };
		      if (Object.defineProperty) {
		        Object.defineProperty(String, "fromCodePoint", {
		          value: fromCodePoint,
		          configurable: true,
		          writable: true
		        });
		      } else {
		        String.fromCodePoint = fromCodePoint;
		      }
		    })();
		  }
		})(exports); 
	} (sax));
	return sax;
}

var hasRequiredSitemapParser;

function requireSitemapParser () {
	if (hasRequiredSitemapParser) return sitemapParser;
	hasRequiredSitemapParser = 1;
	var __defProp = Object.defineProperty;
	var __getOwnPropSymbols = Object.getOwnPropertySymbols;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __propIsEnum = Object.prototype.propertyIsEnumerable;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp.call(b, prop))
	      __defNormalProp(a, prop, b[prop]);
	  if (__getOwnPropSymbols)
	    for (var prop of __getOwnPropSymbols(b)) {
	      if (__propIsEnum.call(b, prop))
	        __defNormalProp(a, prop, b[prop]);
	    }
	  return a;
	};
	var __importDefault = sitemapParser && sitemapParser.__importDefault || function(mod) {
	  return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(sitemapParser, "__esModule", { value: true });
	sitemapParser.ObjectStreamToJSON = sitemapParser.parseSitemap = sitemapParser.XMLToSitemapItemStream = void 0;
	const sax_1 = __importDefault(requireSax());
	const stream_1 = require$$0;
	const types_1 = requireTypes();
	function isValidTagName(tagName) {
	  return tagName in types_1.TagNames;
	}
	function tagTemplate() {
	  return {
	    img: [],
	    video: [],
	    links: [],
	    url: ""
	  };
	}
	function videoTemplate() {
	  return {
	    tag: [],
	    thumbnail_loc: "",
	    title: "",
	    description: ""
	  };
	}
	const imageTemplate = {
	  url: ""
	};
	const linkTemplate = {
	  lang: "",
	  url: ""
	};
	function newsTemplate() {
	  return {
	    publication: { name: "", language: "" },
	    publication_date: "",
	    title: ""
	  };
	}
	const defaultLogger = (level, ...message) => console[level](...message);
	const defaultStreamOpts = {
	  logger: defaultLogger
	};
	class XMLToSitemapItemStream extends stream_1.Transform {
	  constructor(opts = defaultStreamOpts) {
	    var _a;
	    opts.objectMode = true;
	    super(opts);
	    this.error = null;
	    this.saxStream = sax_1.default.createStream(true, {
	      xmlns: true,
	      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
	      // @ts-ignore
	      strictEntities: true,
	      trim: true
	    });
	    this.level = opts.level || types_1.ErrorLevel.WARN;
	    if (this.level !== types_1.ErrorLevel.SILENT && opts.logger !== false) {
	      this.logger = (_a = opts.logger) !== null && _a !== void 0 ? _a : defaultLogger;
	    } else {
	      this.logger = () => void 0;
	    }
	    let currentItem = tagTemplate();
	    let currentTag;
	    let currentVideo = videoTemplate();
	    let currentImage = __spreadValues({}, imageTemplate);
	    let currentLink = __spreadValues({}, linkTemplate);
	    let dontpushCurrentLink = false;
	    this.saxStream.on("opentagstart", (tag) => {
	      currentTag = tag.name;
	      if (currentTag.startsWith("news:") && !currentItem.news) {
	        currentItem.news = newsTemplate();
	      }
	    });
	    this.saxStream.on("opentag", (tag) => {
	      if (isValidTagName(tag.name)) {
	        if (tag.name === "xhtml:link") {
	          if (typeof tag.attributes.rel === "string" || typeof tag.attributes.href === "string") {
	            return;
	          }
	          if (tag.attributes.rel.value === "alternate" && tag.attributes.hreflang) {
	            currentLink.url = tag.attributes.href.value;
	            if (typeof tag.attributes.hreflang === "string")
	              return;
	            currentLink.lang = tag.attributes.hreflang.value;
	          } else if (tag.attributes.rel.value === "alternate") {
	            dontpushCurrentLink = true;
	            currentItem.androidLink = tag.attributes.href.value;
	          } else if (tag.attributes.rel.value === "amphtml") {
	            dontpushCurrentLink = true;
	            currentItem.ampLink = tag.attributes.href.value;
	          } else {
	            this.logger("log", "unhandled attr for xhtml:link", tag.attributes);
	            this.err(`unhandled attr for xhtml:link ${tag.attributes}`);
	          }
	        }
	      } else {
	        this.logger("warn", "unhandled tag", tag.name);
	        this.err(`unhandled tag: ${tag.name}`);
	      }
	    });
	    this.saxStream.on("text", (text) => {
	      switch (currentTag) {
	        case "mobile:mobile":
	          break;
	        case types_1.TagNames.loc:
	          currentItem.url = text;
	          break;
	        case types_1.TagNames.changefreq:
	          if ((0, types_1.isValidChangeFreq)(text)) {
	            currentItem.changefreq = text;
	          }
	          break;
	        case types_1.TagNames.priority:
	          currentItem.priority = parseFloat(text);
	          break;
	        case types_1.TagNames.lastmod:
	          currentItem.lastmod = text;
	          break;
	        case types_1.TagNames["video:thumbnail_loc"]:
	          currentVideo.thumbnail_loc = text;
	          break;
	        case types_1.TagNames["video:tag"]:
	          currentVideo.tag.push(text);
	          break;
	        case types_1.TagNames["video:duration"]:
	          currentVideo.duration = parseInt(text, 10);
	          break;
	        case types_1.TagNames["video:player_loc"]:
	          currentVideo.player_loc = text;
	          break;
	        case types_1.TagNames["video:content_loc"]:
	          currentVideo.content_loc = text;
	          break;
	        case types_1.TagNames["video:requires_subscription"]:
	          if ((0, types_1.isValidYesNo)(text)) {
	            currentVideo.requires_subscription = text;
	          }
	          break;
	        case types_1.TagNames["video:publication_date"]:
	          currentVideo.publication_date = text;
	          break;
	        case types_1.TagNames["video:id"]:
	          currentVideo.id = text;
	          break;
	        case types_1.TagNames["video:restriction"]:
	          currentVideo.restriction = text;
	          break;
	        case types_1.TagNames["video:view_count"]:
	          currentVideo.view_count = parseInt(text, 10);
	          break;
	        case types_1.TagNames["video:uploader"]:
	          currentVideo.uploader = text;
	          break;
	        case types_1.TagNames["video:family_friendly"]:
	          if ((0, types_1.isValidYesNo)(text)) {
	            currentVideo.family_friendly = text;
	          }
	          break;
	        case types_1.TagNames["video:expiration_date"]:
	          currentVideo.expiration_date = text;
	          break;
	        case types_1.TagNames["video:platform"]:
	          currentVideo.platform = text;
	          break;
	        case types_1.TagNames["video:price"]:
	          currentVideo.price = text;
	          break;
	        case types_1.TagNames["video:rating"]:
	          currentVideo.rating = parseFloat(text);
	          break;
	        case types_1.TagNames["video:category"]:
	          currentVideo.category = text;
	          break;
	        case types_1.TagNames["video:live"]:
	          if ((0, types_1.isValidYesNo)(text)) {
	            currentVideo.live = text;
	          }
	          break;
	        case types_1.TagNames["video:gallery_loc"]:
	          currentVideo.gallery_loc = text;
	          break;
	        case types_1.TagNames["image:loc"]:
	          currentImage.url = text;
	          break;
	        case types_1.TagNames["image:geo_location"]:
	          currentImage.geoLocation = text;
	          break;
	        case types_1.TagNames["image:license"]:
	          currentImage.license = text;
	          break;
	        case types_1.TagNames["news:access"]:
	          if (!currentItem.news) {
	            currentItem.news = newsTemplate();
	          }
	          currentItem.news.access = text;
	          break;
	        case types_1.TagNames["news:genres"]:
	          if (!currentItem.news) {
	            currentItem.news = newsTemplate();
	          }
	          currentItem.news.genres = text;
	          break;
	        case types_1.TagNames["news:publication_date"]:
	          if (!currentItem.news) {
	            currentItem.news = newsTemplate();
	          }
	          currentItem.news.publication_date = text;
	          break;
	        case types_1.TagNames["news:keywords"]:
	          if (!currentItem.news) {
	            currentItem.news = newsTemplate();
	          }
	          currentItem.news.keywords = text;
	          break;
	        case types_1.TagNames["news:stock_tickers"]:
	          if (!currentItem.news) {
	            currentItem.news = newsTemplate();
	          }
	          currentItem.news.stock_tickers = text;
	          break;
	        case types_1.TagNames["news:language"]:
	          if (!currentItem.news) {
	            currentItem.news = newsTemplate();
	          }
	          currentItem.news.publication.language = text;
	          break;
	        case types_1.TagNames["video:title"]:
	          currentVideo.title += text;
	          break;
	        case types_1.TagNames["video:description"]:
	          currentVideo.description += text;
	          break;
	        case types_1.TagNames["news:name"]:
	          if (!currentItem.news) {
	            currentItem.news = newsTemplate();
	          }
	          currentItem.news.publication.name += text;
	          break;
	        case types_1.TagNames["news:title"]:
	          if (!currentItem.news) {
	            currentItem.news = newsTemplate();
	          }
	          currentItem.news.title += text;
	          break;
	        case types_1.TagNames["image:caption"]:
	          if (!currentImage.caption) {
	            currentImage.caption = text;
	          } else {
	            currentImage.caption += text;
	          }
	          break;
	        case types_1.TagNames["image:title"]:
	          if (!currentImage.title) {
	            currentImage.title = text;
	          } else {
	            currentImage.title += text;
	          }
	          break;
	        default:
	          this.logger("log", "unhandled text for tag:", currentTag, `'${text}'`);
	          this.err(`unhandled text for tag: ${currentTag} '${text}'`);
	          break;
	      }
	    });
	    this.saxStream.on("cdata", (text) => {
	      switch (currentTag) {
	        case types_1.TagNames["video:title"]:
	          currentVideo.title += text;
	          break;
	        case types_1.TagNames["video:description"]:
	          currentVideo.description += text;
	          break;
	        case types_1.TagNames["news:name"]:
	          if (!currentItem.news) {
	            currentItem.news = newsTemplate();
	          }
	          currentItem.news.publication.name += text;
	          break;
	        case types_1.TagNames["news:title"]:
	          if (!currentItem.news) {
	            currentItem.news = newsTemplate();
	          }
	          currentItem.news.title += text;
	          break;
	        case types_1.TagNames["image:caption"]:
	          if (!currentImage.caption) {
	            currentImage.caption = text;
	          } else {
	            currentImage.caption += text;
	          }
	          break;
	        case types_1.TagNames["image:title"]:
	          if (!currentImage.title) {
	            currentImage.title = text;
	          } else {
	            currentImage.title += text;
	          }
	          break;
	        default:
	          this.logger("log", "unhandled cdata for tag:", currentTag);
	          this.err(`unhandled cdata for tag: ${currentTag}`);
	          break;
	      }
	    });
	    this.saxStream.on("attribute", (attr) => {
	      switch (currentTag) {
	        case types_1.TagNames["urlset"]:
	        case types_1.TagNames["xhtml:link"]:
	        case types_1.TagNames["video:id"]:
	          break;
	        case types_1.TagNames["video:restriction"]:
	          if (attr.name === "relationship" && (0, types_1.isAllowDeny)(attr.value)) {
	            currentVideo["restriction:relationship"] = attr.value;
	          } else {
	            this.logger("log", "unhandled attr", currentTag, attr.name);
	            this.err(`unhandled attr: ${currentTag} ${attr.name}`);
	          }
	          break;
	        case types_1.TagNames["video:price"]:
	          if (attr.name === "type" && (0, types_1.isPriceType)(attr.value)) {
	            currentVideo["price:type"] = attr.value;
	          } else if (attr.name === "currency") {
	            currentVideo["price:currency"] = attr.value;
	          } else if (attr.name === "resolution" && (0, types_1.isResolution)(attr.value)) {
	            currentVideo["price:resolution"] = attr.value;
	          } else {
	            this.logger("log", "unhandled attr for video:price", attr.name);
	            this.err(`unhandled attr: ${currentTag} ${attr.name}`);
	          }
	          break;
	        case types_1.TagNames["video:player_loc"]:
	          if (attr.name === "autoplay") {
	            currentVideo["player_loc:autoplay"] = attr.value;
	          } else if (attr.name === "allow_embed" && (0, types_1.isValidYesNo)(attr.value)) {
	            currentVideo["player_loc:allow_embed"] = attr.value;
	          } else {
	            this.logger("log", "unhandled attr for video:player_loc", attr.name);
	            this.err(`unhandled attr: ${currentTag} ${attr.name}`);
	          }
	          break;
	        case types_1.TagNames["video:platform"]:
	          if (attr.name === "relationship" && (0, types_1.isAllowDeny)(attr.value)) {
	            currentVideo["platform:relationship"] = attr.value;
	          } else {
	            this.logger("log", "unhandled attr for video:platform", attr.name, attr.value);
	            this.err(`unhandled attr: ${currentTag} ${attr.name} ${attr.value}`);
	          }
	          break;
	        case types_1.TagNames["video:gallery_loc"]:
	          if (attr.name === "title") {
	            currentVideo["gallery_loc:title"] = attr.value;
	          } else {
	            this.logger("log", "unhandled attr for video:galler_loc", attr.name);
	            this.err(`unhandled attr: ${currentTag} ${attr.name}`);
	          }
	          break;
	        case types_1.TagNames["video:uploader"]:
	          if (attr.name === "info") {
	            currentVideo["uploader:info"] = attr.value;
	          } else {
	            this.logger("log", "unhandled attr for video:uploader", attr.name);
	            this.err(`unhandled attr: ${currentTag} ${attr.name}`);
	          }
	          break;
	        default:
	          this.logger("log", "unhandled attr", currentTag, attr.name);
	          this.err(`unhandled attr: ${currentTag} ${attr.name}`);
	      }
	    });
	    this.saxStream.on("closetag", (tag) => {
	      switch (tag) {
	        case types_1.TagNames.url:
	          this.push(currentItem);
	          currentItem = tagTemplate();
	          break;
	        case types_1.TagNames["video:video"]:
	          currentItem.video.push(currentVideo);
	          currentVideo = videoTemplate();
	          break;
	        case types_1.TagNames["image:image"]:
	          currentItem.img.push(currentImage);
	          currentImage = __spreadValues({}, imageTemplate);
	          break;
	        case types_1.TagNames["xhtml:link"]:
	          if (!dontpushCurrentLink) {
	            currentItem.links.push(currentLink);
	          }
	          currentLink = __spreadValues({}, linkTemplate);
	          break;
	      }
	    });
	  }
	  _transform(data, encoding, callback) {
	    try {
	      const cb = () => callback(this.level === types_1.ErrorLevel.THROW ? this.error : null);
	      if (!this.saxStream.write(data, encoding)) {
	        this.saxStream.once("drain", cb);
	      } else {
	        process.nextTick(cb);
	      }
	    } catch (error) {
	      callback(error);
	    }
	  }
	  err(msg) {
	    if (!this.error)
	      this.error = new Error(msg);
	  }
	}
	sitemapParser.XMLToSitemapItemStream = XMLToSitemapItemStream;
	async function parseSitemap(xml) {
	  const urls = [];
	  return new Promise((resolve, reject) => {
	    xml.pipe(new XMLToSitemapItemStream()).on("data", (smi) => urls.push(smi)).on("end", () => {
	      resolve(urls);
	    }).on("error", (error) => {
	      reject(error);
	    });
	  });
	}
	sitemapParser.parseSitemap = parseSitemap;
	const defaultObjectStreamOpts = {
	  lineSeparated: false
	};
	class ObjectStreamToJSON extends stream_1.Transform {
	  constructor(opts = defaultObjectStreamOpts) {
	    opts.writableObjectMode = true;
	    super(opts);
	    this.lineSeparated = opts.lineSeparated;
	    this.firstWritten = false;
	  }
	  _transform(chunk, encoding, cb) {
	    if (!this.firstWritten) {
	      this.firstWritten = true;
	      if (!this.lineSeparated) {
	        this.push("[");
	      }
	    } else if (this.lineSeparated) {
	      this.push("\n");
	    } else {
	      this.push(",");
	    }
	    if (chunk) {
	      this.push(JSON.stringify(chunk));
	    }
	    cb();
	  }
	  _flush(cb) {
	    if (!this.lineSeparated) {
	      this.push("]");
	    }
	    cb();
	  }
	}
	sitemapParser.ObjectStreamToJSON = ObjectStreamToJSON;
	return sitemapParser;
}

var sitemapIndexParser = {};

var hasRequiredSitemapIndexParser;

function requireSitemapIndexParser () {
	if (hasRequiredSitemapIndexParser) return sitemapIndexParser;
	hasRequiredSitemapIndexParser = 1;
	var __importDefault = sitemapIndexParser && sitemapIndexParser.__importDefault || function(mod) {
	  return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(sitemapIndexParser, "__esModule", { value: true });
	sitemapIndexParser.IndexObjectStreamToJSON = sitemapIndexParser.parseSitemapIndex = sitemapIndexParser.XMLToSitemapIndexStream = void 0;
	const sax_1 = __importDefault(requireSax());
	const stream_1 = require$$0;
	const types_1 = requireTypes();
	function isValidTagName(tagName) {
	  return tagName in types_1.IndexTagNames;
	}
	function tagTemplate() {
	  return {
	    url: ""
	  };
	}
	const defaultLogger = (level, ...message) => console[level](...message);
	const defaultStreamOpts = {
	  logger: defaultLogger
	};
	class XMLToSitemapIndexStream extends stream_1.Transform {
	  constructor(opts = defaultStreamOpts) {
	    var _a;
	    opts.objectMode = true;
	    super(opts);
	    this.saxStream = sax_1.default.createStream(true, {
	      xmlns: true,
	      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
	      // @ts-ignore
	      strictEntities: true,
	      trim: true
	    });
	    this.level = opts.level || types_1.ErrorLevel.WARN;
	    if (this.level !== types_1.ErrorLevel.SILENT && opts.logger !== false) {
	      this.logger = (_a = opts.logger) !== null && _a !== void 0 ? _a : defaultLogger;
	    } else {
	      this.logger = () => void 0;
	    }
	    let currentItem = tagTemplate();
	    let currentTag;
	    this.saxStream.on("opentagstart", (tag) => {
	      currentTag = tag.name;
	    });
	    this.saxStream.on("opentag", (tag) => {
	      if (!isValidTagName(tag.name)) {
	        this.logger("warn", "unhandled tag", tag.name);
	      }
	    });
	    this.saxStream.on("text", (text) => {
	      switch (currentTag) {
	        case types_1.IndexTagNames.loc:
	          currentItem.url = text;
	          break;
	        case types_1.IndexTagNames.lastmod:
	          currentItem.lastmod = text;
	          break;
	        default:
	          this.logger("log", "unhandled text for tag:", currentTag, `'${text}'`);
	          break;
	      }
	    });
	    this.saxStream.on("cdata", (_text) => {
	      switch (currentTag) {
	        default:
	          this.logger("log", "unhandled cdata for tag:", currentTag);
	          break;
	      }
	    });
	    this.saxStream.on("attribute", (attr) => {
	      switch (currentTag) {
	        case types_1.IndexTagNames.sitemapindex:
	          break;
	        default:
	          this.logger("log", "unhandled attr", currentTag, attr.name);
	      }
	    });
	    this.saxStream.on("closetag", (tag) => {
	      switch (tag) {
	        case types_1.IndexTagNames.sitemap:
	          this.push(currentItem);
	          currentItem = tagTemplate();
	          break;
	      }
	    });
	  }
	  _transform(data, encoding, callback) {
	    try {
	      this.saxStream.write(data, encoding);
	      callback();
	    } catch (error) {
	      callback(error);
	    }
	  }
	}
	sitemapIndexParser.XMLToSitemapIndexStream = XMLToSitemapIndexStream;
	async function parseSitemapIndex(xml) {
	  const urls = [];
	  return new Promise((resolve, reject) => {
	    xml.pipe(new XMLToSitemapIndexStream()).on("data", (smi) => urls.push(smi)).on("end", () => {
	      resolve(urls);
	    }).on("error", (error) => {
	      reject(error);
	    });
	  });
	}
	sitemapIndexParser.parseSitemapIndex = parseSitemapIndex;
	const defaultObjectStreamOpts = {
	  lineSeparated: false
	};
	class IndexObjectStreamToJSON extends stream_1.Transform {
	  constructor(opts = defaultObjectStreamOpts) {
	    opts.writableObjectMode = true;
	    super(opts);
	    this.lineSeparated = opts.lineSeparated;
	    this.firstWritten = false;
	  }
	  _transform(chunk, encoding, cb) {
	    if (!this.firstWritten) {
	      this.firstWritten = true;
	      if (!this.lineSeparated) {
	        this.push("[");
	      }
	    } else if (this.lineSeparated) {
	      this.push("\n");
	    } else {
	      this.push(",");
	    }
	    if (chunk) {
	      this.push(JSON.stringify(chunk));
	    }
	    cb();
	  }
	  _flush(cb) {
	    if (!this.lineSeparated) {
	      this.push("]");
	    }
	    cb();
	  }
	}
	sitemapIndexParser.IndexObjectStreamToJSON = IndexObjectStreamToJSON;
	return sitemapIndexParser;
}

var sitemapSimple = {};

var hasRequiredSitemapSimple;

function requireSitemapSimple () {
	if (hasRequiredSitemapSimple) return sitemapSimple;
	hasRequiredSitemapSimple = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.simpleSitemapAndIndex = void 0;
		const sitemap_index_stream_1 = requireSitemapIndexStream();
		const sitemap_stream_1 = requireSitemapStream();
		const utils_1 = requireUtils$4();
		const zlib_1 = require$$3$1;
		const fs_1 = require$$0$1;
		const path_1 = require$$0$2;
		const stream_1 = require$$0;
		const util_1 = require$$0$3;
		const url_1 = require$$3;
		const pipeline = (0, util_1.promisify)(stream_1.pipeline);
		const simpleSitemapAndIndex = async ({
		  hostname,
		  sitemapHostname = hostname,
		  // if different
		  /**
		   * Pass a line separated list of sitemap items or a stream or an array
		   */
		  sourceData,
		  destinationDir,
		  limit = 5e4,
		  gzip = true,
		  publicBasePath = "./"
		}) => {
		  await fs_1.promises.mkdir(destinationDir, { recursive: true });
		  const sitemapAndIndexStream = new sitemap_index_stream_1.SitemapAndIndexStream({
		    limit,
		    getSitemapStream: (i) => {
		      const sitemapStream = new sitemap_stream_1.SitemapStream({
		        hostname
		      });
		      const path = `./sitemap-${i}.xml`;
		      const writePath2 = (0, path_1.resolve)(destinationDir, path + (gzip ? ".gz" : ""));
		      if (!publicBasePath.endsWith("/")) {
		        publicBasePath += "/";
		      }
		      const publicPath = (0, path_1.normalize)(publicBasePath + path);
		      let pipeline2;
		      if (gzip) {
		        pipeline2 = sitemapStream.pipe((0, zlib_1.createGzip)()).pipe((0, fs_1.createWriteStream)(writePath2));
		      } else {
		        pipeline2 = sitemapStream.pipe((0, fs_1.createWriteStream)(writePath2));
		      }
		      return [
		        new url_1.URL(`${publicPath}${gzip ? ".gz" : ""}`, sitemapHostname).toString(),
		        sitemapStream,
		        pipeline2
		      ];
		    }
		  });
		  let src;
		  if (typeof sourceData === "string") {
		    src = (0, utils_1.lineSeparatedURLsToSitemapOptions)((0, fs_1.createReadStream)(sourceData));
		  } else if (sourceData instanceof stream_1.Readable) {
		    src = sourceData;
		  } else if (Array.isArray(sourceData)) {
		    src = stream_1.Readable.from(sourceData);
		  } else {
		    throw new Error("unhandled source type. You've passed in data that is not supported");
		  }
		  const writePath = (0, path_1.resolve)(destinationDir, `./sitemap-index.xml${gzip ? ".gz" : ""}`);
		  if (gzip) {
		    return pipeline(src, sitemapAndIndexStream, (0, zlib_1.createGzip)(), (0, fs_1.createWriteStream)(writePath));
		  } else {
		    return pipeline(src, sitemapAndIndexStream, (0, fs_1.createWriteStream)(writePath));
		  }
		};
		exports.simpleSitemapAndIndex = simpleSitemapAndIndex;
		exports.default = exports.simpleSitemapAndIndex; 
	} (sitemapSimple));
	return sitemapSimple;
}

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	(function (exports) {
		var __createBinding = dist && dist.__createBinding || (Object.create ? function(o, m, k, k2) {
		  if (k2 === void 0) k2 = k;
		  Object.defineProperty(o, k2, { enumerable: true, get: function() {
		    return m[k];
		  } });
		} : function(o, m, k, k2) {
		  if (k2 === void 0) k2 = k;
		  o[k2] = m[k];
		});
		var __exportStar = dist && dist.__exportStar || function(m, exports2) {
		  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.simpleSitemapAndIndex = exports.IndexObjectStreamToJSON = exports.XMLToSitemapIndexStream = exports.parseSitemapIndex = exports.ObjectStreamToJSON = exports.XMLToSitemapItemStream = exports.parseSitemap = exports.xmlLint = exports.ReadlineStream = exports.normalizeURL = exports.validateSMIOptions = exports.mergeStreams = exports.lineSeparatedURLsToSitemapOptions = exports.SitemapStream = exports.streamToPromise = exports.SitemapAndIndexStream = exports.SitemapIndexStream = exports.IndexTagNames = exports.SitemapItemStream = void 0;
		/*!
		 * Sitemap
		 * Copyright(c) 2011 Eugene Kalinin
		 * MIT Licensed
		 */
		var sitemap_item_stream_1 = requireSitemapItemStream();
		Object.defineProperty(exports, "SitemapItemStream", { enumerable: true, get: function() {
		  return sitemap_item_stream_1.SitemapItemStream;
		} });
		var sitemap_index_stream_1 = requireSitemapIndexStream();
		Object.defineProperty(exports, "IndexTagNames", { enumerable: true, get: function() {
		  return sitemap_index_stream_1.IndexTagNames;
		} });
		Object.defineProperty(exports, "SitemapIndexStream", { enumerable: true, get: function() {
		  return sitemap_index_stream_1.SitemapIndexStream;
		} });
		Object.defineProperty(exports, "SitemapAndIndexStream", { enumerable: true, get: function() {
		  return sitemap_index_stream_1.SitemapAndIndexStream;
		} });
		var sitemap_stream_1 = requireSitemapStream();
		Object.defineProperty(exports, "streamToPromise", { enumerable: true, get: function() {
		  return sitemap_stream_1.streamToPromise;
		} });
		Object.defineProperty(exports, "SitemapStream", { enumerable: true, get: function() {
		  return sitemap_stream_1.SitemapStream;
		} });
		__exportStar(requireErrors(), exports);
		__exportStar(requireTypes(), exports);
		var utils_1 = requireUtils$4();
		Object.defineProperty(exports, "lineSeparatedURLsToSitemapOptions", { enumerable: true, get: function() {
		  return utils_1.lineSeparatedURLsToSitemapOptions;
		} });
		Object.defineProperty(exports, "mergeStreams", { enumerable: true, get: function() {
		  return utils_1.mergeStreams;
		} });
		Object.defineProperty(exports, "validateSMIOptions", { enumerable: true, get: function() {
		  return utils_1.validateSMIOptions;
		} });
		Object.defineProperty(exports, "normalizeURL", { enumerable: true, get: function() {
		  return utils_1.normalizeURL;
		} });
		Object.defineProperty(exports, "ReadlineStream", { enumerable: true, get: function() {
		  return utils_1.ReadlineStream;
		} });
		var xmllint_1 = requireXmllint();
		Object.defineProperty(exports, "xmlLint", { enumerable: true, get: function() {
		  return xmllint_1.xmlLint;
		} });
		var sitemap_parser_1 = requireSitemapParser();
		Object.defineProperty(exports, "parseSitemap", { enumerable: true, get: function() {
		  return sitemap_parser_1.parseSitemap;
		} });
		Object.defineProperty(exports, "XMLToSitemapItemStream", { enumerable: true, get: function() {
		  return sitemap_parser_1.XMLToSitemapItemStream;
		} });
		Object.defineProperty(exports, "ObjectStreamToJSON", { enumerable: true, get: function() {
		  return sitemap_parser_1.ObjectStreamToJSON;
		} });
		var sitemap_index_parser_1 = requireSitemapIndexParser();
		Object.defineProperty(exports, "parseSitemapIndex", { enumerable: true, get: function() {
		  return sitemap_index_parser_1.parseSitemapIndex;
		} });
		Object.defineProperty(exports, "XMLToSitemapIndexStream", { enumerable: true, get: function() {
		  return sitemap_index_parser_1.XMLToSitemapIndexStream;
		} });
		Object.defineProperty(exports, "IndexObjectStreamToJSON", { enumerable: true, get: function() {
		  return sitemap_index_parser_1.IndexObjectStreamToJSON;
		} });
		var sitemap_simple_1 = requireSitemapSimple();
		Object.defineProperty(exports, "simpleSitemapAndIndex", { enumerable: true, get: function() {
		  return sitemap_simple_1.simpleSitemapAndIndex;
		} }); 
	} (dist));
	return dist;
}

var distExports = requireDist();

var cjs$2 = {exports: {}};

var cjs$1 = {exports: {}};

var hasRequiredCjs$1;

function requireCjs$1 () {
	if (hasRequiredCjs$1) return cjs$1.exports;
	hasRequiredCjs$1 = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ParsingError = void 0;
		class ParsingError extends Error {
		  constructor(message, cause) {
		    super(message);
		    this.cause = cause;
		  }
		}
		exports.ParsingError = ParsingError;
		let parsingState;
		function nextChild() {
		  return element(false) || text() || comment() || cdata();
		}
		function nextRootChild() {
		  match(/\s*/);
		  return element(true) || comment() || doctype() || processingInstruction(false);
		}
		function parseDocument() {
		  const declaration = processingInstruction(true);
		  const children = [];
		  let documentRootNode;
		  let child = nextRootChild();
		  while (child) {
		    if (child.node.type === "Element") {
		      if (documentRootNode) {
		        throw new Error("Found multiple root nodes");
		      }
		      documentRootNode = child.node;
		    }
		    if (!child.excluded) {
		      children.push(child.node);
		    }
		    child = nextRootChild();
		  }
		  if (!documentRootNode) {
		    throw new ParsingError("Failed to parse XML", "Root Element not found");
		  }
		  if (parsingState.xml.length !== 0) {
		    throw new ParsingError("Failed to parse XML", "Not Well-Formed XML");
		  }
		  return {
		    declaration: declaration ? declaration.node : null,
		    root: documentRootNode,
		    children
		  };
		}
		function processingInstruction(matchDeclaration) {
		  const m = matchDeclaration ? match(/^<\?(xml)\s*/) : match(/^<\?([\w-:.]+)\s*/);
		  if (!m)
		    return;
		  const node = {
		    name: m[1],
		    type: "ProcessingInstruction",
		    attributes: {}
		  };
		  while (!(eos() || is("?>"))) {
		    const attr = attribute();
		    if (attr) {
		      node.attributes[attr.name] = attr.value;
		    } else {
		      return;
		    }
		  }
		  match(/\?>/);
		  return {
		    excluded: matchDeclaration ? false : parsingState.options.filter(node) === false,
		    node
		  };
		}
		function element(matchRoot) {
		  const m = match(/^<([^?!</>\s]+)\s*/);
		  if (!m)
		    return;
		  const node = {
		    type: "Element",
		    name: m[1],
		    attributes: {},
		    children: []
		  };
		  const excluded = matchRoot ? false : parsingState.options.filter(node) === false;
		  while (!(eos() || is(">") || is("?>") || is("/>"))) {
		    const attr = attribute();
		    if (attr) {
		      node.attributes[attr.name] = attr.value;
		    } else {
		      return;
		    }
		  }
		  if (match(/^\s*\/>/)) {
		    node.children = null;
		    return {
		      excluded,
		      node
		    };
		  }
		  match(/\??>/);
		  let child = nextChild();
		  while (child) {
		    if (!child.excluded) {
		      node.children.push(child.node);
		    }
		    child = nextChild();
		  }
		  if (parsingState.options.strictMode) {
		    const closingTag = `</${node.name}>`;
		    if (parsingState.xml.startsWith(closingTag)) {
		      parsingState.xml = parsingState.xml.slice(closingTag.length);
		    } else {
		      throw new ParsingError("Failed to parse XML", `Closing tag not matching "${closingTag}"`);
		    }
		  } else {
		    match(/^<\/\s*[\w-:.\u00C0-\u00FF]+>/);
		  }
		  return {
		    excluded,
		    node
		  };
		}
		function doctype() {
		  const m = match(/^<!DOCTYPE\s+\S+\s+SYSTEM[^>]*>/) || match(/^<!DOCTYPE\s+\S+\s+PUBLIC[^>]*>/) || match(/^<!DOCTYPE\s+\S+\s*\[[^\]]*]>/) || match(/^<!DOCTYPE\s+\S+\s*>/);
		  if (m) {
		    const node = {
		      type: "DocumentType",
		      content: m[0]
		    };
		    return {
		      excluded: parsingState.options.filter(node) === false,
		      node
		    };
		  }
		}
		function cdata() {
		  if (parsingState.xml.startsWith("<![CDATA[")) {
		    const endPositionStart = parsingState.xml.indexOf("]]>");
		    if (endPositionStart > -1) {
		      const endPositionFinish = endPositionStart + 3;
		      const node = {
		        type: "CDATA",
		        content: parsingState.xml.substring(0, endPositionFinish)
		      };
		      parsingState.xml = parsingState.xml.slice(endPositionFinish);
		      return {
		        excluded: parsingState.options.filter(node) === false,
		        node
		      };
		    }
		  }
		}
		function comment() {
		  const m = match(/^<!--[\s\S]*?-->/);
		  if (m) {
		    const node = {
		      type: "Comment",
		      content: m[0]
		    };
		    return {
		      excluded: parsingState.options.filter(node) === false,
		      node
		    };
		  }
		}
		function text() {
		  const m = match(/^([^<]+)/);
		  if (m) {
		    const node = {
		      type: "Text",
		      content: m[1]
		    };
		    return {
		      excluded: parsingState.options.filter(node) === false,
		      node
		    };
		  }
		}
		function attribute() {
		  const m = match(/([^=]+)\s*=\s*("[^"]*"|'[^']*'|[^>\s]+)\s*/);
		  if (m) {
		    return {
		      name: m[1].trim(),
		      value: stripQuotes(m[2].trim())
		    };
		  }
		}
		function stripQuotes(val) {
		  return val.replace(/^['"]|['"]$/g, "");
		}
		function match(re) {
		  const m = parsingState.xml.match(re);
		  if (m) {
		    parsingState.xml = parsingState.xml.slice(m[0].length);
		    return m;
		  }
		}
		function eos() {
		  return 0 === parsingState.xml.length;
		}
		function is(prefix) {
		  return 0 === parsingState.xml.indexOf(prefix);
		}
		function parseXml(xml, options = {}) {
		  xml = xml.trim();
		  const filter = options.filter || (() => true);
		  parsingState = {
		    xml,
		    options: Object.assign(Object.assign({}, options), { filter, strictMode: options.strictMode === true })
		  };
		  return parseDocument();
		}
		{
		  module.exports = parseXml;
		}
		exports.default = parseXml; 
	} (cjs$1, cjs$1.exports));
	return cjs$1.exports;
}

var cjs = cjs$2.exports;

var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs$2.exports;
	hasRequiredCjs = 1;
	(function (module, exports) {
		var __importDefault = cjs && cjs.__importDefault || function(mod) {
		  return mod && mod.__esModule ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		const xml_parser_xo_1 = __importDefault(/*@__PURE__*/ requireCjs$1());
		function newLine(state) {
		  if (!state.options.indentation && !state.options.lineSeparator)
		    return;
		  state.content += state.options.lineSeparator;
		  let i;
		  for (i = 0; i < state.level; i++) {
		    state.content += state.options.indentation;
		  }
		}
		function indent(state) {
		  state.content = state.content.replace(/ +$/, "");
		  let i;
		  for (i = 0; i < state.level; i++) {
		    state.content += state.options.indentation;
		  }
		}
		function appendContent(state, content) {
		  state.content += content;
		}
		function processNode(node, state, preserveSpace) {
		  if (typeof node.content === "string") {
		    processContent(node.content, state, preserveSpace);
		  } else if (node.type === "Element") {
		    processElementNode(node, state, preserveSpace);
		  } else if (node.type === "ProcessingInstruction") {
		    processProcessingIntruction(node, state);
		  } else {
		    throw new Error("Unknown node type: " + node.type);
		  }
		}
		function processContent(content, state, preserveSpace) {
		  if (!preserveSpace) {
		    const trimmedContent = content.trim();
		    if (state.options.lineSeparator) {
		      content = trimmedContent;
		    } else if (trimmedContent.length === 0) {
		      content = trimmedContent;
		    }
		  }
		  if (content.length > 0) {
		    if (!preserveSpace && state.content.length > 0) {
		      newLine(state);
		    }
		    appendContent(state, content);
		  }
		}
		function isPathMatchingIgnoredPaths(path, ignoredPaths) {
		  const fullPath = "/" + path.join("/");
		  const pathLastPart = path[path.length - 1];
		  return ignoredPaths.includes(pathLastPart) || ignoredPaths.includes(fullPath);
		}
		function processElementNode(node, state, preserveSpace) {
		  state.path.push(node.name);
		  if (!preserveSpace && state.content.length > 0) {
		    newLine(state);
		  }
		  appendContent(state, "<" + node.name);
		  processAttributes(state, node.attributes);
		  if (node.children === null || state.options.forceSelfClosingEmptyTag && node.children.length === 0) {
		    const selfClosingNodeClosingTag = state.options.whiteSpaceAtEndOfSelfclosingTag ? " />" : "/>";
		    appendContent(state, selfClosingNodeClosingTag);
		  } else if (node.children.length === 0) {
		    appendContent(state, "></" + node.name + ">");
		  } else {
		    const nodeChildren = node.children;
		    appendContent(state, ">");
		    state.level++;
		    let nodePreserveSpace = node.attributes["xml:space"] === "preserve";
		    let ignoredPath = false;
		    if (!nodePreserveSpace && state.options.ignoredPaths) {
		      ignoredPath = isPathMatchingIgnoredPaths(state.path, state.options.ignoredPaths);
		      nodePreserveSpace = ignoredPath;
		    }
		    if (!nodePreserveSpace && state.options.collapseContent) {
		      let containsTextNodes = false;
		      let containsTextNodesWithLineBreaks = false;
		      let containsNonTextNodes = false;
		      nodeChildren.forEach(function(child, index) {
		        if (child.type === "Text") {
		          if (child.content.includes("\n")) {
		            containsTextNodesWithLineBreaks = true;
		            child.content = child.content.trim();
		          } else if ((index === 0 || index === nodeChildren.length - 1) && !preserveSpace) {
		            if (child.content.trim().length === 0) {
		              child.content = "";
		            }
		          }
		          if (child.content.trim().length > 0) {
		            containsTextNodes = true;
		          }
		        } else if (child.type === "CDATA") {
		          containsTextNodes = true;
		        } else {
		          containsNonTextNodes = true;
		        }
		      });
		      if (containsTextNodes && (!containsNonTextNodes || !containsTextNodesWithLineBreaks)) {
		        nodePreserveSpace = true;
		      }
		    }
		    nodeChildren.forEach(function(child) {
		      processNode(child, state, preserveSpace || nodePreserveSpace);
		    });
		    state.level--;
		    if (!preserveSpace && !nodePreserveSpace) {
		      newLine(state);
		    }
		    if (ignoredPath) {
		      indent(state);
		    }
		    appendContent(state, "</" + node.name + ">");
		  }
		  state.path.pop();
		}
		function processAttributes(state, attributes) {
		  Object.keys(attributes).forEach(function(attr) {
		    const escaped = attributes[attr].replace(/"/g, "&quot;");
		    appendContent(state, " " + attr + '="' + escaped + '"');
		  });
		}
		function processProcessingIntruction(node, state) {
		  if (state.content.length > 0) {
		    newLine(state);
		  }
		  appendContent(state, "<?" + node.name);
		  processAttributes(state, node.attributes);
		  appendContent(state, "?>");
		}
		function formatXml(xml, options = {}) {
		  options.indentation = "indentation" in options ? options.indentation : "    ";
		  options.collapseContent = options.collapseContent === true;
		  options.lineSeparator = "lineSeparator" in options ? options.lineSeparator : "\r\n";
		  options.whiteSpaceAtEndOfSelfclosingTag = options.whiteSpaceAtEndOfSelfclosingTag === true;
		  options.throwOnFailure = options.throwOnFailure !== false;
		  try {
		    const parsedXml = (0, xml_parser_xo_1.default)(xml, { filter: options.filter, strictMode: options.strictMode });
		    const state = { content: "", level: 0, options, path: [] };
		    if (parsedXml.declaration) {
		      processProcessingIntruction(parsedXml.declaration, state);
		    }
		    parsedXml.children.forEach(function(child) {
		      processNode(child, state, false);
		    });
		    if (!options.lineSeparator) {
		      return state.content;
		    }
		    return state.content.replace(/\r\n/g, "\n").replace(/\n/g, options.lineSeparator);
		  } catch (err) {
		    if (options.throwOnFailure) {
		      throw err;
		    }
		    return xml;
		  }
		}
		formatXml.minify = (xml, options = {}) => {
		  return formatXml(xml, Object.assign(Object.assign({}, options), { indentation: "", lineSeparator: "" }));
		};
		{
		  module.exports = formatXml;
		}
		exports.default = formatXml; 
	} (cjs$2, cjs$2.exports));
	return cjs$2.exports;
}

var cjsExports = /*@__PURE__*/ requireCjs();
var format = /*@__PURE__*/getDefaultExportFromCjs(cjsExports);

function slash(str) {
  return str.replace(/\\/g, "/");
}
function ensurePrefix(prefix, str) {
  if (!str.startsWith(prefix))
    return prefix + str;
  return str;
}
function ensureSuffix(suffix, str) {
  if (!str.endsWith(suffix))
    return str + suffix;
  return str;
}

var tasks = {};

var utils$3 = {};

var array = {};

var hasRequiredArray;

function requireArray () {
	if (hasRequiredArray) return array;
	hasRequiredArray = 1;
	Object.defineProperty(array, "__esModule", { value: true });
	array.splitWhen = array.flatten = void 0;
	function flatten(items) {
	  return items.reduce((collection, item) => [].concat(collection, item), []);
	}
	array.flatten = flatten;
	function splitWhen(items, predicate) {
	  const result = [[]];
	  let groupIndex = 0;
	  for (const item of items) {
	    if (predicate(item)) {
	      groupIndex++;
	      result[groupIndex] = [];
	    } else {
	      result[groupIndex].push(item);
	    }
	  }
	  return result;
	}
	array.splitWhen = splitWhen;
	return array;
}

var errno = {};

var hasRequiredErrno;

function requireErrno () {
	if (hasRequiredErrno) return errno;
	hasRequiredErrno = 1;
	Object.defineProperty(errno, "__esModule", { value: true });
	errno.isEnoentCodeError = void 0;
	function isEnoentCodeError(error) {
	  return error.code === "ENOENT";
	}
	errno.isEnoentCodeError = isEnoentCodeError;
	return errno;
}

var fs$3 = {};

var hasRequiredFs$3;

function requireFs$3 () {
	if (hasRequiredFs$3) return fs$3;
	hasRequiredFs$3 = 1;
	Object.defineProperty(fs$3, "__esModule", { value: true });
	fs$3.createDirentFromStats = void 0;
	class DirentFromStats {
	  constructor(name, stats) {
	    this.name = name;
	    this.isBlockDevice = stats.isBlockDevice.bind(stats);
	    this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
	    this.isDirectory = stats.isDirectory.bind(stats);
	    this.isFIFO = stats.isFIFO.bind(stats);
	    this.isFile = stats.isFile.bind(stats);
	    this.isSocket = stats.isSocket.bind(stats);
	    this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
	  }
	}
	function createDirentFromStats(name, stats) {
	  return new DirentFromStats(name, stats);
	}
	fs$3.createDirentFromStats = createDirentFromStats;
	return fs$3;
}

var path = {};

var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path;
	hasRequiredPath = 1;
	Object.defineProperty(path, "__esModule", { value: true });
	path.convertPosixPathToPattern = path.convertWindowsPathToPattern = path.convertPathToPattern = path.escapePosixPath = path.escapeWindowsPath = path.escape = path.removeLeadingDotSegment = path.makeAbsolute = path.unixify = void 0;
	const os = require$$0$4;
	const path$1 = require$$0$2;
	const IS_WINDOWS_PLATFORM = os.platform() === "win32";
	const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
	const POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
	const WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g;
	const DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
	const WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
	function unixify(filepath) {
	  return filepath.replace(/\\/g, "/");
	}
	path.unixify = unixify;
	function makeAbsolute(cwd, filepath) {
	  return path$1.resolve(cwd, filepath);
	}
	path.makeAbsolute = makeAbsolute;
	function removeLeadingDotSegment(entry) {
	  if (entry.charAt(0) === ".") {
	    const secondCharactery = entry.charAt(1);
	    if (secondCharactery === "/" || secondCharactery === "\\") {
	      return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
	    }
	  }
	  return entry;
	}
	path.removeLeadingDotSegment = removeLeadingDotSegment;
	path.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
	function escapeWindowsPath(pattern) {
	  return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
	}
	path.escapeWindowsPath = escapeWindowsPath;
	function escapePosixPath(pattern) {
	  return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
	}
	path.escapePosixPath = escapePosixPath;
	path.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
	function convertWindowsPathToPattern(filepath) {
	  return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
	}
	path.convertWindowsPathToPattern = convertWindowsPathToPattern;
	function convertPosixPathToPattern(filepath) {
	  return escapePosixPath(filepath);
	}
	path.convertPosixPathToPattern = convertPosixPathToPattern;
	return path;
}

var pattern = {};

var isExtglob;
var hasRequiredIsExtglob;

function requireIsExtglob () {
	if (hasRequiredIsExtglob) return isExtglob;
	hasRequiredIsExtglob = 1;
	/*!
	 * is-extglob <https://github.com/jonschlinkert/is-extglob>
	 *
	 * Copyright (c) 2014-2016, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	isExtglob = function isExtglob(str) {
	  if (typeof str !== "string" || str === "") {
	    return false;
	  }
	  var match;
	  while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
	    if (match[2]) return true;
	    str = str.slice(match.index + match[0].length);
	  }
	  return false;
	};
	return isExtglob;
}

var isGlob;
var hasRequiredIsGlob;

function requireIsGlob () {
	if (hasRequiredIsGlob) return isGlob;
	hasRequiredIsGlob = 1;
	/*!
	 * is-glob <https://github.com/jonschlinkert/is-glob>
	 *
	 * Copyright (c) 2014-2017, Jon Schlinkert.
	 * Released under the MIT License.
	 */
	var isExtglob = requireIsExtglob();
	var chars = { "{": "}", "(": ")", "[": "]" };
	var strictCheck = function(str) {
	  if (str[0] === "!") {
	    return true;
	  }
	  var index = 0;
	  var pipeIndex = -2;
	  var closeSquareIndex = -2;
	  var closeCurlyIndex = -2;
	  var closeParenIndex = -2;
	  var backSlashIndex = -2;
	  while (index < str.length) {
	    if (str[index] === "*") {
	      return true;
	    }
	    if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
	      return true;
	    }
	    if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
	      if (closeSquareIndex < index) {
	        closeSquareIndex = str.indexOf("]", index);
	      }
	      if (closeSquareIndex > index) {
	        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
	          return true;
	        }
	        backSlashIndex = str.indexOf("\\", index);
	        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
	          return true;
	        }
	      }
	    }
	    if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
	      closeCurlyIndex = str.indexOf("}", index);
	      if (closeCurlyIndex > index) {
	        backSlashIndex = str.indexOf("\\", index);
	        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
	          return true;
	        }
	      }
	    }
	    if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
	      closeParenIndex = str.indexOf(")", index);
	      if (closeParenIndex > index) {
	        backSlashIndex = str.indexOf("\\", index);
	        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
	          return true;
	        }
	      }
	    }
	    if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
	      if (pipeIndex < index) {
	        pipeIndex = str.indexOf("|", index);
	      }
	      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
	        closeParenIndex = str.indexOf(")", pipeIndex);
	        if (closeParenIndex > pipeIndex) {
	          backSlashIndex = str.indexOf("\\", pipeIndex);
	          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
	            return true;
	          }
	        }
	      }
	    }
	    if (str[index] === "\\") {
	      var open = str[index + 1];
	      index += 2;
	      var close = chars[open];
	      if (close) {
	        var n = str.indexOf(close, index);
	        if (n !== -1) {
	          index = n + 1;
	        }
	      }
	      if (str[index] === "!") {
	        return true;
	      }
	    } else {
	      index++;
	    }
	  }
	  return false;
	};
	var relaxedCheck = function(str) {
	  if (str[0] === "!") {
	    return true;
	  }
	  var index = 0;
	  while (index < str.length) {
	    if (/[*?{}()[\]]/.test(str[index])) {
	      return true;
	    }
	    if (str[index] === "\\") {
	      var open = str[index + 1];
	      index += 2;
	      var close = chars[open];
	      if (close) {
	        var n = str.indexOf(close, index);
	        if (n !== -1) {
	          index = n + 1;
	        }
	      }
	      if (str[index] === "!") {
	        return true;
	      }
	    } else {
	      index++;
	    }
	  }
	  return false;
	};
	isGlob = function isGlob(str, options) {
	  if (typeof str !== "string" || str === "") {
	    return false;
	  }
	  if (isExtglob(str)) {
	    return true;
	  }
	  var check = strictCheck;
	  if (options && options.strict === false) {
	    check = relaxedCheck;
	  }
	  return check(str);
	};
	return isGlob;
}

var globParent;
var hasRequiredGlobParent;

function requireGlobParent () {
	if (hasRequiredGlobParent) return globParent;
	hasRequiredGlobParent = 1;
	var isGlob = requireIsGlob();
	var pathPosixDirname = require$$0$2.posix.dirname;
	var isWin32 = require$$0$4.platform() === "win32";
	var slash = "/";
	var backslash = /\\/g;
	var enclosure = /[\{\[].*[\}\]]$/;
	var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
	var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
	globParent = function globParent(str, opts) {
	  var options = Object.assign({ flipBackslashes: true }, opts);
	  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
	    str = str.replace(backslash, slash);
	  }
	  if (enclosure.test(str)) {
	    str += slash;
	  }
	  str += "a";
	  do {
	    str = pathPosixDirname(str);
	  } while (isGlob(str) || globby.test(str));
	  return str.replace(escaped, "$1");
	};
	return globParent;
}

var utils$2 = {};

var hasRequiredUtils$3;

function requireUtils$3 () {
	if (hasRequiredUtils$3) return utils$2;
	hasRequiredUtils$3 = 1;
	(function (exports) {
		exports.isInteger = (num) => {
		  if (typeof num === "number") {
		    return Number.isInteger(num);
		  }
		  if (typeof num === "string" && num.trim() !== "") {
		    return Number.isInteger(Number(num));
		  }
		  return false;
		};
		exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
		exports.exceedsLimit = (min, max, step = 1, limit) => {
		  if (limit === false) return false;
		  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
		  return (Number(max) - Number(min)) / Number(step) >= limit;
		};
		exports.escapeNode = (block, n = 0, type) => {
		  const node = block.nodes[n];
		  if (!node) return;
		  if (type && node.type === type || node.type === "open" || node.type === "close") {
		    if (node.escaped !== true) {
		      node.value = "\\" + node.value;
		      node.escaped = true;
		    }
		  }
		};
		exports.encloseBrace = (node) => {
		  if (node.type !== "brace") return false;
		  if (node.commas >> 0 + node.ranges >> 0 === 0) {
		    node.invalid = true;
		    return true;
		  }
		  return false;
		};
		exports.isInvalidBrace = (block) => {
		  if (block.type !== "brace") return false;
		  if (block.invalid === true || block.dollar) return true;
		  if (block.commas >> 0 + block.ranges >> 0 === 0) {
		    block.invalid = true;
		    return true;
		  }
		  if (block.open !== true || block.close !== true) {
		    block.invalid = true;
		    return true;
		  }
		  return false;
		};
		exports.isOpenOrClose = (node) => {
		  if (node.type === "open" || node.type === "close") {
		    return true;
		  }
		  return node.open === true || node.close === true;
		};
		exports.reduce = (nodes) => nodes.reduce((acc, node) => {
		  if (node.type === "text") acc.push(node.value);
		  if (node.type === "range") node.type = "text";
		  return acc;
		}, []);
		exports.flatten = (...args) => {
		  const result = [];
		  const flat = (arr) => {
		    for (let i = 0; i < arr.length; i++) {
		      const ele = arr[i];
		      if (Array.isArray(ele)) {
		        flat(ele);
		        continue;
		      }
		      if (ele !== void 0) {
		        result.push(ele);
		      }
		    }
		    return result;
		  };
		  flat(args);
		  return result;
		}; 
	} (utils$2));
	return utils$2;
}

var stringify;
var hasRequiredStringify;

function requireStringify () {
	if (hasRequiredStringify) return stringify;
	hasRequiredStringify = 1;
	const utils = requireUtils$3();
	stringify = (ast, options = {}) => {
	  const stringify = (node, parent = {}) => {
	    const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
	    const invalidNode = node.invalid === true && options.escapeInvalid === true;
	    let output = "";
	    if (node.value) {
	      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
	        return "\\" + node.value;
	      }
	      return node.value;
	    }
	    if (node.value) {
	      return node.value;
	    }
	    if (node.nodes) {
	      for (const child of node.nodes) {
	        output += stringify(child);
	      }
	    }
	    return output;
	  };
	  return stringify(ast);
	};
	return stringify;
}

var isNumber;
var hasRequiredIsNumber;

function requireIsNumber () {
	if (hasRequiredIsNumber) return isNumber;
	hasRequiredIsNumber = 1;
	/*!
	 * is-number <https://github.com/jonschlinkert/is-number>
	 *
	 * Copyright (c) 2014-present, Jon Schlinkert.
	 * Released under the MIT License.
	 */
	isNumber = function(num) {
	  if (typeof num === "number") {
	    return num - num === 0;
	  }
	  if (typeof num === "string" && num.trim() !== "") {
	    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
	  }
	  return false;
	};
	return isNumber;
}

var toRegexRange_1;
var hasRequiredToRegexRange;

function requireToRegexRange () {
	if (hasRequiredToRegexRange) return toRegexRange_1;
	hasRequiredToRegexRange = 1;
	var __defProp = Object.defineProperty;
	var __getOwnPropSymbols = Object.getOwnPropertySymbols;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __propIsEnum = Object.prototype.propertyIsEnumerable;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp.call(b, prop))
	      __defNormalProp(a, prop, b[prop]);
	  if (__getOwnPropSymbols)
	    for (var prop of __getOwnPropSymbols(b)) {
	      if (__propIsEnum.call(b, prop))
	        __defNormalProp(a, prop, b[prop]);
	    }
	  return a;
	};
	/*!
	 * to-regex-range <https://github.com/micromatch/to-regex-range>
	 *
	 * Copyright (c) 2015-present, Jon Schlinkert.
	 * Released under the MIT License.
	 */
	const isNumber = requireIsNumber();
	const toRegexRange = (min, max, options) => {
	  if (isNumber(min) === false) {
	    throw new TypeError("toRegexRange: expected the first argument to be a number");
	  }
	  if (max === void 0 || min === max) {
	    return String(min);
	  }
	  if (isNumber(max) === false) {
	    throw new TypeError("toRegexRange: expected the second argument to be a number.");
	  }
	  let opts = __spreadValues({ relaxZeros: true }, options);
	  if (typeof opts.strictZeros === "boolean") {
	    opts.relaxZeros = opts.strictZeros === false;
	  }
	  let relax = String(opts.relaxZeros);
	  let shorthand = String(opts.shorthand);
	  let capture = String(opts.capture);
	  let wrap = String(opts.wrap);
	  let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
	  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
	    return toRegexRange.cache[cacheKey].result;
	  }
	  let a = Math.min(min, max);
	  let b = Math.max(min, max);
	  if (Math.abs(a - b) === 1) {
	    let result = min + "|" + max;
	    if (opts.capture) {
	      return `(${result})`;
	    }
	    if (opts.wrap === false) {
	      return result;
	    }
	    return `(?:${result})`;
	  }
	  let isPadded = hasPadding(min) || hasPadding(max);
	  let state = { min, max, a, b };
	  let positives = [];
	  let negatives = [];
	  if (isPadded) {
	    state.isPadded = isPadded;
	    state.maxLen = String(state.max).length;
	  }
	  if (a < 0) {
	    let newMin = b < 0 ? Math.abs(b) : 1;
	    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
	    a = state.a = 0;
	  }
	  if (b >= 0) {
	    positives = splitToPatterns(a, b, state, opts);
	  }
	  state.negatives = negatives;
	  state.positives = positives;
	  state.result = collatePatterns(negatives, positives);
	  if (opts.capture === true) {
	    state.result = `(${state.result})`;
	  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
	    state.result = `(?:${state.result})`;
	  }
	  toRegexRange.cache[cacheKey] = state;
	  return state.result;
	};
	function collatePatterns(neg, pos, options) {
	  let onlyNegative = filterPatterns(neg, pos, "-", false) || [];
	  let onlyPositive = filterPatterns(pos, neg, "", false) || [];
	  let intersected = filterPatterns(neg, pos, "-?", true) || [];
	  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
	  return subpatterns.join("|");
	}
	function splitToRanges(min, max) {
	  let nines = 1;
	  let zeros = 1;
	  let stop = countNines(min, nines);
	  let stops = /* @__PURE__ */ new Set([max]);
	  while (min <= stop && stop <= max) {
	    stops.add(stop);
	    nines += 1;
	    stop = countNines(min, nines);
	  }
	  stop = countZeros(max + 1, zeros) - 1;
	  while (min < stop && stop <= max) {
	    stops.add(stop);
	    zeros += 1;
	    stop = countZeros(max + 1, zeros) - 1;
	  }
	  stops = [...stops];
	  stops.sort(compare);
	  return stops;
	}
	function rangeToPattern(start, stop, options) {
	  if (start === stop) {
	    return { pattern: start, count: [], digits: 0 };
	  }
	  let zipped = zip(start, stop);
	  let digits = zipped.length;
	  let pattern = "";
	  let count = 0;
	  for (let i = 0; i < digits; i++) {
	    let [startDigit, stopDigit] = zipped[i];
	    if (startDigit === stopDigit) {
	      pattern += startDigit;
	    } else if (startDigit !== "0" || stopDigit !== "9") {
	      pattern += toCharacterClass(startDigit, stopDigit);
	    } else {
	      count++;
	    }
	  }
	  if (count) {
	    pattern += options.shorthand === true ? "\\d" : "[0-9]";
	  }
	  return { pattern, count: [count], digits };
	}
	function splitToPatterns(min, max, tok, options) {
	  let ranges = splitToRanges(min, max);
	  let tokens = [];
	  let start = min;
	  let prev;
	  for (let i = 0; i < ranges.length; i++) {
	    let max2 = ranges[i];
	    let obj = rangeToPattern(String(start), String(max2), options);
	    let zeros = "";
	    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
	      if (prev.count.length > 1) {
	        prev.count.pop();
	      }
	      prev.count.push(obj.count[0]);
	      prev.string = prev.pattern + toQuantifier(prev.count);
	      start = max2 + 1;
	      continue;
	    }
	    if (tok.isPadded) {
	      zeros = padZeros(max2, tok, options);
	    }
	    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
	    tokens.push(obj);
	    start = max2 + 1;
	    prev = obj;
	  }
	  return tokens;
	}
	function filterPatterns(arr, comparison, prefix, intersection, options) {
	  let result = [];
	  for (let ele of arr) {
	    let { string } = ele;
	    if (!intersection && !contains(comparison, "string", string)) {
	      result.push(prefix + string);
	    }
	    if (intersection && contains(comparison, "string", string)) {
	      result.push(prefix + string);
	    }
	  }
	  return result;
	}
	function zip(a, b) {
	  let arr = [];
	  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
	  return arr;
	}
	function compare(a, b) {
	  return a > b ? 1 : b > a ? -1 : 0;
	}
	function contains(arr, key, val) {
	  return arr.some((ele) => ele[key] === val);
	}
	function countNines(min, len) {
	  return Number(String(min).slice(0, -len) + "9".repeat(len));
	}
	function countZeros(integer, zeros) {
	  return integer - integer % Math.pow(10, zeros);
	}
	function toQuantifier(digits) {
	  let [start = 0, stop = ""] = digits;
	  if (stop || start > 1) {
	    return `{${start + (stop ? "," + stop : "")}}`;
	  }
	  return "";
	}
	function toCharacterClass(a, b, options) {
	  return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
	}
	function hasPadding(str) {
	  return /^-?(0+)\d/.test(str);
	}
	function padZeros(value, tok, options) {
	  if (!tok.isPadded) {
	    return value;
	  }
	  let diff = Math.abs(tok.maxLen - String(value).length);
	  let relax = options.relaxZeros !== false;
	  switch (diff) {
	    case 0:
	      return "";
	    case 1:
	      return relax ? "0?" : "0";
	    case 2:
	      return relax ? "0{0,2}" : "00";
	    default: {
	      return relax ? `0{0,${diff}}` : `0{${diff}}`;
	    }
	  }
	}
	toRegexRange.cache = {};
	toRegexRange.clearCache = () => toRegexRange.cache = {};
	toRegexRange_1 = toRegexRange;
	return toRegexRange_1;
}

var fillRange;
var hasRequiredFillRange;

function requireFillRange () {
	if (hasRequiredFillRange) return fillRange;
	hasRequiredFillRange = 1;
	var __defProp = Object.defineProperty;
	var __getOwnPropSymbols = Object.getOwnPropertySymbols;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __propIsEnum = Object.prototype.propertyIsEnumerable;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp.call(b, prop))
	      __defNormalProp(a, prop, b[prop]);
	  if (__getOwnPropSymbols)
	    for (var prop of __getOwnPropSymbols(b)) {
	      if (__propIsEnum.call(b, prop))
	        __defNormalProp(a, prop, b[prop]);
	    }
	  return a;
	};
	/*!
	 * fill-range <https://github.com/jonschlinkert/fill-range>
	 *
	 * Copyright (c) 2014-present, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	const util = require$$0$3;
	const toRegexRange = requireToRegexRange();
	const isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
	const transform = (toNumber) => {
	  return (value) => toNumber === true ? Number(value) : String(value);
	};
	const isValidValue = (value) => {
	  return typeof value === "number" || typeof value === "string" && value !== "";
	};
	const isNumber = (num) => Number.isInteger(+num);
	const zeros = (input) => {
	  let value = `${input}`;
	  let index = -1;
	  if (value[0] === "-") value = value.slice(1);
	  if (value === "0") return false;
	  while (value[++index] === "0") ;
	  return index > 0;
	};
	const stringify = (start, end, options) => {
	  if (typeof start === "string" || typeof end === "string") {
	    return true;
	  }
	  return options.stringify === true;
	};
	const pad = (input, maxLength, toNumber) => {
	  if (maxLength > 0) {
	    let dash = input[0] === "-" ? "-" : "";
	    if (dash) input = input.slice(1);
	    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
	  }
	  if (toNumber === false) {
	    return String(input);
	  }
	  return input;
	};
	const toMaxLen = (input, maxLength) => {
	  let negative = input[0] === "-" ? "-" : "";
	  if (negative) {
	    input = input.slice(1);
	    maxLength--;
	  }
	  while (input.length < maxLength) input = "0" + input;
	  return negative ? "-" + input : input;
	};
	const toSequence = (parts, options, maxLen) => {
	  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
	  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
	  let prefix = options.capture ? "" : "?:";
	  let positives = "";
	  let negatives = "";
	  let result;
	  if (parts.positives.length) {
	    positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
	  }
	  if (parts.negatives.length) {
	    negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
	  }
	  if (positives && negatives) {
	    result = `${positives}|${negatives}`;
	  } else {
	    result = positives || negatives;
	  }
	  if (options.wrap) {
	    return `(${prefix}${result})`;
	  }
	  return result;
	};
	const toRange = (a, b, isNumbers, options) => {
	  if (isNumbers) {
	    return toRegexRange(a, b, __spreadValues({ wrap: false }, options));
	  }
	  let start = String.fromCharCode(a);
	  if (a === b) return start;
	  let stop = String.fromCharCode(b);
	  return `[${start}-${stop}]`;
	};
	const toRegex = (start, end, options) => {
	  if (Array.isArray(start)) {
	    let wrap = options.wrap === true;
	    let prefix = options.capture ? "" : "?:";
	    return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
	  }
	  return toRegexRange(start, end, options);
	};
	const rangeError = (...args) => {
	  return new RangeError("Invalid range arguments: " + util.inspect(...args));
	};
	const invalidRange = (start, end, options) => {
	  if (options.strictRanges === true) throw rangeError([start, end]);
	  return [];
	};
	const invalidStep = (step, options) => {
	  if (options.strictRanges === true) {
	    throw new TypeError(`Expected step "${step}" to be a number`);
	  }
	  return [];
	};
	const fillNumbers = (start, end, step = 1, options = {}) => {
	  let a = Number(start);
	  let b = Number(end);
	  if (!Number.isInteger(a) || !Number.isInteger(b)) {
	    if (options.strictRanges === true) throw rangeError([start, end]);
	    return [];
	  }
	  if (a === 0) a = 0;
	  if (b === 0) b = 0;
	  let descending = a > b;
	  let startString = String(start);
	  let endString = String(end);
	  let stepString = String(step);
	  step = Math.max(Math.abs(step), 1);
	  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
	  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
	  let toNumber = padded === false && stringify(start, end, options) === false;
	  let format = options.transform || transform(toNumber);
	  if (options.toRegex && step === 1) {
	    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
	  }
	  let parts = { negatives: [], positives: [] };
	  let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
	  let range = [];
	  let index = 0;
	  while (descending ? a >= b : a <= b) {
	    if (options.toRegex === true && step > 1) {
	      push(a);
	    } else {
	      range.push(pad(format(a, index), maxLen, toNumber));
	    }
	    a = descending ? a - step : a + step;
	    index++;
	  }
	  if (options.toRegex === true) {
	    return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, __spreadValues({ wrap: false }, options));
	  }
	  return range;
	};
	const fillLetters = (start, end, step = 1, options = {}) => {
	  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
	    return invalidRange(start, end, options);
	  }
	  let format = options.transform || ((val) => String.fromCharCode(val));
	  let a = `${start}`.charCodeAt(0);
	  let b = `${end}`.charCodeAt(0);
	  let descending = a > b;
	  let min = Math.min(a, b);
	  let max = Math.max(a, b);
	  if (options.toRegex && step === 1) {
	    return toRange(min, max, false, options);
	  }
	  let range = [];
	  let index = 0;
	  while (descending ? a >= b : a <= b) {
	    range.push(format(a, index));
	    a = descending ? a - step : a + step;
	    index++;
	  }
	  if (options.toRegex === true) {
	    return toRegex(range, null, { wrap: false, options });
	  }
	  return range;
	};
	const fill = (start, end, step, options = {}) => {
	  if (end == null && isValidValue(start)) {
	    return [start];
	  }
	  if (!isValidValue(start) || !isValidValue(end)) {
	    return invalidRange(start, end, options);
	  }
	  if (typeof step === "function") {
	    return fill(start, end, 1, { transform: step });
	  }
	  if (isObject(step)) {
	    return fill(start, end, 0, step);
	  }
	  let opts = __spreadValues({}, options);
	  if (opts.capture === true) opts.wrap = true;
	  step = step || opts.step || 1;
	  if (!isNumber(step)) {
	    if (step != null && !isObject(step)) return invalidStep(step, opts);
	    return fill(start, end, 1, step);
	  }
	  if (isNumber(start) && isNumber(end)) {
	    return fillNumbers(start, end, step, opts);
	  }
	  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
	};
	fillRange = fill;
	return fillRange;
}

var compile_1;
var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile_1;
	hasRequiredCompile = 1;
	var __defProp = Object.defineProperty;
	var __defProps = Object.defineProperties;
	var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols = Object.getOwnPropertySymbols;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __propIsEnum = Object.prototype.propertyIsEnumerable;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp.call(b, prop))
	      __defNormalProp(a, prop, b[prop]);
	  if (__getOwnPropSymbols)
	    for (var prop of __getOwnPropSymbols(b)) {
	      if (__propIsEnum.call(b, prop))
	        __defNormalProp(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
	const fill = requireFillRange();
	const utils = requireUtils$3();
	const compile = (ast, options = {}) => {
	  const walk = (node, parent = {}) => {
	    const invalidBlock = utils.isInvalidBrace(parent);
	    const invalidNode = node.invalid === true && options.escapeInvalid === true;
	    const invalid = invalidBlock === true || invalidNode === true;
	    const prefix = options.escapeInvalid === true ? "\\" : "";
	    let output = "";
	    if (node.isOpen === true) {
	      return prefix + node.value;
	    }
	    if (node.isClose === true) {
	      console.log("node.isClose", prefix, node.value);
	      return prefix + node.value;
	    }
	    if (node.type === "open") {
	      return invalid ? prefix + node.value : "(";
	    }
	    if (node.type === "close") {
	      return invalid ? prefix + node.value : ")";
	    }
	    if (node.type === "comma") {
	      return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
	    }
	    if (node.value) {
	      return node.value;
	    }
	    if (node.nodes && node.ranges > 0) {
	      const args = utils.reduce(node.nodes);
	      const range = fill(...args, __spreadProps(__spreadValues({}, options), { wrap: false, toRegex: true, strictZeros: true }));
	      if (range.length !== 0) {
	        return args.length > 1 && range.length > 1 ? `(${range})` : range;
	      }
	    }
	    if (node.nodes) {
	      for (const child of node.nodes) {
	        output += walk(child, node);
	      }
	    }
	    return output;
	  };
	  return walk(ast);
	};
	compile_1 = compile;
	return compile_1;
}

var expand_1;
var hasRequiredExpand;

function requireExpand () {
	if (hasRequiredExpand) return expand_1;
	hasRequiredExpand = 1;
	const fill = requireFillRange();
	const stringify = requireStringify();
	const utils = requireUtils$3();
	const append = (queue = "", stash = "", enclose = false) => {
	  const result = [];
	  queue = [].concat(queue);
	  stash = [].concat(stash);
	  if (!stash.length) return queue;
	  if (!queue.length) {
	    return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
	  }
	  for (const item of queue) {
	    if (Array.isArray(item)) {
	      for (const value of item) {
	        result.push(append(value, stash, enclose));
	      }
	    } else {
	      for (let ele of stash) {
	        if (enclose === true && typeof ele === "string") ele = `{${ele}}`;
	        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
	      }
	    }
	  }
	  return utils.flatten(result);
	};
	const expand = (ast, options = {}) => {
	  const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
	  const walk = (node, parent = {}) => {
	    node.queue = [];
	    let p = parent;
	    let q = parent.queue;
	    while (p.type !== "brace" && p.type !== "root" && p.parent) {
	      p = p.parent;
	      q = p.queue;
	    }
	    if (node.invalid || node.dollar) {
	      q.push(append(q.pop(), stringify(node, options)));
	      return;
	    }
	    if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
	      q.push(append(q.pop(), ["{}"]));
	      return;
	    }
	    if (node.nodes && node.ranges > 0) {
	      const args = utils.reduce(node.nodes);
	      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
	        throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
	      }
	      let range = fill(...args, options);
	      if (range.length === 0) {
	        range = stringify(node, options);
	      }
	      q.push(append(q.pop(), range));
	      node.nodes = [];
	      return;
	    }
	    const enclose = utils.encloseBrace(node);
	    let queue = node.queue;
	    let block = node;
	    while (block.type !== "brace" && block.type !== "root" && block.parent) {
	      block = block.parent;
	      queue = block.queue;
	    }
	    for (let i = 0; i < node.nodes.length; i++) {
	      const child = node.nodes[i];
	      if (child.type === "comma" && node.type === "brace") {
	        if (i === 1) queue.push("");
	        queue.push("");
	        continue;
	      }
	      if (child.type === "close") {
	        q.push(append(q.pop(), queue, enclose));
	        continue;
	      }
	      if (child.value && child.type !== "open") {
	        queue.push(append(queue.pop(), child.value));
	        continue;
	      }
	      if (child.nodes) {
	        walk(child, node);
	      }
	    }
	    return queue;
	  };
	  return utils.flatten(walk(ast));
	};
	expand_1 = expand;
	return expand_1;
}

var constants$2;
var hasRequiredConstants$2;

function requireConstants$2 () {
	if (hasRequiredConstants$2) return constants$2;
	hasRequiredConstants$2 = 1;
	constants$2 = {
	  MAX_LENGTH: 1e4,
	  // Digits
	  CHAR_0: "0",
	  /* 0 */
	  CHAR_9: "9",
	  /* 9 */
	  // Alphabet chars.
	  CHAR_UPPERCASE_A: "A",
	  /* A */
	  CHAR_LOWERCASE_A: "a",
	  /* a */
	  CHAR_UPPERCASE_Z: "Z",
	  /* Z */
	  CHAR_LOWERCASE_Z: "z",
	  /* z */
	  CHAR_LEFT_PARENTHESES: "(",
	  /* ( */
	  CHAR_RIGHT_PARENTHESES: ")",
	  /* ) */
	  CHAR_ASTERISK: "*",
	  /* * */
	  // Non-alphabetic chars.
	  CHAR_AMPERSAND: "&",
	  /* & */
	  CHAR_AT: "@",
	  /* @ */
	  CHAR_BACKSLASH: "\\",
	  /* \ */
	  CHAR_BACKTICK: "`",
	  /* ` */
	  CHAR_CARRIAGE_RETURN: "\r",
	  /* \r */
	  CHAR_CIRCUMFLEX_ACCENT: "^",
	  /* ^ */
	  CHAR_COLON: ":",
	  /* : */
	  CHAR_COMMA: ",",
	  /* , */
	  CHAR_DOLLAR: "$",
	  /* . */
	  CHAR_DOT: ".",
	  /* . */
	  CHAR_DOUBLE_QUOTE: '"',
	  /* " */
	  CHAR_EQUAL: "=",
	  /* = */
	  CHAR_EXCLAMATION_MARK: "!",
	  /* ! */
	  CHAR_FORM_FEED: "\f",
	  /* \f */
	  CHAR_FORWARD_SLASH: "/",
	  /* / */
	  CHAR_HASH: "#",
	  /* # */
	  CHAR_HYPHEN_MINUS: "-",
	  /* - */
	  CHAR_LEFT_ANGLE_BRACKET: "<",
	  /* < */
	  CHAR_LEFT_CURLY_BRACE: "{",
	  /* { */
	  CHAR_LEFT_SQUARE_BRACKET: "[",
	  /* [ */
	  CHAR_LINE_FEED: "\n",
	  /* \n */
	  CHAR_NO_BREAK_SPACE: "\xA0",
	  /* \u00A0 */
	  CHAR_PERCENT: "%",
	  /* % */
	  CHAR_PLUS: "+",
	  /* + */
	  CHAR_QUESTION_MARK: "?",
	  /* ? */
	  CHAR_RIGHT_ANGLE_BRACKET: ">",
	  /* > */
	  CHAR_RIGHT_CURLY_BRACE: "}",
	  /* } */
	  CHAR_RIGHT_SQUARE_BRACKET: "]",
	  /* ] */
	  CHAR_SEMICOLON: ";",
	  /* ; */
	  CHAR_SINGLE_QUOTE: "'",
	  /* ' */
	  CHAR_SPACE: " ",
	  /*   */
	  CHAR_TAB: "	",
	  /* \t */
	  CHAR_UNDERSCORE: "_",
	  /* _ */
	  CHAR_VERTICAL_LINE: "|",
	  /* | */
	  CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
	  /* \uFEFF */
	};
	return constants$2;
}

var parse_1$1;
var hasRequiredParse$1;

function requireParse$1 () {
	if (hasRequiredParse$1) return parse_1$1;
	hasRequiredParse$1 = 1;
	const stringify = requireStringify();
	const {
	  MAX_LENGTH,
	  CHAR_BACKSLASH,
	  /* \ */
	  CHAR_BACKTICK,
	  /* ` */
	  CHAR_COMMA,
	  /* , */
	  CHAR_DOT,
	  /* . */
	  CHAR_LEFT_PARENTHESES,
	  /* ( */
	  CHAR_RIGHT_PARENTHESES,
	  /* ) */
	  CHAR_LEFT_CURLY_BRACE,
	  /* { */
	  CHAR_RIGHT_CURLY_BRACE,
	  /* } */
	  CHAR_LEFT_SQUARE_BRACKET,
	  /* [ */
	  CHAR_RIGHT_SQUARE_BRACKET,
	  /* ] */
	  CHAR_DOUBLE_QUOTE,
	  /* " */
	  CHAR_SINGLE_QUOTE,
	  /* ' */
	  CHAR_NO_BREAK_SPACE,
	  CHAR_ZERO_WIDTH_NOBREAK_SPACE
	} = requireConstants$2();
	const parse = (input, options = {}) => {
	  if (typeof input !== "string") {
	    throw new TypeError("Expected a string");
	  }
	  const opts = options || {};
	  const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
	  if (input.length > max) {
	    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
	  }
	  const ast = { type: "root", input, nodes: [] };
	  const stack = [ast];
	  let block = ast;
	  let prev = ast;
	  let brackets = 0;
	  const length = input.length;
	  let index = 0;
	  let depth = 0;
	  let value;
	  const advance = () => input[index++];
	  const push = (node) => {
	    if (node.type === "text" && prev.type === "dot") {
	      prev.type = "text";
	    }
	    if (prev && prev.type === "text" && node.type === "text") {
	      prev.value += node.value;
	      return;
	    }
	    block.nodes.push(node);
	    node.parent = block;
	    node.prev = prev;
	    prev = node;
	    return node;
	  };
	  push({ type: "bos" });
	  while (index < length) {
	    block = stack[stack.length - 1];
	    value = advance();
	    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
	      continue;
	    }
	    if (value === CHAR_BACKSLASH) {
	      push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
	      continue;
	    }
	    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
	      push({ type: "text", value: "\\" + value });
	      continue;
	    }
	    if (value === CHAR_LEFT_SQUARE_BRACKET) {
	      brackets++;
	      let next;
	      while (index < length && (next = advance())) {
	        value += next;
	        if (next === CHAR_LEFT_SQUARE_BRACKET) {
	          brackets++;
	          continue;
	        }
	        if (next === CHAR_BACKSLASH) {
	          value += advance();
	          continue;
	        }
	        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
	          brackets--;
	          if (brackets === 0) {
	            break;
	          }
	        }
	      }
	      push({ type: "text", value });
	      continue;
	    }
	    if (value === CHAR_LEFT_PARENTHESES) {
	      block = push({ type: "paren", nodes: [] });
	      stack.push(block);
	      push({ type: "text", value });
	      continue;
	    }
	    if (value === CHAR_RIGHT_PARENTHESES) {
	      if (block.type !== "paren") {
	        push({ type: "text", value });
	        continue;
	      }
	      block = stack.pop();
	      push({ type: "text", value });
	      block = stack[stack.length - 1];
	      continue;
	    }
	    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
	      const open = value;
	      let next;
	      if (options.keepQuotes !== true) {
	        value = "";
	      }
	      while (index < length && (next = advance())) {
	        if (next === CHAR_BACKSLASH) {
	          value += next + advance();
	          continue;
	        }
	        if (next === open) {
	          if (options.keepQuotes === true) value += next;
	          break;
	        }
	        value += next;
	      }
	      push({ type: "text", value });
	      continue;
	    }
	    if (value === CHAR_LEFT_CURLY_BRACE) {
	      depth++;
	      const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
	      const brace = {
	        type: "brace",
	        open: true,
	        close: false,
	        dollar,
	        depth,
	        commas: 0,
	        ranges: 0,
	        nodes: []
	      };
	      block = push(brace);
	      stack.push(block);
	      push({ type: "open", value });
	      continue;
	    }
	    if (value === CHAR_RIGHT_CURLY_BRACE) {
	      if (block.type !== "brace") {
	        push({ type: "text", value });
	        continue;
	      }
	      const type = "close";
	      block = stack.pop();
	      block.close = true;
	      push({ type, value });
	      depth--;
	      block = stack[stack.length - 1];
	      continue;
	    }
	    if (value === CHAR_COMMA && depth > 0) {
	      if (block.ranges > 0) {
	        block.ranges = 0;
	        const open = block.nodes.shift();
	        block.nodes = [open, { type: "text", value: stringify(block) }];
	      }
	      push({ type: "comma", value });
	      block.commas++;
	      continue;
	    }
	    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
	      const siblings = block.nodes;
	      if (depth === 0 || siblings.length === 0) {
	        push({ type: "text", value });
	        continue;
	      }
	      if (prev.type === "dot") {
	        block.range = [];
	        prev.value += value;
	        prev.type = "range";
	        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
	          block.invalid = true;
	          block.ranges = 0;
	          prev.type = "text";
	          continue;
	        }
	        block.ranges++;
	        block.args = [];
	        continue;
	      }
	      if (prev.type === "range") {
	        siblings.pop();
	        const before = siblings[siblings.length - 1];
	        before.value += prev.value + value;
	        prev = before;
	        block.ranges--;
	        continue;
	      }
	      push({ type: "dot", value });
	      continue;
	    }
	    push({ type: "text", value });
	  }
	  do {
	    block = stack.pop();
	    if (block.type !== "root") {
	      block.nodes.forEach((node) => {
	        if (!node.nodes) {
	          if (node.type === "open") node.isOpen = true;
	          if (node.type === "close") node.isClose = true;
	          if (!node.nodes) node.type = "text";
	          node.invalid = true;
	        }
	      });
	      const parent = stack[stack.length - 1];
	      const index2 = parent.nodes.indexOf(block);
	      parent.nodes.splice(index2, 1, ...block.nodes);
	    }
	  } while (stack.length > 0);
	  push({ type: "eos" });
	  return ast;
	};
	parse_1$1 = parse;
	return parse_1$1;
}

var braces_1;
var hasRequiredBraces;

function requireBraces () {
	if (hasRequiredBraces) return braces_1;
	hasRequiredBraces = 1;
	const stringify = requireStringify();
	const compile = requireCompile();
	const expand = requireExpand();
	const parse = requireParse$1();
	const braces = (input, options = {}) => {
	  let output = [];
	  if (Array.isArray(input)) {
	    for (const pattern of input) {
	      const result = braces.create(pattern, options);
	      if (Array.isArray(result)) {
	        output.push(...result);
	      } else {
	        output.push(result);
	      }
	    }
	  } else {
	    output = [].concat(braces.create(input, options));
	  }
	  if (options && options.expand === true && options.nodupes === true) {
	    output = [...new Set(output)];
	  }
	  return output;
	};
	braces.parse = (input, options = {}) => parse(input, options);
	braces.stringify = (input, options = {}) => {
	  if (typeof input === "string") {
	    return stringify(braces.parse(input, options), options);
	  }
	  return stringify(input, options);
	};
	braces.compile = (input, options = {}) => {
	  if (typeof input === "string") {
	    input = braces.parse(input, options);
	  }
	  return compile(input, options);
	};
	braces.expand = (input, options = {}) => {
	  if (typeof input === "string") {
	    input = braces.parse(input, options);
	  }
	  let result = expand(input, options);
	  if (options.noempty === true) {
	    result = result.filter(Boolean);
	  }
	  if (options.nodupes === true) {
	    result = [...new Set(result)];
	  }
	  return result;
	};
	braces.create = (input, options = {}) => {
	  if (input === "" || input.length < 3) {
	    return [input];
	  }
	  return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
	};
	braces_1 = braces;
	return braces_1;
}

var utils$1 = {};

var constants$1;
var hasRequiredConstants$1;

function requireConstants$1 () {
	if (hasRequiredConstants$1) return constants$1;
	hasRequiredConstants$1 = 1;
	var __defProp = Object.defineProperty;
	var __defProps = Object.defineProperties;
	var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols = Object.getOwnPropertySymbols;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __propIsEnum = Object.prototype.propertyIsEnumerable;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp.call(b, prop))
	      __defNormalProp(a, prop, b[prop]);
	  if (__getOwnPropSymbols)
	    for (var prop of __getOwnPropSymbols(b)) {
	      if (__propIsEnum.call(b, prop))
	        __defNormalProp(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
	const path = require$$0$2;
	const WIN_SLASH = "\\\\/";
	const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
	const DOT_LITERAL = "\\.";
	const PLUS_LITERAL = "\\+";
	const QMARK_LITERAL = "\\?";
	const SLASH_LITERAL = "\\/";
	const ONE_CHAR = "(?=.)";
	const QMARK = "[^/]";
	const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
	const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
	const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
	const NO_DOT = `(?!${DOT_LITERAL})`;
	const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
	const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
	const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
	const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
	const STAR = `${QMARK}*?`;
	const POSIX_CHARS = {
	  DOT_LITERAL,
	  PLUS_LITERAL,
	  QMARK_LITERAL,
	  SLASH_LITERAL,
	  ONE_CHAR,
	  QMARK,
	  END_ANCHOR,
	  DOTS_SLASH,
	  NO_DOT,
	  NO_DOTS,
	  NO_DOT_SLASH,
	  NO_DOTS_SLASH,
	  QMARK_NO_DOT,
	  STAR,
	  START_ANCHOR
	};
	const WINDOWS_CHARS = __spreadProps(__spreadValues({}, POSIX_CHARS), {
	  SLASH_LITERAL: `[${WIN_SLASH}]`,
	  QMARK: WIN_NO_SLASH,
	  STAR: `${WIN_NO_SLASH}*?`,
	  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
	  NO_DOT: `(?!${DOT_LITERAL})`,
	  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
	  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
	  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
	  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
	  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
	  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
	});
	const POSIX_REGEX_SOURCE = {
	  alnum: "a-zA-Z0-9",
	  alpha: "a-zA-Z",
	  ascii: "\\x00-\\x7F",
	  blank: " \\t",
	  cntrl: "\\x00-\\x1F\\x7F",
	  digit: "0-9",
	  graph: "\\x21-\\x7E",
	  lower: "a-z",
	  print: "\\x20-\\x7E ",
	  punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
	  space: " \\t\\r\\n\\v\\f",
	  upper: "A-Z",
	  word: "A-Za-z0-9_",
	  xdigit: "A-Fa-f0-9"
	};
	constants$1 = {
	  MAX_LENGTH: 1024 * 64,
	  POSIX_REGEX_SOURCE,
	  // regular expressions
	  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
	  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
	  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
	  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
	  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
	  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
	  // Replace globs with equivalent patterns to reduce parsing time.
	  REPLACEMENTS: {
	    "***": "*",
	    "**/**": "**",
	    "**/**/**": "**"
	  },
	  // Digits
	  CHAR_0: 48,
	  /* 0 */
	  CHAR_9: 57,
	  /* 9 */
	  // Alphabet chars.
	  CHAR_UPPERCASE_A: 65,
	  /* A */
	  CHAR_LOWERCASE_A: 97,
	  /* a */
	  CHAR_UPPERCASE_Z: 90,
	  /* Z */
	  CHAR_LOWERCASE_Z: 122,
	  /* z */
	  CHAR_LEFT_PARENTHESES: 40,
	  /* ( */
	  CHAR_RIGHT_PARENTHESES: 41,
	  /* ) */
	  CHAR_ASTERISK: 42,
	  /* * */
	  // Non-alphabetic chars.
	  CHAR_AMPERSAND: 38,
	  /* & */
	  CHAR_AT: 64,
	  /* @ */
	  CHAR_BACKWARD_SLASH: 92,
	  /* \ */
	  CHAR_CARRIAGE_RETURN: 13,
	  /* \r */
	  CHAR_CIRCUMFLEX_ACCENT: 94,
	  /* ^ */
	  CHAR_COLON: 58,
	  /* : */
	  CHAR_COMMA: 44,
	  /* , */
	  CHAR_DOT: 46,
	  /* . */
	  CHAR_DOUBLE_QUOTE: 34,
	  /* " */
	  CHAR_EQUAL: 61,
	  /* = */
	  CHAR_EXCLAMATION_MARK: 33,
	  /* ! */
	  CHAR_FORM_FEED: 12,
	  /* \f */
	  CHAR_FORWARD_SLASH: 47,
	  /* / */
	  CHAR_GRAVE_ACCENT: 96,
	  /* ` */
	  CHAR_HASH: 35,
	  /* # */
	  CHAR_HYPHEN_MINUS: 45,
	  /* - */
	  CHAR_LEFT_ANGLE_BRACKET: 60,
	  /* < */
	  CHAR_LEFT_CURLY_BRACE: 123,
	  /* { */
	  CHAR_LEFT_SQUARE_BRACKET: 91,
	  /* [ */
	  CHAR_LINE_FEED: 10,
	  /* \n */
	  CHAR_NO_BREAK_SPACE: 160,
	  /* \u00A0 */
	  CHAR_PERCENT: 37,
	  /* % */
	  CHAR_PLUS: 43,
	  /* + */
	  CHAR_QUESTION_MARK: 63,
	  /* ? */
	  CHAR_RIGHT_ANGLE_BRACKET: 62,
	  /* > */
	  CHAR_RIGHT_CURLY_BRACE: 125,
	  /* } */
	  CHAR_RIGHT_SQUARE_BRACKET: 93,
	  /* ] */
	  CHAR_SEMICOLON: 59,
	  /* ; */
	  CHAR_SINGLE_QUOTE: 39,
	  /* ' */
	  CHAR_SPACE: 32,
	  /*   */
	  CHAR_TAB: 9,
	  /* \t */
	  CHAR_UNDERSCORE: 95,
	  /* _ */
	  CHAR_VERTICAL_LINE: 124,
	  /* | */
	  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
	  /* \uFEFF */
	  SEP: path.sep,
	  /**
	   * Create EXTGLOB_CHARS
	   */
	  extglobChars(chars) {
	    return {
	      "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
	      "?": { type: "qmark", open: "(?:", close: ")?" },
	      "+": { type: "plus", open: "(?:", close: ")+" },
	      "*": { type: "star", open: "(?:", close: ")*" },
	      "@": { type: "at", open: "(?:", close: ")" }
	    };
	  },
	  /**
	   * Create GLOB_CHARS
	   */
	  globChars(win32) {
	    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
	  }
	};
	return constants$1;
}

var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$1;
	hasRequiredUtils$2 = 1;
	(function (exports) {
		const path = require$$0$2;
		const win32 = process.platform === "win32";
		const {
		  REGEX_BACKSLASH,
		  REGEX_REMOVE_BACKSLASH,
		  REGEX_SPECIAL_CHARS,
		  REGEX_SPECIAL_CHARS_GLOBAL
		} = requireConstants$1();
		exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
		exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
		exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
		exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
		exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
		exports.removeBackslashes = (str) => {
		  return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
		    return match === "\\" ? "" : match;
		  });
		};
		exports.supportsLookbehinds = () => {
		  const segs = process.version.slice(1).split(".").map(Number);
		  if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
		    return true;
		  }
		  return false;
		};
		exports.isWindows = (options) => {
		  if (options && typeof options.windows === "boolean") {
		    return options.windows;
		  }
		  return win32 === true || path.sep === "\\";
		};
		exports.escapeLast = (input, char, lastIdx) => {
		  const idx = input.lastIndexOf(char, lastIdx);
		  if (idx === -1) return input;
		  if (input[idx - 1] === "\\") return exports.escapeLast(input, char, idx - 1);
		  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
		};
		exports.removePrefix = (input, state = {}) => {
		  let output = input;
		  if (output.startsWith("./")) {
		    output = output.slice(2);
		    state.prefix = "./";
		  }
		  return output;
		};
		exports.wrapOutput = (input, state = {}, options = {}) => {
		  const prepend = options.contains ? "" : "^";
		  const append = options.contains ? "" : "$";
		  let output = `${prepend}(?:${input})${append}`;
		  if (state.negated === true) {
		    output = `(?:^(?!${output}).*$)`;
		  }
		  return output;
		}; 
	} (utils$1));
	return utils$1;
}

var scan_1;
var hasRequiredScan;

function requireScan () {
	if (hasRequiredScan) return scan_1;
	hasRequiredScan = 1;
	const utils = requireUtils$2();
	const {
	  CHAR_ASTERISK,
	  /* * */
	  CHAR_AT,
	  /* @ */
	  CHAR_BACKWARD_SLASH,
	  /* \ */
	  CHAR_COMMA,
	  /* , */
	  CHAR_DOT,
	  /* . */
	  CHAR_EXCLAMATION_MARK,
	  /* ! */
	  CHAR_FORWARD_SLASH,
	  /* / */
	  CHAR_LEFT_CURLY_BRACE,
	  /* { */
	  CHAR_LEFT_PARENTHESES,
	  /* ( */
	  CHAR_LEFT_SQUARE_BRACKET,
	  /* [ */
	  CHAR_PLUS,
	  /* + */
	  CHAR_QUESTION_MARK,
	  /* ? */
	  CHAR_RIGHT_CURLY_BRACE,
	  /* } */
	  CHAR_RIGHT_PARENTHESES,
	  /* ) */
	  CHAR_RIGHT_SQUARE_BRACKET
	  /* ] */
	} = requireConstants$1();
	const isPathSeparator = (code) => {
	  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
	};
	const depth = (token) => {
	  if (token.isPrefix !== true) {
	    token.depth = token.isGlobstar ? Infinity : 1;
	  }
	};
	const scan = (input, options) => {
	  const opts = options || {};
	  const length = input.length - 1;
	  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
	  const slashes = [];
	  const tokens = [];
	  const parts = [];
	  let str = input;
	  let index = -1;
	  let start = 0;
	  let lastIndex = 0;
	  let isBrace = false;
	  let isBracket = false;
	  let isGlob = false;
	  let isExtglob = false;
	  let isGlobstar = false;
	  let braceEscaped = false;
	  let backslashes = false;
	  let negated = false;
	  let negatedExtglob = false;
	  let finished = false;
	  let braces = 0;
	  let prev;
	  let code;
	  let token = { value: "", depth: 0, isGlob: false };
	  const eos = () => index >= length;
	  const peek = () => str.charCodeAt(index + 1);
	  const advance = () => {
	    prev = code;
	    return str.charCodeAt(++index);
	  };
	  while (index < length) {
	    code = advance();
	    let next;
	    if (code === CHAR_BACKWARD_SLASH) {
	      backslashes = token.backslashes = true;
	      code = advance();
	      if (code === CHAR_LEFT_CURLY_BRACE) {
	        braceEscaped = true;
	      }
	      continue;
	    }
	    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
	      braces++;
	      while (eos() !== true && (code = advance())) {
	        if (code === CHAR_BACKWARD_SLASH) {
	          backslashes = token.backslashes = true;
	          advance();
	          continue;
	        }
	        if (code === CHAR_LEFT_CURLY_BRACE) {
	          braces++;
	          continue;
	        }
	        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
	          isBrace = token.isBrace = true;
	          isGlob = token.isGlob = true;
	          finished = true;
	          if (scanToEnd === true) {
	            continue;
	          }
	          break;
	        }
	        if (braceEscaped !== true && code === CHAR_COMMA) {
	          isBrace = token.isBrace = true;
	          isGlob = token.isGlob = true;
	          finished = true;
	          if (scanToEnd === true) {
	            continue;
	          }
	          break;
	        }
	        if (code === CHAR_RIGHT_CURLY_BRACE) {
	          braces--;
	          if (braces === 0) {
	            braceEscaped = false;
	            isBrace = token.isBrace = true;
	            finished = true;
	            break;
	          }
	        }
	      }
	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }
	    if (code === CHAR_FORWARD_SLASH) {
	      slashes.push(index);
	      tokens.push(token);
	      token = { value: "", depth: 0, isGlob: false };
	      if (finished === true) continue;
	      if (prev === CHAR_DOT && index === start + 1) {
	        start += 2;
	        continue;
	      }
	      lastIndex = index + 1;
	      continue;
	    }
	    if (opts.noext !== true) {
	      const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
	      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
	        isGlob = token.isGlob = true;
	        isExtglob = token.isExtglob = true;
	        finished = true;
	        if (code === CHAR_EXCLAMATION_MARK && index === start) {
	          negatedExtglob = true;
	        }
	        if (scanToEnd === true) {
	          while (eos() !== true && (code = advance())) {
	            if (code === CHAR_BACKWARD_SLASH) {
	              backslashes = token.backslashes = true;
	              code = advance();
	              continue;
	            }
	            if (code === CHAR_RIGHT_PARENTHESES) {
	              isGlob = token.isGlob = true;
	              finished = true;
	              break;
	            }
	          }
	          continue;
	        }
	        break;
	      }
	    }
	    if (code === CHAR_ASTERISK) {
	      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
	      isGlob = token.isGlob = true;
	      finished = true;
	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }
	    if (code === CHAR_QUESTION_MARK) {
	      isGlob = token.isGlob = true;
	      finished = true;
	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }
	    if (code === CHAR_LEFT_SQUARE_BRACKET) {
	      while (eos() !== true && (next = advance())) {
	        if (next === CHAR_BACKWARD_SLASH) {
	          backslashes = token.backslashes = true;
	          advance();
	          continue;
	        }
	        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
	          isBracket = token.isBracket = true;
	          isGlob = token.isGlob = true;
	          finished = true;
	          break;
	        }
	      }
	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }
	    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
	      negated = token.negated = true;
	      start++;
	      continue;
	    }
	    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
	      isGlob = token.isGlob = true;
	      if (scanToEnd === true) {
	        while (eos() !== true && (code = advance())) {
	          if (code === CHAR_LEFT_PARENTHESES) {
	            backslashes = token.backslashes = true;
	            code = advance();
	            continue;
	          }
	          if (code === CHAR_RIGHT_PARENTHESES) {
	            finished = true;
	            break;
	          }
	        }
	        continue;
	      }
	      break;
	    }
	    if (isGlob === true) {
	      finished = true;
	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }
	  }
	  if (opts.noext === true) {
	    isExtglob = false;
	    isGlob = false;
	  }
	  let base = str;
	  let prefix = "";
	  let glob = "";
	  if (start > 0) {
	    prefix = str.slice(0, start);
	    str = str.slice(start);
	    lastIndex -= start;
	  }
	  if (base && isGlob === true && lastIndex > 0) {
	    base = str.slice(0, lastIndex);
	    glob = str.slice(lastIndex);
	  } else if (isGlob === true) {
	    base = "";
	    glob = str;
	  } else {
	    base = str;
	  }
	  if (base && base !== "" && base !== "/" && base !== str) {
	    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
	      base = base.slice(0, -1);
	    }
	  }
	  if (opts.unescape === true) {
	    if (glob) glob = utils.removeBackslashes(glob);
	    if (base && backslashes === true) {
	      base = utils.removeBackslashes(base);
	    }
	  }
	  const state = {
	    prefix,
	    input,
	    start,
	    base,
	    glob,
	    isBrace,
	    isBracket,
	    isGlob,
	    isExtglob,
	    isGlobstar,
	    negated,
	    negatedExtglob
	  };
	  if (opts.tokens === true) {
	    state.maxDepth = 0;
	    if (!isPathSeparator(code)) {
	      tokens.push(token);
	    }
	    state.tokens = tokens;
	  }
	  if (opts.parts === true || opts.tokens === true) {
	    let prevIndex;
	    for (let idx = 0; idx < slashes.length; idx++) {
	      const n = prevIndex ? prevIndex + 1 : start;
	      const i = slashes[idx];
	      const value = input.slice(n, i);
	      if (opts.tokens) {
	        if (idx === 0 && start !== 0) {
	          tokens[idx].isPrefix = true;
	          tokens[idx].value = prefix;
	        } else {
	          tokens[idx].value = value;
	        }
	        depth(tokens[idx]);
	        state.maxDepth += tokens[idx].depth;
	      }
	      if (idx !== 0 || value !== "") {
	        parts.push(value);
	      }
	      prevIndex = i;
	    }
	    if (prevIndex && prevIndex + 1 < input.length) {
	      const value = input.slice(prevIndex + 1);
	      parts.push(value);
	      if (opts.tokens) {
	        tokens[tokens.length - 1].value = value;
	        depth(tokens[tokens.length - 1]);
	        state.maxDepth += tokens[tokens.length - 1].depth;
	      }
	    }
	    state.slashes = slashes;
	    state.parts = parts;
	  }
	  return state;
	};
	scan_1 = scan;
	return scan_1;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;
	var __defProp = Object.defineProperty;
	var __defProps = Object.defineProperties;
	var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols = Object.getOwnPropertySymbols;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __propIsEnum = Object.prototype.propertyIsEnumerable;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp.call(b, prop))
	      __defNormalProp(a, prop, b[prop]);
	  if (__getOwnPropSymbols)
	    for (var prop of __getOwnPropSymbols(b)) {
	      if (__propIsEnum.call(b, prop))
	        __defNormalProp(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
	const constants = requireConstants$1();
	const utils = requireUtils$2();
	const {
	  MAX_LENGTH,
	  POSIX_REGEX_SOURCE,
	  REGEX_NON_SPECIAL_CHARS,
	  REGEX_SPECIAL_CHARS_BACKREF,
	  REPLACEMENTS
	} = constants;
	const expandRange = (args, options) => {
	  if (typeof options.expandRange === "function") {
	    return options.expandRange(...args, options);
	  }
	  args.sort();
	  const value = `[${args.join("-")}]`;
	  try {
	    new RegExp(value);
	  } catch (ex) {
	    return args.map((v) => utils.escapeRegex(v)).join("..");
	  }
	  return value;
	};
	const syntaxError = (type, char) => {
	  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
	};
	const parse = (input, options) => {
	  if (typeof input !== "string") {
	    throw new TypeError("Expected a string");
	  }
	  input = REPLACEMENTS[input] || input;
	  const opts = __spreadValues({}, options);
	  const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
	  let len = input.length;
	  if (len > max) {
	    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
	  }
	  const bos = { type: "bos", value: "", output: opts.prepend || "" };
	  const tokens = [bos];
	  const capture = opts.capture ? "" : "?:";
	  const win32 = utils.isWindows(options);
	  const PLATFORM_CHARS = constants.globChars(win32);
	  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
	  const {
	    DOT_LITERAL,
	    PLUS_LITERAL,
	    SLASH_LITERAL,
	    ONE_CHAR,
	    DOTS_SLASH,
	    NO_DOT,
	    NO_DOT_SLASH,
	    NO_DOTS_SLASH,
	    QMARK,
	    QMARK_NO_DOT,
	    STAR,
	    START_ANCHOR
	  } = PLATFORM_CHARS;
	  const globstar = (opts2) => {
	    return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
	  };
	  const nodot = opts.dot ? "" : NO_DOT;
	  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
	  let star = opts.bash === true ? globstar(opts) : STAR;
	  if (opts.capture) {
	    star = `(${star})`;
	  }
	  if (typeof opts.noext === "boolean") {
	    opts.noextglob = opts.noext;
	  }
	  const state = {
	    input,
	    index: -1,
	    start: 0,
	    dot: opts.dot === true,
	    consumed: "",
	    output: "",
	    prefix: "",
	    backtrack: false,
	    negated: false,
	    brackets: 0,
	    braces: 0,
	    parens: 0,
	    quotes: 0,
	    globstar: false,
	    tokens
	  };
	  input = utils.removePrefix(input, state);
	  len = input.length;
	  const extglobs = [];
	  const braces = [];
	  const stack = [];
	  let prev = bos;
	  let value;
	  const eos = () => state.index === len - 1;
	  const peek = state.peek = (n = 1) => input[state.index + n];
	  const advance = state.advance = () => input[++state.index] || "";
	  const remaining = () => input.slice(state.index + 1);
	  const consume = (value2 = "", num = 0) => {
	    state.consumed += value2;
	    state.index += num;
	  };
	  const append = (token) => {
	    state.output += token.output != null ? token.output : token.value;
	    consume(token.value);
	  };
	  const negate = () => {
	    let count = 1;
	    while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
	      advance();
	      state.start++;
	      count++;
	    }
	    if (count % 2 === 0) {
	      return false;
	    }
	    state.negated = true;
	    state.start++;
	    return true;
	  };
	  const increment = (type) => {
	    state[type]++;
	    stack.push(type);
	  };
	  const decrement = (type) => {
	    state[type]--;
	    stack.pop();
	  };
	  const push = (tok) => {
	    if (prev.type === "globstar") {
	      const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
	      const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
	      if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
	        state.output = state.output.slice(0, -prev.output.length);
	        prev.type = "star";
	        prev.value = "*";
	        prev.output = star;
	        state.output += prev.output;
	      }
	    }
	    if (extglobs.length && tok.type !== "paren") {
	      extglobs[extglobs.length - 1].inner += tok.value;
	    }
	    if (tok.value || tok.output) append(tok);
	    if (prev && prev.type === "text" && tok.type === "text") {
	      prev.value += tok.value;
	      prev.output = (prev.output || "") + tok.value;
	      return;
	    }
	    tok.prev = prev;
	    tokens.push(tok);
	    prev = tok;
	  };
	  const extglobOpen = (type, value2) => {
	    const token = __spreadProps(__spreadValues({}, EXTGLOB_CHARS[value2]), { conditions: 1, inner: "" });
	    token.prev = prev;
	    token.parens = state.parens;
	    token.output = state.output;
	    const output = (opts.capture ? "(" : "") + token.open;
	    increment("parens");
	    push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
	    push({ type: "paren", extglob: true, value: advance(), output });
	    extglobs.push(token);
	  };
	  const extglobClose = (token) => {
	    let output = token.close + (opts.capture ? ")" : "");
	    let rest;
	    if (token.type === "negate") {
	      let extglobStar = star;
	      if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
	        extglobStar = globstar(opts);
	      }
	      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
	        output = token.close = `)$))${extglobStar}`;
	      }
	      if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
	        const expression = parse(rest, __spreadProps(__spreadValues({}, options), { fastpaths: false })).output;
	        output = token.close = `)${expression})${extglobStar})`;
	      }
	      if (token.prev.type === "bos") {
	        state.negatedExtglob = true;
	      }
	    }
	    push({ type: "paren", extglob: true, value, output });
	    decrement("parens");
	  };
	  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
	    let backslashes = false;
	    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
	      if (first === "\\") {
	        backslashes = true;
	        return m;
	      }
	      if (first === "?") {
	        if (esc) {
	          return esc + first + (rest ? QMARK.repeat(rest.length) : "");
	        }
	        if (index === 0) {
	          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
	        }
	        return QMARK.repeat(chars.length);
	      }
	      if (first === ".") {
	        return DOT_LITERAL.repeat(chars.length);
	      }
	      if (first === "*") {
	        if (esc) {
	          return esc + first + (rest ? star : "");
	        }
	        return star;
	      }
	      return esc ? m : `\\${m}`;
	    });
	    if (backslashes === true) {
	      if (opts.unescape === true) {
	        output = output.replace(/\\/g, "");
	      } else {
	        output = output.replace(/\\+/g, (m) => {
	          return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
	        });
	      }
	    }
	    if (output === input && opts.contains === true) {
	      state.output = input;
	      return state;
	    }
	    state.output = utils.wrapOutput(output, state, options);
	    return state;
	  }
	  while (!eos()) {
	    value = advance();
	    if (value === "\0") {
	      continue;
	    }
	    if (value === "\\") {
	      const next = peek();
	      if (next === "/" && opts.bash !== true) {
	        continue;
	      }
	      if (next === "." || next === ";") {
	        continue;
	      }
	      if (!next) {
	        value += "\\";
	        push({ type: "text", value });
	        continue;
	      }
	      const match = /^\\+/.exec(remaining());
	      let slashes = 0;
	      if (match && match[0].length > 2) {
	        slashes = match[0].length;
	        state.index += slashes;
	        if (slashes % 2 !== 0) {
	          value += "\\";
	        }
	      }
	      if (opts.unescape === true) {
	        value = advance();
	      } else {
	        value += advance();
	      }
	      if (state.brackets === 0) {
	        push({ type: "text", value });
	        continue;
	      }
	    }
	    if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
	      if (opts.posix !== false && value === ":") {
	        const inner = prev.value.slice(1);
	        if (inner.includes("[")) {
	          prev.posix = true;
	          if (inner.includes(":")) {
	            const idx = prev.value.lastIndexOf("[");
	            const pre = prev.value.slice(0, idx);
	            const rest2 = prev.value.slice(idx + 2);
	            const posix = POSIX_REGEX_SOURCE[rest2];
	            if (posix) {
	              prev.value = pre + posix;
	              state.backtrack = true;
	              advance();
	              if (!bos.output && tokens.indexOf(prev) === 1) {
	                bos.output = ONE_CHAR;
	              }
	              continue;
	            }
	          }
	        }
	      }
	      if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
	        value = `\\${value}`;
	      }
	      if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
	        value = `\\${value}`;
	      }
	      if (opts.posix === true && value === "!" && prev.value === "[") {
	        value = "^";
	      }
	      prev.value += value;
	      append({ value });
	      continue;
	    }
	    if (state.quotes === 1 && value !== '"') {
	      value = utils.escapeRegex(value);
	      prev.value += value;
	      append({ value });
	      continue;
	    }
	    if (value === '"') {
	      state.quotes = state.quotes === 1 ? 0 : 1;
	      if (opts.keepQuotes === true) {
	        push({ type: "text", value });
	      }
	      continue;
	    }
	    if (value === "(") {
	      increment("parens");
	      push({ type: "paren", value });
	      continue;
	    }
	    if (value === ")") {
	      if (state.parens === 0 && opts.strictBrackets === true) {
	        throw new SyntaxError(syntaxError("opening", "("));
	      }
	      const extglob = extglobs[extglobs.length - 1];
	      if (extglob && state.parens === extglob.parens + 1) {
	        extglobClose(extglobs.pop());
	        continue;
	      }
	      push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
	      decrement("parens");
	      continue;
	    }
	    if (value === "[") {
	      if (opts.nobracket === true || !remaining().includes("]")) {
	        if (opts.nobracket !== true && opts.strictBrackets === true) {
	          throw new SyntaxError(syntaxError("closing", "]"));
	        }
	        value = `\\${value}`;
	      } else {
	        increment("brackets");
	      }
	      push({ type: "bracket", value });
	      continue;
	    }
	    if (value === "]") {
	      if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
	        push({ type: "text", value, output: `\\${value}` });
	        continue;
	      }
	      if (state.brackets === 0) {
	        if (opts.strictBrackets === true) {
	          throw new SyntaxError(syntaxError("opening", "["));
	        }
	        push({ type: "text", value, output: `\\${value}` });
	        continue;
	      }
	      decrement("brackets");
	      const prevValue = prev.value.slice(1);
	      if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
	        value = `/${value}`;
	      }
	      prev.value += value;
	      append({ value });
	      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
	        continue;
	      }
	      const escaped = utils.escapeRegex(prev.value);
	      state.output = state.output.slice(0, -prev.value.length);
	      if (opts.literalBrackets === true) {
	        state.output += escaped;
	        prev.value = escaped;
	        continue;
	      }
	      prev.value = `(${capture}${escaped}|${prev.value})`;
	      state.output += prev.value;
	      continue;
	    }
	    if (value === "{" && opts.nobrace !== true) {
	      increment("braces");
	      const open = {
	        type: "brace",
	        value,
	        output: "(",
	        outputIndex: state.output.length,
	        tokensIndex: state.tokens.length
	      };
	      braces.push(open);
	      push(open);
	      continue;
	    }
	    if (value === "}") {
	      const brace = braces[braces.length - 1];
	      if (opts.nobrace === true || !brace) {
	        push({ type: "text", value, output: value });
	        continue;
	      }
	      let output = ")";
	      if (brace.dots === true) {
	        const arr = tokens.slice();
	        const range = [];
	        for (let i = arr.length - 1; i >= 0; i--) {
	          tokens.pop();
	          if (arr[i].type === "brace") {
	            break;
	          }
	          if (arr[i].type !== "dots") {
	            range.unshift(arr[i].value);
	          }
	        }
	        output = expandRange(range, opts);
	        state.backtrack = true;
	      }
	      if (brace.comma !== true && brace.dots !== true) {
	        const out = state.output.slice(0, brace.outputIndex);
	        const toks = state.tokens.slice(brace.tokensIndex);
	        brace.value = brace.output = "\\{";
	        value = output = "\\}";
	        state.output = out;
	        for (const t of toks) {
	          state.output += t.output || t.value;
	        }
	      }
	      push({ type: "brace", value, output });
	      decrement("braces");
	      braces.pop();
	      continue;
	    }
	    if (value === "|") {
	      if (extglobs.length > 0) {
	        extglobs[extglobs.length - 1].conditions++;
	      }
	      push({ type: "text", value });
	      continue;
	    }
	    if (value === ",") {
	      let output = value;
	      const brace = braces[braces.length - 1];
	      if (brace && stack[stack.length - 1] === "braces") {
	        brace.comma = true;
	        output = "|";
	      }
	      push({ type: "comma", value, output });
	      continue;
	    }
	    if (value === "/") {
	      if (prev.type === "dot" && state.index === state.start + 1) {
	        state.start = state.index + 1;
	        state.consumed = "";
	        state.output = "";
	        tokens.pop();
	        prev = bos;
	        continue;
	      }
	      push({ type: "slash", value, output: SLASH_LITERAL });
	      continue;
	    }
	    if (value === ".") {
	      if (state.braces > 0 && prev.type === "dot") {
	        if (prev.value === ".") prev.output = DOT_LITERAL;
	        const brace = braces[braces.length - 1];
	        prev.type = "dots";
	        prev.output += value;
	        prev.value += value;
	        brace.dots = true;
	        continue;
	      }
	      if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
	        push({ type: "text", value, output: DOT_LITERAL });
	        continue;
	      }
	      push({ type: "dot", value, output: DOT_LITERAL });
	      continue;
	    }
	    if (value === "?") {
	      const isGroup = prev && prev.value === "(";
	      if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
	        extglobOpen("qmark", value);
	        continue;
	      }
	      if (prev && prev.type === "paren") {
	        const next = peek();
	        let output = value;
	        if (next === "<" && !utils.supportsLookbehinds()) {
	          throw new Error("Node.js v10 or higher is required for regex lookbehinds");
	        }
	        if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
	          output = `\\${value}`;
	        }
	        push({ type: "text", value, output });
	        continue;
	      }
	      if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
	        push({ type: "qmark", value, output: QMARK_NO_DOT });
	        continue;
	      }
	      push({ type: "qmark", value, output: QMARK });
	      continue;
	    }
	    if (value === "!") {
	      if (opts.noextglob !== true && peek() === "(") {
	        if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
	          extglobOpen("negate", value);
	          continue;
	        }
	      }
	      if (opts.nonegate !== true && state.index === 0) {
	        negate();
	        continue;
	      }
	    }
	    if (value === "+") {
	      if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
	        extglobOpen("plus", value);
	        continue;
	      }
	      if (prev && prev.value === "(" || opts.regex === false) {
	        push({ type: "plus", value, output: PLUS_LITERAL });
	        continue;
	      }
	      if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
	        push({ type: "plus", value });
	        continue;
	      }
	      push({ type: "plus", value: PLUS_LITERAL });
	      continue;
	    }
	    if (value === "@") {
	      if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
	        push({ type: "at", extglob: true, value, output: "" });
	        continue;
	      }
	      push({ type: "text", value });
	      continue;
	    }
	    if (value !== "*") {
	      if (value === "$" || value === "^") {
	        value = `\\${value}`;
	      }
	      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
	      if (match) {
	        value += match[0];
	        state.index += match[0].length;
	      }
	      push({ type: "text", value });
	      continue;
	    }
	    if (prev && (prev.type === "globstar" || prev.star === true)) {
	      prev.type = "star";
	      prev.star = true;
	      prev.value += value;
	      prev.output = star;
	      state.backtrack = true;
	      state.globstar = true;
	      consume(value);
	      continue;
	    }
	    let rest = remaining();
	    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
	      extglobOpen("star", value);
	      continue;
	    }
	    if (prev.type === "star") {
	      if (opts.noglobstar === true) {
	        consume(value);
	        continue;
	      }
	      const prior = prev.prev;
	      const before = prior.prev;
	      const isStart = prior.type === "slash" || prior.type === "bos";
	      const afterStar = before && (before.type === "star" || before.type === "globstar");
	      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
	        push({ type: "star", value, output: "" });
	        continue;
	      }
	      const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
	      const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
	      if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
	        push({ type: "star", value, output: "" });
	        continue;
	      }
	      while (rest.slice(0, 3) === "/**") {
	        const after = input[state.index + 4];
	        if (after && after !== "/") {
	          break;
	        }
	        rest = rest.slice(3);
	        consume("/**", 3);
	      }
	      if (prior.type === "bos" && eos()) {
	        prev.type = "globstar";
	        prev.value += value;
	        prev.output = globstar(opts);
	        state.output = prev.output;
	        state.globstar = true;
	        consume(value);
	        continue;
	      }
	      if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
	        state.output = state.output.slice(0, -(prior.output + prev.output).length);
	        prior.output = `(?:${prior.output}`;
	        prev.type = "globstar";
	        prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
	        prev.value += value;
	        state.globstar = true;
	        state.output += prior.output + prev.output;
	        consume(value);
	        continue;
	      }
	      if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
	        const end = rest[1] !== void 0 ? "|$" : "";
	        state.output = state.output.slice(0, -(prior.output + prev.output).length);
	        prior.output = `(?:${prior.output}`;
	        prev.type = "globstar";
	        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
	        prev.value += value;
	        state.output += prior.output + prev.output;
	        state.globstar = true;
	        consume(value + advance());
	        push({ type: "slash", value: "/", output: "" });
	        continue;
	      }
	      if (prior.type === "bos" && rest[0] === "/") {
	        prev.type = "globstar";
	        prev.value += value;
	        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
	        state.output = prev.output;
	        state.globstar = true;
	        consume(value + advance());
	        push({ type: "slash", value: "/", output: "" });
	        continue;
	      }
	      state.output = state.output.slice(0, -prev.output.length);
	      prev.type = "globstar";
	      prev.output = globstar(opts);
	      prev.value += value;
	      state.output += prev.output;
	      state.globstar = true;
	      consume(value);
	      continue;
	    }
	    const token = { type: "star", value, output: star };
	    if (opts.bash === true) {
	      token.output = ".*?";
	      if (prev.type === "bos" || prev.type === "slash") {
	        token.output = nodot + token.output;
	      }
	      push(token);
	      continue;
	    }
	    if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
	      token.output = value;
	      push(token);
	      continue;
	    }
	    if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
	      if (prev.type === "dot") {
	        state.output += NO_DOT_SLASH;
	        prev.output += NO_DOT_SLASH;
	      } else if (opts.dot === true) {
	        state.output += NO_DOTS_SLASH;
	        prev.output += NO_DOTS_SLASH;
	      } else {
	        state.output += nodot;
	        prev.output += nodot;
	      }
	      if (peek() !== "*") {
	        state.output += ONE_CHAR;
	        prev.output += ONE_CHAR;
	      }
	    }
	    push(token);
	  }
	  while (state.brackets > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
	    state.output = utils.escapeLast(state.output, "[");
	    decrement("brackets");
	  }
	  while (state.parens > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
	    state.output = utils.escapeLast(state.output, "(");
	    decrement("parens");
	  }
	  while (state.braces > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
	    state.output = utils.escapeLast(state.output, "{");
	    decrement("braces");
	  }
	  if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
	    push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
	  }
	  if (state.backtrack === true) {
	    state.output = "";
	    for (const token of state.tokens) {
	      state.output += token.output != null ? token.output : token.value;
	      if (token.suffix) {
	        state.output += token.suffix;
	      }
	    }
	  }
	  return state;
	};
	parse.fastpaths = (input, options) => {
	  const opts = __spreadValues({}, options);
	  const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
	  const len = input.length;
	  if (len > max) {
	    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
	  }
	  input = REPLACEMENTS[input] || input;
	  const win32 = utils.isWindows(options);
	  const {
	    DOT_LITERAL,
	    SLASH_LITERAL,
	    ONE_CHAR,
	    DOTS_SLASH,
	    NO_DOT,
	    NO_DOTS,
	    NO_DOTS_SLASH,
	    STAR,
	    START_ANCHOR
	  } = constants.globChars(win32);
	  const nodot = opts.dot ? NO_DOTS : NO_DOT;
	  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
	  const capture = opts.capture ? "" : "?:";
	  const state = { negated: false, prefix: "" };
	  let star = opts.bash === true ? ".*?" : STAR;
	  if (opts.capture) {
	    star = `(${star})`;
	  }
	  const globstar = (opts2) => {
	    if (opts2.noglobstar === true) return star;
	    return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
	  };
	  const create = (str) => {
	    switch (str) {
	      case "*":
	        return `${nodot}${ONE_CHAR}${star}`;
	      case ".*":
	        return `${DOT_LITERAL}${ONE_CHAR}${star}`;
	      case "*.*":
	        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
	      case "*/*":
	        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
	      case "**":
	        return nodot + globstar(opts);
	      case "**/*":
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
	      case "**/*.*":
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
	      case "**/.*":
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
	      default: {
	        const match = /^(.*?)\.(\w+)$/.exec(str);
	        if (!match) return;
	        const source2 = create(match[1]);
	        if (!source2) return;
	        return source2 + DOT_LITERAL + match[2];
	      }
	    }
	  };
	  const output = utils.removePrefix(input, state);
	  let source = create(output);
	  if (source && opts.strictSlashes !== true) {
	    source += `${SLASH_LITERAL}?`;
	  }
	  return source;
	};
	parse_1 = parse;
	return parse_1;
}

var picomatch_1;
var hasRequiredPicomatch$1;

function requirePicomatch$1 () {
	if (hasRequiredPicomatch$1) return picomatch_1;
	hasRequiredPicomatch$1 = 1;
	var __defProp = Object.defineProperty;
	var __defProps = Object.defineProperties;
	var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols = Object.getOwnPropertySymbols;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __propIsEnum = Object.prototype.propertyIsEnumerable;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp.call(b, prop))
	      __defNormalProp(a, prop, b[prop]);
	  if (__getOwnPropSymbols)
	    for (var prop of __getOwnPropSymbols(b)) {
	      if (__propIsEnum.call(b, prop))
	        __defNormalProp(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
	const path = require$$0$2;
	const scan = requireScan();
	const parse = requireParse();
	const utils = requireUtils$2();
	const constants = requireConstants$1();
	const isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
	const picomatch = (glob, options, returnState = false) => {
	  if (Array.isArray(glob)) {
	    const fns = glob.map((input) => picomatch(input, options, returnState));
	    const arrayMatcher = (str) => {
	      for (const isMatch of fns) {
	        const state2 = isMatch(str);
	        if (state2) return state2;
	      }
	      return false;
	    };
	    return arrayMatcher;
	  }
	  const isState = isObject(glob) && glob.tokens && glob.input;
	  if (glob === "" || typeof glob !== "string" && !isState) {
	    throw new TypeError("Expected pattern to be a non-empty string");
	  }
	  const opts = options || {};
	  const posix = utils.isWindows(options);
	  const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
	  const state = regex.state;
	  delete regex.state;
	  let isIgnored = () => false;
	  if (opts.ignore) {
	    const ignoreOpts = __spreadProps(__spreadValues({}, options), { ignore: null, onMatch: null, onResult: null });
	    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
	  }
	  const matcher = (input, returnObject = false) => {
	    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
	    const result = { glob, state, regex, posix, input, output, match, isMatch };
	    if (typeof opts.onResult === "function") {
	      opts.onResult(result);
	    }
	    if (isMatch === false) {
	      result.isMatch = false;
	      return returnObject ? result : false;
	    }
	    if (isIgnored(input)) {
	      if (typeof opts.onIgnore === "function") {
	        opts.onIgnore(result);
	      }
	      result.isMatch = false;
	      return returnObject ? result : false;
	    }
	    if (typeof opts.onMatch === "function") {
	      opts.onMatch(result);
	    }
	    return returnObject ? result : true;
	  };
	  if (returnState) {
	    matcher.state = state;
	  }
	  return matcher;
	};
	picomatch.test = (input, regex, options, { glob, posix } = {}) => {
	  if (typeof input !== "string") {
	    throw new TypeError("Expected input to be a string");
	  }
	  if (input === "") {
	    return { isMatch: false, output: "" };
	  }
	  const opts = options || {};
	  const format = opts.format || (posix ? utils.toPosixSlashes : null);
	  let match = input === glob;
	  let output = match && format ? format(input) : input;
	  if (match === false) {
	    output = format ? format(input) : input;
	    match = output === glob;
	  }
	  if (match === false || opts.capture === true) {
	    if (opts.matchBase === true || opts.basename === true) {
	      match = picomatch.matchBase(input, regex, options, posix);
	    } else {
	      match = regex.exec(output);
	    }
	  }
	  return { isMatch: Boolean(match), match, output };
	};
	picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
	  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
	  return regex.test(path.basename(input));
	};
	picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
	picomatch.parse = (pattern, options) => {
	  if (Array.isArray(pattern)) return pattern.map((p) => picomatch.parse(p, options));
	  return parse(pattern, __spreadProps(__spreadValues({}, options), { fastpaths: false }));
	};
	picomatch.scan = (input, options) => scan(input, options);
	picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
	  if (returnOutput === true) {
	    return state.output;
	  }
	  const opts = options || {};
	  const prepend = opts.contains ? "" : "^";
	  const append = opts.contains ? "" : "$";
	  let source = `${prepend}(?:${state.output})${append}`;
	  if (state && state.negated === true) {
	    source = `^(?!${source}).*$`;
	  }
	  const regex = picomatch.toRegex(source, options);
	  if (returnState === true) {
	    regex.state = state;
	  }
	  return regex;
	};
	picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
	  if (!input || typeof input !== "string") {
	    throw new TypeError("Expected a non-empty string");
	  }
	  let parsed = { negated: false, fastpaths: true };
	  if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
	    parsed.output = parse.fastpaths(input, options);
	  }
	  if (!parsed.output) {
	    parsed = parse(input, options);
	  }
	  return picomatch.compileRe(parsed, options, returnOutput, returnState);
	};
	picomatch.toRegex = (source, options) => {
	  try {
	    const opts = options || {};
	    return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
	  } catch (err) {
	    if (options && options.debug === true) throw err;
	    return /$^/;
	  }
	};
	picomatch.constants = constants;
	picomatch_1 = picomatch;
	return picomatch_1;
}

var picomatch;
var hasRequiredPicomatch;

function requirePicomatch () {
	if (hasRequiredPicomatch) return picomatch;
	hasRequiredPicomatch = 1;
	picomatch = requirePicomatch$1();
	return picomatch;
}

var micromatch_1;
var hasRequiredMicromatch;

function requireMicromatch () {
	if (hasRequiredMicromatch) return micromatch_1;
	hasRequiredMicromatch = 1;
	var __defProp = Object.defineProperty;
	var __defProps = Object.defineProperties;
	var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols = Object.getOwnPropertySymbols;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __propIsEnum = Object.prototype.propertyIsEnumerable;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp.call(b, prop))
	      __defNormalProp(a, prop, b[prop]);
	  if (__getOwnPropSymbols)
	    for (var prop of __getOwnPropSymbols(b)) {
	      if (__propIsEnum.call(b, prop))
	        __defNormalProp(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
	const util = require$$0$3;
	const braces = requireBraces();
	const picomatch = requirePicomatch();
	const utils = requireUtils$2();
	const isEmptyString = (v) => v === "" || v === "./";
	const hasBraces = (v) => {
	  const index = v.indexOf("{");
	  return index > -1 && v.indexOf("}", index) > -1;
	};
	const micromatch = (list, patterns, options) => {
	  patterns = [].concat(patterns);
	  list = [].concat(list);
	  let omit = /* @__PURE__ */ new Set();
	  let keep = /* @__PURE__ */ new Set();
	  let items = /* @__PURE__ */ new Set();
	  let negatives = 0;
	  let onResult = (state) => {
	    items.add(state.output);
	    if (options && options.onResult) {
	      options.onResult(state);
	    }
	  };
	  for (let i = 0; i < patterns.length; i++) {
	    let isMatch = picomatch(String(patterns[i]), __spreadProps(__spreadValues({}, options), { onResult }), true);
	    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
	    if (negated) negatives++;
	    for (let item of list) {
	      let matched = isMatch(item, true);
	      let match = negated ? !matched.isMatch : matched.isMatch;
	      if (!match) continue;
	      if (negated) {
	        omit.add(matched.output);
	      } else {
	        omit.delete(matched.output);
	        keep.add(matched.output);
	      }
	    }
	  }
	  let result = negatives === patterns.length ? [...items] : [...keep];
	  let matches = result.filter((item) => !omit.has(item));
	  if (options && matches.length === 0) {
	    if (options.failglob === true) {
	      throw new Error(`No matches found for "${patterns.join(", ")}"`);
	    }
	    if (options.nonull === true || options.nullglob === true) {
	      return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
	    }
	  }
	  return matches;
	};
	micromatch.match = micromatch;
	micromatch.matcher = (pattern, options) => picomatch(pattern, options);
	micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
	micromatch.any = micromatch.isMatch;
	micromatch.not = (list, patterns, options = {}) => {
	  patterns = [].concat(patterns).map(String);
	  let result = /* @__PURE__ */ new Set();
	  let items = [];
	  let onResult = (state) => {
	    if (options.onResult) options.onResult(state);
	    items.push(state.output);
	  };
	  let matches = new Set(micromatch(list, patterns, __spreadProps(__spreadValues({}, options), { onResult })));
	  for (let item of items) {
	    if (!matches.has(item)) {
	      result.add(item);
	    }
	  }
	  return [...result];
	};
	micromatch.contains = (str, pattern, options) => {
	  if (typeof str !== "string") {
	    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
	  }
	  if (Array.isArray(pattern)) {
	    return pattern.some((p) => micromatch.contains(str, p, options));
	  }
	  if (typeof pattern === "string") {
	    if (isEmptyString(str) || isEmptyString(pattern)) {
	      return false;
	    }
	    if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
	      return true;
	    }
	  }
	  return micromatch.isMatch(str, pattern, __spreadProps(__spreadValues({}, options), { contains: true }));
	};
	micromatch.matchKeys = (obj, patterns, options) => {
	  if (!utils.isObject(obj)) {
	    throw new TypeError("Expected the first argument to be an object");
	  }
	  let keys = micromatch(Object.keys(obj), patterns, options);
	  let res = {};
	  for (let key of keys) res[key] = obj[key];
	  return res;
	};
	micromatch.some = (list, patterns, options) => {
	  let items = [].concat(list);
	  for (let pattern of [].concat(patterns)) {
	    let isMatch = picomatch(String(pattern), options);
	    if (items.some((item) => isMatch(item))) {
	      return true;
	    }
	  }
	  return false;
	};
	micromatch.every = (list, patterns, options) => {
	  let items = [].concat(list);
	  for (let pattern of [].concat(patterns)) {
	    let isMatch = picomatch(String(pattern), options);
	    if (!items.every((item) => isMatch(item))) {
	      return false;
	    }
	  }
	  return true;
	};
	micromatch.all = (str, patterns, options) => {
	  if (typeof str !== "string") {
	    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
	  }
	  return [].concat(patterns).every((p) => picomatch(p, options)(str));
	};
	micromatch.capture = (glob, input, options) => {
	  let posix = utils.isWindows(options);
	  let regex = picomatch.makeRe(String(glob), __spreadProps(__spreadValues({}, options), { capture: true }));
	  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
	  if (match) {
	    return match.slice(1).map((v) => v === void 0 ? "" : v);
	  }
	};
	micromatch.makeRe = (...args) => picomatch.makeRe(...args);
	micromatch.scan = (...args) => picomatch.scan(...args);
	micromatch.parse = (patterns, options) => {
	  let res = [];
	  for (let pattern of [].concat(patterns || [])) {
	    for (let str of braces(String(pattern), options)) {
	      res.push(picomatch.parse(str, options));
	    }
	  }
	  return res;
	};
	micromatch.braces = (pattern, options) => {
	  if (typeof pattern !== "string") throw new TypeError("Expected a string");
	  if (options && options.nobrace === true || !hasBraces(pattern)) {
	    return [pattern];
	  }
	  return braces(pattern, options);
	};
	micromatch.braceExpand = (pattern, options) => {
	  if (typeof pattern !== "string") throw new TypeError("Expected a string");
	  return micromatch.braces(pattern, __spreadProps(__spreadValues({}, options), { expand: true }));
	};
	micromatch.hasBraces = hasBraces;
	micromatch_1 = micromatch;
	return micromatch_1;
}

var hasRequiredPattern;

function requirePattern () {
	if (hasRequiredPattern) return pattern;
	hasRequiredPattern = 1;
	Object.defineProperty(pattern, "__esModule", { value: true });
	pattern.isAbsolute = pattern.partitionAbsoluteAndRelative = pattern.removeDuplicateSlashes = pattern.matchAny = pattern.convertPatternsToRe = pattern.makeRe = pattern.getPatternParts = pattern.expandBraceExpansion = pattern.expandPatternsWithBraceExpansion = pattern.isAffectDepthOfReadingPattern = pattern.endsWithSlashGlobStar = pattern.hasGlobStar = pattern.getBaseDirectory = pattern.isPatternRelatedToParentDirectory = pattern.getPatternsOutsideCurrentDirectory = pattern.getPatternsInsideCurrentDirectory = pattern.getPositivePatterns = pattern.getNegativePatterns = pattern.isPositivePattern = pattern.isNegativePattern = pattern.convertToNegativePattern = pattern.convertToPositivePattern = pattern.isDynamicPattern = pattern.isStaticPattern = void 0;
	const path = require$$0$2;
	const globParent = requireGlobParent();
	const micromatch = requireMicromatch();
	const GLOBSTAR = "**";
	const ESCAPE_SYMBOL = "\\";
	const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
	const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
	const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
	const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
	const BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
	const DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
	function isStaticPattern(pattern, options = {}) {
	  return !isDynamicPattern(pattern, options);
	}
	pattern.isStaticPattern = isStaticPattern;
	function isDynamicPattern(pattern, options = {}) {
	  if (pattern === "") {
	    return false;
	  }
	  if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
	    return true;
	  }
	  if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
	    return true;
	  }
	  if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
	    return true;
	  }
	  if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
	    return true;
	  }
	  return false;
	}
	pattern.isDynamicPattern = isDynamicPattern;
	function hasBraceExpansion(pattern) {
	  const openingBraceIndex = pattern.indexOf("{");
	  if (openingBraceIndex === -1) {
	    return false;
	  }
	  const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
	  if (closingBraceIndex === -1) {
	    return false;
	  }
	  const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
	  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
	}
	function convertToPositivePattern(pattern) {
	  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
	}
	pattern.convertToPositivePattern = convertToPositivePattern;
	function convertToNegativePattern(pattern) {
	  return "!" + pattern;
	}
	pattern.convertToNegativePattern = convertToNegativePattern;
	function isNegativePattern(pattern) {
	  return pattern.startsWith("!") && pattern[1] !== "(";
	}
	pattern.isNegativePattern = isNegativePattern;
	function isPositivePattern(pattern) {
	  return !isNegativePattern(pattern);
	}
	pattern.isPositivePattern = isPositivePattern;
	function getNegativePatterns(patterns) {
	  return patterns.filter(isNegativePattern);
	}
	pattern.getNegativePatterns = getNegativePatterns;
	function getPositivePatterns(patterns) {
	  return patterns.filter(isPositivePattern);
	}
	pattern.getPositivePatterns = getPositivePatterns;
	function getPatternsInsideCurrentDirectory(patterns) {
	  return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
	}
	pattern.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
	function getPatternsOutsideCurrentDirectory(patterns) {
	  return patterns.filter(isPatternRelatedToParentDirectory);
	}
	pattern.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
	function isPatternRelatedToParentDirectory(pattern) {
	  return pattern.startsWith("..") || pattern.startsWith("./..");
	}
	pattern.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
	function getBaseDirectory(pattern) {
	  return globParent(pattern, { flipBackslashes: false });
	}
	pattern.getBaseDirectory = getBaseDirectory;
	function hasGlobStar(pattern) {
	  return pattern.includes(GLOBSTAR);
	}
	pattern.hasGlobStar = hasGlobStar;
	function endsWithSlashGlobStar(pattern) {
	  return pattern.endsWith("/" + GLOBSTAR);
	}
	pattern.endsWithSlashGlobStar = endsWithSlashGlobStar;
	function isAffectDepthOfReadingPattern(pattern) {
	  const basename = path.basename(pattern);
	  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
	}
	pattern.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
	function expandPatternsWithBraceExpansion(patterns) {
	  return patterns.reduce((collection, pattern) => {
	    return collection.concat(expandBraceExpansion(pattern));
	  }, []);
	}
	pattern.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
	function expandBraceExpansion(pattern) {
	  const patterns = micromatch.braces(pattern, { expand: true, nodupes: true, keepEscaping: true });
	  patterns.sort((a, b) => a.length - b.length);
	  return patterns.filter((pattern2) => pattern2 !== "");
	}
	pattern.expandBraceExpansion = expandBraceExpansion;
	function getPatternParts(pattern, options) {
	  let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
	  if (parts.length === 0) {
	    parts = [pattern];
	  }
	  if (parts[0].startsWith("/")) {
	    parts[0] = parts[0].slice(1);
	    parts.unshift("");
	  }
	  return parts;
	}
	pattern.getPatternParts = getPatternParts;
	function makeRe(pattern, options) {
	  return micromatch.makeRe(pattern, options);
	}
	pattern.makeRe = makeRe;
	function convertPatternsToRe(patterns, options) {
	  return patterns.map((pattern) => makeRe(pattern, options));
	}
	pattern.convertPatternsToRe = convertPatternsToRe;
	function matchAny(entry, patternsRe) {
	  return patternsRe.some((patternRe) => patternRe.test(entry));
	}
	pattern.matchAny = matchAny;
	function removeDuplicateSlashes(pattern) {
	  return pattern.replace(DOUBLE_SLASH_RE, "/");
	}
	pattern.removeDuplicateSlashes = removeDuplicateSlashes;
	function partitionAbsoluteAndRelative(patterns) {
	  const absolute = [];
	  const relative = [];
	  for (const pattern of patterns) {
	    if (isAbsolute(pattern)) {
	      absolute.push(pattern);
	    } else {
	      relative.push(pattern);
	    }
	  }
	  return [absolute, relative];
	}
	pattern.partitionAbsoluteAndRelative = partitionAbsoluteAndRelative;
	function isAbsolute(pattern) {
	  return path.isAbsolute(pattern);
	}
	pattern.isAbsolute = isAbsolute;
	return pattern;
}

var stream$3 = {};

var merge2_1;
var hasRequiredMerge2;

function requireMerge2 () {
	if (hasRequiredMerge2) return merge2_1;
	hasRequiredMerge2 = 1;
	const Stream = require$$0;
	const PassThrough = Stream.PassThrough;
	const slice = Array.prototype.slice;
	merge2_1 = merge2;
	function merge2() {
	  const streamsQueue = [];
	  const args = slice.call(arguments);
	  let merging = false;
	  let options = args[args.length - 1];
	  if (options && !Array.isArray(options) && options.pipe == null) {
	    args.pop();
	  } else {
	    options = {};
	  }
	  const doEnd = options.end !== false;
	  const doPipeError = options.pipeError === true;
	  if (options.objectMode == null) {
	    options.objectMode = true;
	  }
	  if (options.highWaterMark == null) {
	    options.highWaterMark = 64 * 1024;
	  }
	  const mergedStream = PassThrough(options);
	  function addStream() {
	    for (let i = 0, len = arguments.length; i < len; i++) {
	      streamsQueue.push(pauseStreams(arguments[i], options));
	    }
	    mergeStream();
	    return this;
	  }
	  function mergeStream() {
	    if (merging) {
	      return;
	    }
	    merging = true;
	    let streams = streamsQueue.shift();
	    if (!streams) {
	      process.nextTick(endStream);
	      return;
	    }
	    if (!Array.isArray(streams)) {
	      streams = [streams];
	    }
	    let pipesCount = streams.length + 1;
	    function next() {
	      if (--pipesCount > 0) {
	        return;
	      }
	      merging = false;
	      mergeStream();
	    }
	    function pipe(stream) {
	      function onend() {
	        stream.removeListener("merge2UnpipeEnd", onend);
	        stream.removeListener("end", onend);
	        if (doPipeError) {
	          stream.removeListener("error", onerror);
	        }
	        next();
	      }
	      function onerror(err) {
	        mergedStream.emit("error", err);
	      }
	      if (stream._readableState.endEmitted) {
	        return next();
	      }
	      stream.on("merge2UnpipeEnd", onend);
	      stream.on("end", onend);
	      if (doPipeError) {
	        stream.on("error", onerror);
	      }
	      stream.pipe(mergedStream, { end: false });
	      stream.resume();
	    }
	    for (let i = 0; i < streams.length; i++) {
	      pipe(streams[i]);
	    }
	    next();
	  }
	  function endStream() {
	    merging = false;
	    mergedStream.emit("queueDrain");
	    if (doEnd) {
	      mergedStream.end();
	    }
	  }
	  mergedStream.setMaxListeners(0);
	  mergedStream.add = addStream;
	  mergedStream.on("unpipe", function(stream) {
	    stream.emit("merge2UnpipeEnd");
	  });
	  if (args.length) {
	    addStream.apply(null, args);
	  }
	  return mergedStream;
	}
	function pauseStreams(streams, options) {
	  if (!Array.isArray(streams)) {
	    if (!streams._readableState && streams.pipe) {
	      streams = streams.pipe(PassThrough(options));
	    }
	    if (!streams._readableState || !streams.pause || !streams.pipe) {
	      throw new Error("Only readable stream can be merged.");
	    }
	    streams.pause();
	  } else {
	    for (let i = 0, len = streams.length; i < len; i++) {
	      streams[i] = pauseStreams(streams[i], options);
	    }
	  }
	  return streams;
	}
	return merge2_1;
}

var hasRequiredStream$3;

function requireStream$3 () {
	if (hasRequiredStream$3) return stream$3;
	hasRequiredStream$3 = 1;
	Object.defineProperty(stream$3, "__esModule", { value: true });
	stream$3.merge = void 0;
	const merge2 = requireMerge2();
	function merge(streams) {
	  const mergedStream = merge2(streams);
	  streams.forEach((stream) => {
	    stream.once("error", (error) => mergedStream.emit("error", error));
	  });
	  mergedStream.once("close", () => propagateCloseEventToSources(streams));
	  mergedStream.once("end", () => propagateCloseEventToSources(streams));
	  return mergedStream;
	}
	stream$3.merge = merge;
	function propagateCloseEventToSources(streams) {
	  streams.forEach((stream) => stream.emit("close"));
	}
	return stream$3;
}

var string = {};

var hasRequiredString;

function requireString () {
	if (hasRequiredString) return string;
	hasRequiredString = 1;
	Object.defineProperty(string, "__esModule", { value: true });
	string.isEmpty = string.isString = void 0;
	function isString(input) {
	  return typeof input === "string";
	}
	string.isString = isString;
	function isEmpty(input) {
	  return input === "";
	}
	string.isEmpty = isEmpty;
	return string;
}

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$3;
	hasRequiredUtils$1 = 1;
	Object.defineProperty(utils$3, "__esModule", { value: true });
	utils$3.string = utils$3.stream = utils$3.pattern = utils$3.path = utils$3.fs = utils$3.errno = utils$3.array = void 0;
	const array = requireArray();
	utils$3.array = array;
	const errno = requireErrno();
	utils$3.errno = errno;
	const fs = requireFs$3();
	utils$3.fs = fs;
	const path = requirePath();
	utils$3.path = path;
	const pattern = requirePattern();
	utils$3.pattern = pattern;
	const stream = requireStream$3();
	utils$3.stream = stream;
	const string = requireString();
	utils$3.string = string;
	return utils$3;
}

var hasRequiredTasks;

function requireTasks () {
	if (hasRequiredTasks) return tasks;
	hasRequiredTasks = 1;
	Object.defineProperty(tasks, "__esModule", { value: true });
	tasks.convertPatternGroupToTask = tasks.convertPatternGroupsToTasks = tasks.groupPatternsByBaseDirectory = tasks.getNegativePatternsAsPositive = tasks.getPositivePatterns = tasks.convertPatternsToTasks = tasks.generate = void 0;
	const utils = requireUtils$1();
	function generate(input, settings) {
	  const patterns = processPatterns(input, settings);
	  const ignore = processPatterns(settings.ignore, settings);
	  const positivePatterns = getPositivePatterns(patterns);
	  const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
	  const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
	  const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
	  const staticTasks = convertPatternsToTasks(
	    staticPatterns,
	    negativePatterns,
	    /* dynamic */
	    false
	  );
	  const dynamicTasks = convertPatternsToTasks(
	    dynamicPatterns,
	    negativePatterns,
	    /* dynamic */
	    true
	  );
	  return staticTasks.concat(dynamicTasks);
	}
	tasks.generate = generate;
	function processPatterns(input, settings) {
	  let patterns = input;
	  if (settings.braceExpansion) {
	    patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);
	  }
	  if (settings.baseNameMatch) {
	    patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`);
	  }
	  return patterns.map((pattern) => utils.pattern.removeDuplicateSlashes(pattern));
	}
	function convertPatternsToTasks(positive, negative, dynamic) {
	  const tasks = [];
	  const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
	  const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
	  const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
	  const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
	  tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
	  if ("." in insideCurrentDirectoryGroup) {
	    tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
	  } else {
	    tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
	  }
	  return tasks;
	}
	tasks.convertPatternsToTasks = convertPatternsToTasks;
	function getPositivePatterns(patterns) {
	  return utils.pattern.getPositivePatterns(patterns);
	}
	tasks.getPositivePatterns = getPositivePatterns;
	function getNegativePatternsAsPositive(patterns, ignore) {
	  const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
	  const positive = negative.map(utils.pattern.convertToPositivePattern);
	  return positive;
	}
	tasks.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
	function groupPatternsByBaseDirectory(patterns) {
	  const group = {};
	  return patterns.reduce((collection, pattern) => {
	    const base = utils.pattern.getBaseDirectory(pattern);
	    if (base in collection) {
	      collection[base].push(pattern);
	    } else {
	      collection[base] = [pattern];
	    }
	    return collection;
	  }, group);
	}
	tasks.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
	function convertPatternGroupsToTasks(positive, negative, dynamic) {
	  return Object.keys(positive).map((base) => {
	    return convertPatternGroupToTask(base, positive[base], negative, dynamic);
	  });
	}
	tasks.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
	function convertPatternGroupToTask(base, positive, negative, dynamic) {
	  return {
	    dynamic,
	    positive,
	    negative,
	    base,
	    patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
	  };
	}
	tasks.convertPatternGroupToTask = convertPatternGroupToTask;
	return tasks;
}

var async$5 = {};

var async$4 = {};

var out$3 = {};

var async$3 = {};

var async$2 = {};

var out$2 = {};

var async$1 = {};

var out$1 = {};

var async = {};

var hasRequiredAsync$5;

function requireAsync$5 () {
	if (hasRequiredAsync$5) return async;
	hasRequiredAsync$5 = 1;
	Object.defineProperty(async, "__esModule", { value: true });
	async.read = void 0;
	function read(path, settings, callback) {
	  settings.fs.lstat(path, (lstatError, lstat) => {
	    if (lstatError !== null) {
	      callFailureCallback(callback, lstatError);
	      return;
	    }
	    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
	      callSuccessCallback(callback, lstat);
	      return;
	    }
	    settings.fs.stat(path, (statError, stat) => {
	      if (statError !== null) {
	        if (settings.throwErrorOnBrokenSymbolicLink) {
	          callFailureCallback(callback, statError);
	          return;
	        }
	        callSuccessCallback(callback, lstat);
	        return;
	      }
	      if (settings.markSymbolicLink) {
	        stat.isSymbolicLink = () => true;
	      }
	      callSuccessCallback(callback, stat);
	    });
	  });
	}
	async.read = read;
	function callFailureCallback(callback, error) {
	  callback(error);
	}
	function callSuccessCallback(callback, result) {
	  callback(null, result);
	}
	return async;
}

var sync$5 = {};

var hasRequiredSync$5;

function requireSync$5 () {
	if (hasRequiredSync$5) return sync$5;
	hasRequiredSync$5 = 1;
	Object.defineProperty(sync$5, "__esModule", { value: true });
	sync$5.read = void 0;
	function read(path, settings) {
	  const lstat = settings.fs.lstatSync(path);
	  if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
	    return lstat;
	  }
	  try {
	    const stat = settings.fs.statSync(path);
	    if (settings.markSymbolicLink) {
	      stat.isSymbolicLink = () => true;
	    }
	    return stat;
	  } catch (error) {
	    if (!settings.throwErrorOnBrokenSymbolicLink) {
	      return lstat;
	    }
	    throw error;
	  }
	}
	sync$5.read = read;
	return sync$5;
}

var settings$3 = {};

var fs$2 = {};

var hasRequiredFs$2;

function requireFs$2 () {
	if (hasRequiredFs$2) return fs$2;
	hasRequiredFs$2 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
		const fs = require$$0$1;
		exports.FILE_SYSTEM_ADAPTER = {
		  lstat: fs.lstat,
		  stat: fs.stat,
		  lstatSync: fs.lstatSync,
		  statSync: fs.statSync
		};
		function createFileSystemAdapter(fsMethods) {
		  if (fsMethods === void 0) {
		    return exports.FILE_SYSTEM_ADAPTER;
		  }
		  return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
		}
		exports.createFileSystemAdapter = createFileSystemAdapter; 
	} (fs$2));
	return fs$2;
}

var hasRequiredSettings$3;

function requireSettings$3 () {
	if (hasRequiredSettings$3) return settings$3;
	hasRequiredSettings$3 = 1;
	Object.defineProperty(settings$3, "__esModule", { value: true });
	const fs = requireFs$2();
	class Settings {
	  constructor(_options = {}) {
	    this._options = _options;
	    this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
	    this.fs = fs.createFileSystemAdapter(this._options.fs);
	    this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
	    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
	  }
	  _getValue(option, value) {
	    return option !== null && option !== void 0 ? option : value;
	  }
	}
	settings$3.default = Settings;
	return settings$3;
}

var hasRequiredOut$3;

function requireOut$3 () {
	if (hasRequiredOut$3) return out$1;
	hasRequiredOut$3 = 1;
	Object.defineProperty(out$1, "__esModule", { value: true });
	out$1.statSync = out$1.stat = out$1.Settings = void 0;
	const async = requireAsync$5();
	const sync = requireSync$5();
	const settings_1 = requireSettings$3();
	out$1.Settings = settings_1.default;
	function stat(path, optionsOrSettingsOrCallback, callback) {
	  if (typeof optionsOrSettingsOrCallback === "function") {
	    async.read(path, getSettings(), optionsOrSettingsOrCallback);
	    return;
	  }
	  async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
	}
	out$1.stat = stat;
	function statSync(path, optionsOrSettings) {
	  const settings = getSettings(optionsOrSettings);
	  return sync.read(path, settings);
	}
	out$1.statSync = statSync;
	function getSettings(settingsOrOptions = {}) {
	  if (settingsOrOptions instanceof settings_1.default) {
	    return settingsOrOptions;
	  }
	  return new settings_1.default(settingsOrOptions);
	}
	return out$1;
}

var queueMicrotask_1;
var hasRequiredQueueMicrotask;

function requireQueueMicrotask () {
	if (hasRequiredQueueMicrotask) return queueMicrotask_1;
	hasRequiredQueueMicrotask = 1;
	/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	let promise;
	queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
	  throw err;
	}, 0));
	return queueMicrotask_1;
}

var runParallel_1;
var hasRequiredRunParallel;

function requireRunParallel () {
	if (hasRequiredRunParallel) return runParallel_1;
	hasRequiredRunParallel = 1;
	/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	runParallel_1 = runParallel;
	const queueMicrotask = requireQueueMicrotask();
	function runParallel(tasks, cb) {
	  let results, pending, keys;
	  let isSync = true;
	  if (Array.isArray(tasks)) {
	    results = [];
	    pending = tasks.length;
	  } else {
	    keys = Object.keys(tasks);
	    results = {};
	    pending = keys.length;
	  }
	  function done(err) {
	    function end() {
	      if (cb) cb(err, results);
	      cb = null;
	    }
	    if (isSync) queueMicrotask(end);
	    else end();
	  }
	  function each(i, err, result) {
	    results[i] = result;
	    if (--pending === 0 || err) {
	      done(err);
	    }
	  }
	  if (!pending) {
	    done(null);
	  } else if (keys) {
	    keys.forEach(function(key) {
	      tasks[key](function(err, result) {
	        each(key, err, result);
	      });
	    });
	  } else {
	    tasks.forEach(function(task, i) {
	      task(function(err, result) {
	        each(i, err, result);
	      });
	    });
	  }
	  isSync = false;
	}
	return runParallel_1;
}

var constants = {};

var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	Object.defineProperty(constants, "__esModule", { value: true });
	constants.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
	const NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
	if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
	  throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
	}
	const MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
	const MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
	const SUPPORTED_MAJOR_VERSION = 10;
	const SUPPORTED_MINOR_VERSION = 10;
	const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
	const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
	constants.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
	return constants;
}

var utils = {};

var fs$1 = {};

var hasRequiredFs$1;

function requireFs$1 () {
	if (hasRequiredFs$1) return fs$1;
	hasRequiredFs$1 = 1;
	Object.defineProperty(fs$1, "__esModule", { value: true });
	fs$1.createDirentFromStats = void 0;
	class DirentFromStats {
	  constructor(name, stats) {
	    this.name = name;
	    this.isBlockDevice = stats.isBlockDevice.bind(stats);
	    this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
	    this.isDirectory = stats.isDirectory.bind(stats);
	    this.isFIFO = stats.isFIFO.bind(stats);
	    this.isFile = stats.isFile.bind(stats);
	    this.isSocket = stats.isSocket.bind(stats);
	    this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
	  }
	}
	function createDirentFromStats(name, stats) {
	  return new DirentFromStats(name, stats);
	}
	fs$1.createDirentFromStats = createDirentFromStats;
	return fs$1;
}

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	Object.defineProperty(utils, "__esModule", { value: true });
	utils.fs = void 0;
	const fs = requireFs$1();
	utils.fs = fs;
	return utils;
}

var common$1 = {};

var hasRequiredCommon$1;

function requireCommon$1 () {
	if (hasRequiredCommon$1) return common$1;
	hasRequiredCommon$1 = 1;
	Object.defineProperty(common$1, "__esModule", { value: true });
	common$1.joinPathSegments = void 0;
	function joinPathSegments(a, b, separator) {
	  if (a.endsWith(separator)) {
	    return a + b;
	  }
	  return a + separator + b;
	}
	common$1.joinPathSegments = joinPathSegments;
	return common$1;
}

var hasRequiredAsync$4;

function requireAsync$4 () {
	if (hasRequiredAsync$4) return async$1;
	hasRequiredAsync$4 = 1;
	Object.defineProperty(async$1, "__esModule", { value: true });
	async$1.readdir = async$1.readdirWithFileTypes = async$1.read = void 0;
	const fsStat = requireOut$3();
	const rpl = requireRunParallel();
	const constants_1 = requireConstants();
	const utils = requireUtils();
	const common = requireCommon$1();
	function read(directory, settings, callback) {
	  if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
	    readdirWithFileTypes(directory, settings, callback);
	    return;
	  }
	  readdir(directory, settings, callback);
	}
	async$1.read = read;
	function readdirWithFileTypes(directory, settings, callback) {
	  settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
	    if (readdirError !== null) {
	      callFailureCallback(callback, readdirError);
	      return;
	    }
	    const entries = dirents.map((dirent) => ({
	      dirent,
	      name: dirent.name,
	      path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
	    }));
	    if (!settings.followSymbolicLinks) {
	      callSuccessCallback(callback, entries);
	      return;
	    }
	    const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
	    rpl(tasks, (rplError, rplEntries) => {
	      if (rplError !== null) {
	        callFailureCallback(callback, rplError);
	        return;
	      }
	      callSuccessCallback(callback, rplEntries);
	    });
	  });
	}
	async$1.readdirWithFileTypes = readdirWithFileTypes;
	function makeRplTaskEntry(entry, settings) {
	  return (done) => {
	    if (!entry.dirent.isSymbolicLink()) {
	      done(null, entry);
	      return;
	    }
	    settings.fs.stat(entry.path, (statError, stats) => {
	      if (statError !== null) {
	        if (settings.throwErrorOnBrokenSymbolicLink) {
	          done(statError);
	          return;
	        }
	        done(null, entry);
	        return;
	      }
	      entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
	      done(null, entry);
	    });
	  };
	}
	function readdir(directory, settings, callback) {
	  settings.fs.readdir(directory, (readdirError, names) => {
	    if (readdirError !== null) {
	      callFailureCallback(callback, readdirError);
	      return;
	    }
	    const tasks = names.map((name) => {
	      const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
	      return (done) => {
	        fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
	          if (error !== null) {
	            done(error);
	            return;
	          }
	          const entry = {
	            name,
	            path,
	            dirent: utils.fs.createDirentFromStats(name, stats)
	          };
	          if (settings.stats) {
	            entry.stats = stats;
	          }
	          done(null, entry);
	        });
	      };
	    });
	    rpl(tasks, (rplError, entries) => {
	      if (rplError !== null) {
	        callFailureCallback(callback, rplError);
	        return;
	      }
	      callSuccessCallback(callback, entries);
	    });
	  });
	}
	async$1.readdir = readdir;
	function callFailureCallback(callback, error) {
	  callback(error);
	}
	function callSuccessCallback(callback, result) {
	  callback(null, result);
	}
	return async$1;
}

var sync$4 = {};

var hasRequiredSync$4;

function requireSync$4 () {
	if (hasRequiredSync$4) return sync$4;
	hasRequiredSync$4 = 1;
	Object.defineProperty(sync$4, "__esModule", { value: true });
	sync$4.readdir = sync$4.readdirWithFileTypes = sync$4.read = void 0;
	const fsStat = requireOut$3();
	const constants_1 = requireConstants();
	const utils = requireUtils();
	const common = requireCommon$1();
	function read(directory, settings) {
	  if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
	    return readdirWithFileTypes(directory, settings);
	  }
	  return readdir(directory, settings);
	}
	sync$4.read = read;
	function readdirWithFileTypes(directory, settings) {
	  const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
	  return dirents.map((dirent) => {
	    const entry = {
	      dirent,
	      name: dirent.name,
	      path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
	    };
	    if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
	      try {
	        const stats = settings.fs.statSync(entry.path);
	        entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
	      } catch (error) {
	        if (settings.throwErrorOnBrokenSymbolicLink) {
	          throw error;
	        }
	      }
	    }
	    return entry;
	  });
	}
	sync$4.readdirWithFileTypes = readdirWithFileTypes;
	function readdir(directory, settings) {
	  const names = settings.fs.readdirSync(directory);
	  return names.map((name) => {
	    const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
	    const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
	    const entry = {
	      name,
	      path: entryPath,
	      dirent: utils.fs.createDirentFromStats(name, stats)
	    };
	    if (settings.stats) {
	      entry.stats = stats;
	    }
	    return entry;
	  });
	}
	sync$4.readdir = readdir;
	return sync$4;
}

var settings$2 = {};

var fs = {};

var hasRequiredFs;

function requireFs () {
	if (hasRequiredFs) return fs;
	hasRequiredFs = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
		const fs = require$$0$1;
		exports.FILE_SYSTEM_ADAPTER = {
		  lstat: fs.lstat,
		  stat: fs.stat,
		  lstatSync: fs.lstatSync,
		  statSync: fs.statSync,
		  readdir: fs.readdir,
		  readdirSync: fs.readdirSync
		};
		function createFileSystemAdapter(fsMethods) {
		  if (fsMethods === void 0) {
		    return exports.FILE_SYSTEM_ADAPTER;
		  }
		  return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
		}
		exports.createFileSystemAdapter = createFileSystemAdapter; 
	} (fs));
	return fs;
}

var hasRequiredSettings$2;

function requireSettings$2 () {
	if (hasRequiredSettings$2) return settings$2;
	hasRequiredSettings$2 = 1;
	Object.defineProperty(settings$2, "__esModule", { value: true });
	const path = require$$0$2;
	const fsStat = requireOut$3();
	const fs = requireFs();
	class Settings {
	  constructor(_options = {}) {
	    this._options = _options;
	    this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
	    this.fs = fs.createFileSystemAdapter(this._options.fs);
	    this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
	    this.stats = this._getValue(this._options.stats, false);
	    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
	    this.fsStatSettings = new fsStat.Settings({
	      followSymbolicLink: this.followSymbolicLinks,
	      fs: this.fs,
	      throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
	    });
	  }
	  _getValue(option, value) {
	    return option !== null && option !== void 0 ? option : value;
	  }
	}
	settings$2.default = Settings;
	return settings$2;
}

var hasRequiredOut$2;

function requireOut$2 () {
	if (hasRequiredOut$2) return out$2;
	hasRequiredOut$2 = 1;
	Object.defineProperty(out$2, "__esModule", { value: true });
	out$2.Settings = out$2.scandirSync = out$2.scandir = void 0;
	const async = requireAsync$4();
	const sync = requireSync$4();
	const settings_1 = requireSettings$2();
	out$2.Settings = settings_1.default;
	function scandir(path, optionsOrSettingsOrCallback, callback) {
	  if (typeof optionsOrSettingsOrCallback === "function") {
	    async.read(path, getSettings(), optionsOrSettingsOrCallback);
	    return;
	  }
	  async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
	}
	out$2.scandir = scandir;
	function scandirSync(path, optionsOrSettings) {
	  const settings = getSettings(optionsOrSettings);
	  return sync.read(path, settings);
	}
	out$2.scandirSync = scandirSync;
	function getSettings(settingsOrOptions = {}) {
	  if (settingsOrOptions instanceof settings_1.default) {
	    return settingsOrOptions;
	  }
	  return new settings_1.default(settingsOrOptions);
	}
	return out$2;
}

var queue = {exports: {}};

var reusify_1;
var hasRequiredReusify;

function requireReusify () {
	if (hasRequiredReusify) return reusify_1;
	hasRequiredReusify = 1;
	function reusify(Constructor) {
	  var head = new Constructor();
	  var tail = head;
	  function get() {
	    var current = head;
	    if (current.next) {
	      head = current.next;
	    } else {
	      head = new Constructor();
	      tail = head;
	    }
	    current.next = null;
	    return current;
	  }
	  function release(obj) {
	    tail.next = obj;
	    tail = obj;
	  }
	  return {
	    get,
	    release
	  };
	}
	reusify_1 = reusify;
	return reusify_1;
}

var hasRequiredQueue;

function requireQueue () {
	if (hasRequiredQueue) return queue.exports;
	hasRequiredQueue = 1;
	var reusify = requireReusify();
	function fastqueue(context, worker, _concurrency) {
	  if (typeof context === "function") {
	    _concurrency = worker;
	    worker = context;
	    context = null;
	  }
	  if (!(_concurrency >= 1)) {
	    throw new Error("fastqueue concurrency must be equal to or greater than 1");
	  }
	  var cache = reusify(Task);
	  var queueHead = null;
	  var queueTail = null;
	  var _running = 0;
	  var errorHandler = null;
	  var self = {
	    push,
	    drain: noop,
	    saturated: noop,
	    pause,
	    paused: false,
	    get concurrency() {
	      return _concurrency;
	    },
	    set concurrency(value) {
	      if (!(value >= 1)) {
	        throw new Error("fastqueue concurrency must be equal to or greater than 1");
	      }
	      _concurrency = value;
	      if (self.paused) return;
	      for (; queueHead && _running < _concurrency; ) {
	        _running++;
	        release();
	      }
	    },
	    running,
	    resume,
	    idle,
	    length,
	    getQueue,
	    unshift,
	    empty: noop,
	    kill,
	    killAndDrain,
	    error
	  };
	  return self;
	  function running() {
	    return _running;
	  }
	  function pause() {
	    self.paused = true;
	  }
	  function length() {
	    var current = queueHead;
	    var counter = 0;
	    while (current) {
	      current = current.next;
	      counter++;
	    }
	    return counter;
	  }
	  function getQueue() {
	    var current = queueHead;
	    var tasks = [];
	    while (current) {
	      tasks.push(current.value);
	      current = current.next;
	    }
	    return tasks;
	  }
	  function resume() {
	    if (!self.paused) return;
	    self.paused = false;
	    if (queueHead === null) {
	      _running++;
	      release();
	      return;
	    }
	    for (; queueHead && _running < _concurrency; ) {
	      _running++;
	      release();
	    }
	  }
	  function idle() {
	    return _running === 0 && self.length() === 0;
	  }
	  function push(value, done) {
	    var current = cache.get();
	    current.context = context;
	    current.release = release;
	    current.value = value;
	    current.callback = done || noop;
	    current.errorHandler = errorHandler;
	    if (_running >= _concurrency || self.paused) {
	      if (queueTail) {
	        queueTail.next = current;
	        queueTail = current;
	      } else {
	        queueHead = current;
	        queueTail = current;
	        self.saturated();
	      }
	    } else {
	      _running++;
	      worker.call(context, current.value, current.worked);
	    }
	  }
	  function unshift(value, done) {
	    var current = cache.get();
	    current.context = context;
	    current.release = release;
	    current.value = value;
	    current.callback = done || noop;
	    current.errorHandler = errorHandler;
	    if (_running >= _concurrency || self.paused) {
	      if (queueHead) {
	        current.next = queueHead;
	        queueHead = current;
	      } else {
	        queueHead = current;
	        queueTail = current;
	        self.saturated();
	      }
	    } else {
	      _running++;
	      worker.call(context, current.value, current.worked);
	    }
	  }
	  function release(holder) {
	    if (holder) {
	      cache.release(holder);
	    }
	    var next = queueHead;
	    if (next && _running <= _concurrency) {
	      if (!self.paused) {
	        if (queueTail === queueHead) {
	          queueTail = null;
	        }
	        queueHead = next.next;
	        next.next = null;
	        worker.call(context, next.value, next.worked);
	        if (queueTail === null) {
	          self.empty();
	        }
	      } else {
	        _running--;
	      }
	    } else if (--_running === 0) {
	      self.drain();
	    }
	  }
	  function kill() {
	    queueHead = null;
	    queueTail = null;
	    self.drain = noop;
	  }
	  function killAndDrain() {
	    queueHead = null;
	    queueTail = null;
	    self.drain();
	    self.drain = noop;
	  }
	  function error(handler) {
	    errorHandler = handler;
	  }
	}
	function noop() {
	}
	function Task() {
	  this.value = null;
	  this.callback = noop;
	  this.next = null;
	  this.release = noop;
	  this.context = null;
	  this.errorHandler = null;
	  var self = this;
	  this.worked = function worked(err, result) {
	    var callback = self.callback;
	    var errorHandler = self.errorHandler;
	    var val = self.value;
	    self.value = null;
	    self.callback = noop;
	    if (self.errorHandler) {
	      errorHandler(err, val);
	    }
	    callback.call(self.context, err, result);
	    self.release(self);
	  };
	}
	function queueAsPromised(context, worker, _concurrency) {
	  if (typeof context === "function") {
	    _concurrency = worker;
	    worker = context;
	    context = null;
	  }
	  function asyncWrapper(arg, cb) {
	    worker.call(this, arg).then(function(res) {
	      cb(null, res);
	    }, cb);
	  }
	  var queue = fastqueue(context, asyncWrapper, _concurrency);
	  var pushCb = queue.push;
	  var unshiftCb = queue.unshift;
	  queue.push = push;
	  queue.unshift = unshift;
	  queue.drained = drained;
	  return queue;
	  function push(value) {
	    var p = new Promise(function(resolve, reject) {
	      pushCb(value, function(err, result) {
	        if (err) {
	          reject(err);
	          return;
	        }
	        resolve(result);
	      });
	    });
	    p.catch(noop);
	    return p;
	  }
	  function unshift(value) {
	    var p = new Promise(function(resolve, reject) {
	      unshiftCb(value, function(err, result) {
	        if (err) {
	          reject(err);
	          return;
	        }
	        resolve(result);
	      });
	    });
	    p.catch(noop);
	    return p;
	  }
	  function drained() {
	    var p = new Promise(function(resolve) {
	      process.nextTick(function() {
	        if (queue.idle()) {
	          resolve();
	        } else {
	          var previousDrain = queue.drain;
	          queue.drain = function() {
	            if (typeof previousDrain === "function") previousDrain();
	            resolve();
	            queue.drain = previousDrain;
	          };
	        }
	      });
	    });
	    return p;
	  }
	}
	queue.exports = fastqueue;
	queue.exports.promise = queueAsPromised;
	return queue.exports;
}

var common = {};

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	Object.defineProperty(common, "__esModule", { value: true });
	common.joinPathSegments = common.replacePathSegmentSeparator = common.isAppliedFilter = common.isFatalError = void 0;
	function isFatalError(settings, error) {
	  if (settings.errorFilter === null) {
	    return true;
	  }
	  return !settings.errorFilter(error);
	}
	common.isFatalError = isFatalError;
	function isAppliedFilter(filter, value) {
	  return filter === null || filter(value);
	}
	common.isAppliedFilter = isAppliedFilter;
	function replacePathSegmentSeparator(filepath, separator) {
	  return filepath.split(/[/\\]/).join(separator);
	}
	common.replacePathSegmentSeparator = replacePathSegmentSeparator;
	function joinPathSegments(a, b, separator) {
	  if (a === "") {
	    return b;
	  }
	  if (a.endsWith(separator)) {
	    return a + b;
	  }
	  return a + separator + b;
	}
	common.joinPathSegments = joinPathSegments;
	return common;
}

var reader$1 = {};

var hasRequiredReader$1;

function requireReader$1 () {
	if (hasRequiredReader$1) return reader$1;
	hasRequiredReader$1 = 1;
	Object.defineProperty(reader$1, "__esModule", { value: true });
	const common = requireCommon();
	class Reader {
	  constructor(_root, _settings) {
	    this._root = _root;
	    this._settings = _settings;
	    this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
	  }
	}
	reader$1.default = Reader;
	return reader$1;
}

var hasRequiredAsync$3;

function requireAsync$3 () {
	if (hasRequiredAsync$3) return async$2;
	hasRequiredAsync$3 = 1;
	Object.defineProperty(async$2, "__esModule", { value: true });
	const events_1 = require$$0$5;
	const fsScandir = requireOut$2();
	const fastq = requireQueue();
	const common = requireCommon();
	const reader_1 = requireReader$1();
	class AsyncReader extends reader_1.default {
	  constructor(_root, _settings) {
	    super(_root, _settings);
	    this._settings = _settings;
	    this._scandir = fsScandir.scandir;
	    this._emitter = new events_1.EventEmitter();
	    this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
	    this._isFatalError = false;
	    this._isDestroyed = false;
	    this._queue.drain = () => {
	      if (!this._isFatalError) {
	        this._emitter.emit("end");
	      }
	    };
	  }
	  read() {
	    this._isFatalError = false;
	    this._isDestroyed = false;
	    setImmediate(() => {
	      this._pushToQueue(this._root, this._settings.basePath);
	    });
	    return this._emitter;
	  }
	  get isDestroyed() {
	    return this._isDestroyed;
	  }
	  destroy() {
	    if (this._isDestroyed) {
	      throw new Error("The reader is already destroyed");
	    }
	    this._isDestroyed = true;
	    this._queue.killAndDrain();
	  }
	  onEntry(callback) {
	    this._emitter.on("entry", callback);
	  }
	  onError(callback) {
	    this._emitter.once("error", callback);
	  }
	  onEnd(callback) {
	    this._emitter.once("end", callback);
	  }
	  _pushToQueue(directory, base) {
	    const queueItem = { directory, base };
	    this._queue.push(queueItem, (error) => {
	      if (error !== null) {
	        this._handleError(error);
	      }
	    });
	  }
	  _worker(item, done) {
	    this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
	      if (error !== null) {
	        done(error, void 0);
	        return;
	      }
	      for (const entry of entries) {
	        this._handleEntry(entry, item.base);
	      }
	      done(null, void 0);
	    });
	  }
	  _handleError(error) {
	    if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
	      return;
	    }
	    this._isFatalError = true;
	    this._isDestroyed = true;
	    this._emitter.emit("error", error);
	  }
	  _handleEntry(entry, base) {
	    if (this._isDestroyed || this._isFatalError) {
	      return;
	    }
	    const fullpath = entry.path;
	    if (base !== void 0) {
	      entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
	    }
	    if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
	      this._emitEntry(entry);
	    }
	    if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
	      this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
	    }
	  }
	  _emitEntry(entry) {
	    this._emitter.emit("entry", entry);
	  }
	}
	async$2.default = AsyncReader;
	return async$2;
}

var hasRequiredAsync$2;

function requireAsync$2 () {
	if (hasRequiredAsync$2) return async$3;
	hasRequiredAsync$2 = 1;
	Object.defineProperty(async$3, "__esModule", { value: true });
	const async_1 = requireAsync$3();
	class AsyncProvider {
	  constructor(_root, _settings) {
	    this._root = _root;
	    this._settings = _settings;
	    this._reader = new async_1.default(this._root, this._settings);
	    this._storage = [];
	  }
	  read(callback) {
	    this._reader.onError((error) => {
	      callFailureCallback(callback, error);
	    });
	    this._reader.onEntry((entry) => {
	      this._storage.push(entry);
	    });
	    this._reader.onEnd(() => {
	      callSuccessCallback(callback, this._storage);
	    });
	    this._reader.read();
	  }
	}
	async$3.default = AsyncProvider;
	function callFailureCallback(callback, error) {
	  callback(error);
	}
	function callSuccessCallback(callback, entries) {
	  callback(null, entries);
	}
	return async$3;
}

var stream$2 = {};

var hasRequiredStream$2;

function requireStream$2 () {
	if (hasRequiredStream$2) return stream$2;
	hasRequiredStream$2 = 1;
	Object.defineProperty(stream$2, "__esModule", { value: true });
	const stream_1 = require$$0;
	const async_1 = requireAsync$3();
	class StreamProvider {
	  constructor(_root, _settings) {
	    this._root = _root;
	    this._settings = _settings;
	    this._reader = new async_1.default(this._root, this._settings);
	    this._stream = new stream_1.Readable({
	      objectMode: true,
	      read: () => {
	      },
	      destroy: () => {
	        if (!this._reader.isDestroyed) {
	          this._reader.destroy();
	        }
	      }
	    });
	  }
	  read() {
	    this._reader.onError((error) => {
	      this._stream.emit("error", error);
	    });
	    this._reader.onEntry((entry) => {
	      this._stream.push(entry);
	    });
	    this._reader.onEnd(() => {
	      this._stream.push(null);
	    });
	    this._reader.read();
	    return this._stream;
	  }
	}
	stream$2.default = StreamProvider;
	return stream$2;
}

var sync$3 = {};

var sync$2 = {};

var hasRequiredSync$3;

function requireSync$3 () {
	if (hasRequiredSync$3) return sync$2;
	hasRequiredSync$3 = 1;
	Object.defineProperty(sync$2, "__esModule", { value: true });
	const fsScandir = requireOut$2();
	const common = requireCommon();
	const reader_1 = requireReader$1();
	class SyncReader extends reader_1.default {
	  constructor() {
	    super(...arguments);
	    this._scandir = fsScandir.scandirSync;
	    this._storage = [];
	    this._queue = /* @__PURE__ */ new Set();
	  }
	  read() {
	    this._pushToQueue(this._root, this._settings.basePath);
	    this._handleQueue();
	    return this._storage;
	  }
	  _pushToQueue(directory, base) {
	    this._queue.add({ directory, base });
	  }
	  _handleQueue() {
	    for (const item of this._queue.values()) {
	      this._handleDirectory(item.directory, item.base);
	    }
	  }
	  _handleDirectory(directory, base) {
	    try {
	      const entries = this._scandir(directory, this._settings.fsScandirSettings);
	      for (const entry of entries) {
	        this._handleEntry(entry, base);
	      }
	    } catch (error) {
	      this._handleError(error);
	    }
	  }
	  _handleError(error) {
	    if (!common.isFatalError(this._settings, error)) {
	      return;
	    }
	    throw error;
	  }
	  _handleEntry(entry, base) {
	    const fullpath = entry.path;
	    if (base !== void 0) {
	      entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
	    }
	    if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
	      this._pushToStorage(entry);
	    }
	    if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
	      this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
	    }
	  }
	  _pushToStorage(entry) {
	    this._storage.push(entry);
	  }
	}
	sync$2.default = SyncReader;
	return sync$2;
}

var hasRequiredSync$2;

function requireSync$2 () {
	if (hasRequiredSync$2) return sync$3;
	hasRequiredSync$2 = 1;
	Object.defineProperty(sync$3, "__esModule", { value: true });
	const sync_1 = requireSync$3();
	class SyncProvider {
	  constructor(_root, _settings) {
	    this._root = _root;
	    this._settings = _settings;
	    this._reader = new sync_1.default(this._root, this._settings);
	  }
	  read() {
	    return this._reader.read();
	  }
	}
	sync$3.default = SyncProvider;
	return sync$3;
}

var settings$1 = {};

var hasRequiredSettings$1;

function requireSettings$1 () {
	if (hasRequiredSettings$1) return settings$1;
	hasRequiredSettings$1 = 1;
	Object.defineProperty(settings$1, "__esModule", { value: true });
	const path = require$$0$2;
	const fsScandir = requireOut$2();
	class Settings {
	  constructor(_options = {}) {
	    this._options = _options;
	    this.basePath = this._getValue(this._options.basePath, void 0);
	    this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
	    this.deepFilter = this._getValue(this._options.deepFilter, null);
	    this.entryFilter = this._getValue(this._options.entryFilter, null);
	    this.errorFilter = this._getValue(this._options.errorFilter, null);
	    this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
	    this.fsScandirSettings = new fsScandir.Settings({
	      followSymbolicLinks: this._options.followSymbolicLinks,
	      fs: this._options.fs,
	      pathSegmentSeparator: this._options.pathSegmentSeparator,
	      stats: this._options.stats,
	      throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
	    });
	  }
	  _getValue(option, value) {
	    return option !== null && option !== void 0 ? option : value;
	  }
	}
	settings$1.default = Settings;
	return settings$1;
}

var hasRequiredOut$1;

function requireOut$1 () {
	if (hasRequiredOut$1) return out$3;
	hasRequiredOut$1 = 1;
	Object.defineProperty(out$3, "__esModule", { value: true });
	out$3.Settings = out$3.walkStream = out$3.walkSync = out$3.walk = void 0;
	const async_1 = requireAsync$2();
	const stream_1 = requireStream$2();
	const sync_1 = requireSync$2();
	const settings_1 = requireSettings$1();
	out$3.Settings = settings_1.default;
	function walk(directory, optionsOrSettingsOrCallback, callback) {
	  if (typeof optionsOrSettingsOrCallback === "function") {
	    new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
	    return;
	  }
	  new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
	}
	out$3.walk = walk;
	function walkSync(directory, optionsOrSettings) {
	  const settings = getSettings(optionsOrSettings);
	  const provider = new sync_1.default(directory, settings);
	  return provider.read();
	}
	out$3.walkSync = walkSync;
	function walkStream(directory, optionsOrSettings) {
	  const settings = getSettings(optionsOrSettings);
	  const provider = new stream_1.default(directory, settings);
	  return provider.read();
	}
	out$3.walkStream = walkStream;
	function getSettings(settingsOrOptions = {}) {
	  if (settingsOrOptions instanceof settings_1.default) {
	    return settingsOrOptions;
	  }
	  return new settings_1.default(settingsOrOptions);
	}
	return out$3;
}

var reader = {};

var hasRequiredReader;

function requireReader () {
	if (hasRequiredReader) return reader;
	hasRequiredReader = 1;
	Object.defineProperty(reader, "__esModule", { value: true });
	const path = require$$0$2;
	const fsStat = requireOut$3();
	const utils = requireUtils$1();
	class Reader {
	  constructor(_settings) {
	    this._settings = _settings;
	    this._fsStatSettings = new fsStat.Settings({
	      followSymbolicLink: this._settings.followSymbolicLinks,
	      fs: this._settings.fs,
	      throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
	    });
	  }
	  _getFullEntryPath(filepath) {
	    return path.resolve(this._settings.cwd, filepath);
	  }
	  _makeEntry(stats, pattern) {
	    const entry = {
	      name: pattern,
	      path: pattern,
	      dirent: utils.fs.createDirentFromStats(pattern, stats)
	    };
	    if (this._settings.stats) {
	      entry.stats = stats;
	    }
	    return entry;
	  }
	  _isFatalError(error) {
	    return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
	  }
	}
	reader.default = Reader;
	return reader;
}

var stream$1 = {};

var hasRequiredStream$1;

function requireStream$1 () {
	if (hasRequiredStream$1) return stream$1;
	hasRequiredStream$1 = 1;
	Object.defineProperty(stream$1, "__esModule", { value: true });
	const stream_1 = require$$0;
	const fsStat = requireOut$3();
	const fsWalk = requireOut$1();
	const reader_1 = requireReader();
	class ReaderStream extends reader_1.default {
	  constructor() {
	    super(...arguments);
	    this._walkStream = fsWalk.walkStream;
	    this._stat = fsStat.stat;
	  }
	  dynamic(root, options) {
	    return this._walkStream(root, options);
	  }
	  static(patterns, options) {
	    const filepaths = patterns.map(this._getFullEntryPath, this);
	    const stream = new stream_1.PassThrough({ objectMode: true });
	    stream._write = (index, _enc, done) => {
	      return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
	        if (entry !== null && options.entryFilter(entry)) {
	          stream.push(entry);
	        }
	        if (index === filepaths.length - 1) {
	          stream.end();
	        }
	        done();
	      }).catch(done);
	    };
	    for (let i = 0; i < filepaths.length; i++) {
	      stream.write(i);
	    }
	    return stream;
	  }
	  _getEntry(filepath, pattern, options) {
	    return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
	      if (options.errorFilter(error)) {
	        return null;
	      }
	      throw error;
	    });
	  }
	  _getStat(filepath) {
	    return new Promise((resolve, reject) => {
	      this._stat(filepath, this._fsStatSettings, (error, stats) => {
	        return error === null ? resolve(stats) : reject(error);
	      });
	    });
	  }
	}
	stream$1.default = ReaderStream;
	return stream$1;
}

var hasRequiredAsync$1;

function requireAsync$1 () {
	if (hasRequiredAsync$1) return async$4;
	hasRequiredAsync$1 = 1;
	Object.defineProperty(async$4, "__esModule", { value: true });
	const fsWalk = requireOut$1();
	const reader_1 = requireReader();
	const stream_1 = requireStream$1();
	class ReaderAsync extends reader_1.default {
	  constructor() {
	    super(...arguments);
	    this._walkAsync = fsWalk.walk;
	    this._readerStream = new stream_1.default(this._settings);
	  }
	  dynamic(root, options) {
	    return new Promise((resolve, reject) => {
	      this._walkAsync(root, options, (error, entries) => {
	        if (error === null) {
	          resolve(entries);
	        } else {
	          reject(error);
	        }
	      });
	    });
	  }
	  async static(patterns, options) {
	    const entries = [];
	    const stream = this._readerStream.static(patterns, options);
	    return new Promise((resolve, reject) => {
	      stream.once("error", reject);
	      stream.on("data", (entry) => entries.push(entry));
	      stream.once("end", () => resolve(entries));
	    });
	  }
	}
	async$4.default = ReaderAsync;
	return async$4;
}

var provider = {};

var deep = {};

var partial = {};

var matcher = {};

var hasRequiredMatcher;

function requireMatcher () {
	if (hasRequiredMatcher) return matcher;
	hasRequiredMatcher = 1;
	Object.defineProperty(matcher, "__esModule", { value: true });
	const utils = requireUtils$1();
	class Matcher {
	  constructor(_patterns, _settings, _micromatchOptions) {
	    this._patterns = _patterns;
	    this._settings = _settings;
	    this._micromatchOptions = _micromatchOptions;
	    this._storage = [];
	    this._fillStorage();
	  }
	  _fillStorage() {
	    for (const pattern of this._patterns) {
	      const segments = this._getPatternSegments(pattern);
	      const sections = this._splitSegmentsIntoSections(segments);
	      this._storage.push({
	        complete: sections.length <= 1,
	        pattern,
	        segments,
	        sections
	      });
	    }
	  }
	  _getPatternSegments(pattern) {
	    const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
	    return parts.map((part) => {
	      const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
	      if (!dynamic) {
	        return {
	          dynamic: false,
	          pattern: part
	        };
	      }
	      return {
	        dynamic: true,
	        pattern: part,
	        patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
	      };
	    });
	  }
	  _splitSegmentsIntoSections(segments) {
	    return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
	  }
	}
	matcher.default = Matcher;
	return matcher;
}

var hasRequiredPartial;

function requirePartial () {
	if (hasRequiredPartial) return partial;
	hasRequiredPartial = 1;
	Object.defineProperty(partial, "__esModule", { value: true });
	const matcher_1 = requireMatcher();
	class PartialMatcher extends matcher_1.default {
	  match(filepath) {
	    const parts = filepath.split("/");
	    const levels = parts.length;
	    const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
	    for (const pattern of patterns) {
	      const section = pattern.sections[0];
	      if (!pattern.complete && levels > section.length) {
	        return true;
	      }
	      const match = parts.every((part, index) => {
	        const segment = pattern.segments[index];
	        if (segment.dynamic && segment.patternRe.test(part)) {
	          return true;
	        }
	        if (!segment.dynamic && segment.pattern === part) {
	          return true;
	        }
	        return false;
	      });
	      if (match) {
	        return true;
	      }
	    }
	    return false;
	  }
	}
	partial.default = PartialMatcher;
	return partial;
}

var hasRequiredDeep;

function requireDeep () {
	if (hasRequiredDeep) return deep;
	hasRequiredDeep = 1;
	Object.defineProperty(deep, "__esModule", { value: true });
	const utils = requireUtils$1();
	const partial_1 = requirePartial();
	class DeepFilter {
	  constructor(_settings, _micromatchOptions) {
	    this._settings = _settings;
	    this._micromatchOptions = _micromatchOptions;
	  }
	  getFilter(basePath, positive, negative) {
	    const matcher = this._getMatcher(positive);
	    const negativeRe = this._getNegativePatternsRe(negative);
	    return (entry) => this._filter(basePath, entry, matcher, negativeRe);
	  }
	  _getMatcher(patterns) {
	    return new partial_1.default(patterns, this._settings, this._micromatchOptions);
	  }
	  _getNegativePatternsRe(patterns) {
	    const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
	    return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
	  }
	  _filter(basePath, entry, matcher, negativeRe) {
	    if (this._isSkippedByDeep(basePath, entry.path)) {
	      return false;
	    }
	    if (this._isSkippedSymbolicLink(entry)) {
	      return false;
	    }
	    const filepath = utils.path.removeLeadingDotSegment(entry.path);
	    if (this._isSkippedByPositivePatterns(filepath, matcher)) {
	      return false;
	    }
	    return this._isSkippedByNegativePatterns(filepath, negativeRe);
	  }
	  _isSkippedByDeep(basePath, entryPath) {
	    if (this._settings.deep === Infinity) {
	      return false;
	    }
	    return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
	  }
	  _getEntryLevel(basePath, entryPath) {
	    const entryPathDepth = entryPath.split("/").length;
	    if (basePath === "") {
	      return entryPathDepth;
	    }
	    const basePathDepth = basePath.split("/").length;
	    return entryPathDepth - basePathDepth;
	  }
	  _isSkippedSymbolicLink(entry) {
	    return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
	  }
	  _isSkippedByPositivePatterns(entryPath, matcher) {
	    return !this._settings.baseNameMatch && !matcher.match(entryPath);
	  }
	  _isSkippedByNegativePatterns(entryPath, patternsRe) {
	    return !utils.pattern.matchAny(entryPath, patternsRe);
	  }
	}
	deep.default = DeepFilter;
	return deep;
}

var entry$1 = {};

var hasRequiredEntry$1;

function requireEntry$1 () {
	if (hasRequiredEntry$1) return entry$1;
	hasRequiredEntry$1 = 1;
	Object.defineProperty(entry$1, "__esModule", { value: true });
	const utils = requireUtils$1();
	class EntryFilter {
	  constructor(_settings, _micromatchOptions) {
	    this._settings = _settings;
	    this._micromatchOptions = _micromatchOptions;
	    this.index = /* @__PURE__ */ new Map();
	  }
	  getFilter(positive, negative) {
	    const [absoluteNegative, relativeNegative] = utils.pattern.partitionAbsoluteAndRelative(negative);
	    const patterns = {
	      positive: {
	        all: utils.pattern.convertPatternsToRe(positive, this._micromatchOptions)
	      },
	      negative: {
	        absolute: utils.pattern.convertPatternsToRe(absoluteNegative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true })),
	        relative: utils.pattern.convertPatternsToRe(relativeNegative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }))
	      }
	    };
	    return (entry) => this._filter(entry, patterns);
	  }
	  _filter(entry, patterns) {
	    const filepath = utils.path.removeLeadingDotSegment(entry.path);
	    if (this._settings.unique && this._isDuplicateEntry(filepath)) {
	      return false;
	    }
	    if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
	      return false;
	    }
	    const isMatched = this._isMatchToPatternsSet(filepath, patterns, entry.dirent.isDirectory());
	    if (this._settings.unique && isMatched) {
	      this._createIndexRecord(filepath);
	    }
	    return isMatched;
	  }
	  _isDuplicateEntry(filepath) {
	    return this.index.has(filepath);
	  }
	  _createIndexRecord(filepath) {
	    this.index.set(filepath, void 0);
	  }
	  _onlyFileFilter(entry) {
	    return this._settings.onlyFiles && !entry.dirent.isFile();
	  }
	  _onlyDirectoryFilter(entry) {
	    return this._settings.onlyDirectories && !entry.dirent.isDirectory();
	  }
	  _isMatchToPatternsSet(filepath, patterns, isDirectory) {
	    const isMatched = this._isMatchToPatterns(filepath, patterns.positive.all, isDirectory);
	    if (!isMatched) {
	      return false;
	    }
	    const isMatchedByRelativeNegative = this._isMatchToPatterns(filepath, patterns.negative.relative, isDirectory);
	    if (isMatchedByRelativeNegative) {
	      return false;
	    }
	    const isMatchedByAbsoluteNegative = this._isMatchToAbsoluteNegative(filepath, patterns.negative.absolute, isDirectory);
	    if (isMatchedByAbsoluteNegative) {
	      return false;
	    }
	    return true;
	  }
	  _isMatchToAbsoluteNegative(filepath, patternsRe, isDirectory) {
	    if (patternsRe.length === 0) {
	      return false;
	    }
	    const fullpath = utils.path.makeAbsolute(this._settings.cwd, filepath);
	    return this._isMatchToPatterns(fullpath, patternsRe, isDirectory);
	  }
	  _isMatchToPatterns(filepath, patternsRe, isDirectory) {
	    if (patternsRe.length === 0) {
	      return false;
	    }
	    const isMatched = utils.pattern.matchAny(filepath, patternsRe);
	    if (!isMatched && isDirectory) {
	      return utils.pattern.matchAny(filepath + "/", patternsRe);
	    }
	    return isMatched;
	  }
	}
	entry$1.default = EntryFilter;
	return entry$1;
}

var error = {};

var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	Object.defineProperty(error, "__esModule", { value: true });
	const utils = requireUtils$1();
	class ErrorFilter {
	  constructor(_settings) {
	    this._settings = _settings;
	  }
	  getFilter() {
	    return (error) => this._isNonFatalError(error);
	  }
	  _isNonFatalError(error) {
	    return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
	  }
	}
	error.default = ErrorFilter;
	return error;
}

var entry = {};

var hasRequiredEntry;

function requireEntry () {
	if (hasRequiredEntry) return entry;
	hasRequiredEntry = 1;
	Object.defineProperty(entry, "__esModule", { value: true });
	const utils = requireUtils$1();
	class EntryTransformer {
	  constructor(_settings) {
	    this._settings = _settings;
	  }
	  getTransformer() {
	    return (entry) => this._transform(entry);
	  }
	  _transform(entry) {
	    let filepath = entry.path;
	    if (this._settings.absolute) {
	      filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
	      filepath = utils.path.unixify(filepath);
	    }
	    if (this._settings.markDirectories && entry.dirent.isDirectory()) {
	      filepath += "/";
	    }
	    if (!this._settings.objectMode) {
	      return filepath;
	    }
	    return Object.assign(Object.assign({}, entry), { path: filepath });
	  }
	}
	entry.default = EntryTransformer;
	return entry;
}

var hasRequiredProvider;

function requireProvider () {
	if (hasRequiredProvider) return provider;
	hasRequiredProvider = 1;
	Object.defineProperty(provider, "__esModule", { value: true });
	const path = require$$0$2;
	const deep_1 = requireDeep();
	const entry_1 = requireEntry$1();
	const error_1 = requireError();
	const entry_2 = requireEntry();
	class Provider {
	  constructor(_settings) {
	    this._settings = _settings;
	    this.errorFilter = new error_1.default(this._settings);
	    this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
	    this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
	    this.entryTransformer = new entry_2.default(this._settings);
	  }
	  _getRootDirectory(task) {
	    return path.resolve(this._settings.cwd, task.base);
	  }
	  _getReaderOptions(task) {
	    const basePath = task.base === "." ? "" : task.base;
	    return {
	      basePath,
	      pathSegmentSeparator: "/",
	      concurrency: this._settings.concurrency,
	      deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
	      entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
	      errorFilter: this.errorFilter.getFilter(),
	      followSymbolicLinks: this._settings.followSymbolicLinks,
	      fs: this._settings.fs,
	      stats: this._settings.stats,
	      throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
	      transform: this.entryTransformer.getTransformer()
	    };
	  }
	  _getMicromatchOptions() {
	    return {
	      dot: this._settings.dot,
	      matchBase: this._settings.baseNameMatch,
	      nobrace: !this._settings.braceExpansion,
	      nocase: !this._settings.caseSensitiveMatch,
	      noext: !this._settings.extglob,
	      noglobstar: !this._settings.globstar,
	      posix: true,
	      strictSlashes: false
	    };
	  }
	}
	provider.default = Provider;
	return provider;
}

var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async$5;
	hasRequiredAsync = 1;
	Object.defineProperty(async$5, "__esModule", { value: true });
	const async_1 = requireAsync$1();
	const provider_1 = requireProvider();
	class ProviderAsync extends provider_1.default {
	  constructor() {
	    super(...arguments);
	    this._reader = new async_1.default(this._settings);
	  }
	  async read(task) {
	    const root = this._getRootDirectory(task);
	    const options = this._getReaderOptions(task);
	    const entries = await this.api(root, task, options);
	    return entries.map((entry) => options.transform(entry));
	  }
	  api(root, task, options) {
	    if (task.dynamic) {
	      return this._reader.dynamic(root, options);
	    }
	    return this._reader.static(task.patterns, options);
	  }
	}
	async$5.default = ProviderAsync;
	return async$5;
}

var stream = {};

var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream;
	hasRequiredStream = 1;
	Object.defineProperty(stream, "__esModule", { value: true });
	const stream_1 = require$$0;
	const stream_2 = requireStream$1();
	const provider_1 = requireProvider();
	class ProviderStream extends provider_1.default {
	  constructor() {
	    super(...arguments);
	    this._reader = new stream_2.default(this._settings);
	  }
	  read(task) {
	    const root = this._getRootDirectory(task);
	    const options = this._getReaderOptions(task);
	    const source = this.api(root, task, options);
	    const destination = new stream_1.Readable({ objectMode: true, read: () => {
	    } });
	    source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
	    destination.once("close", () => source.destroy());
	    return destination;
	  }
	  api(root, task, options) {
	    if (task.dynamic) {
	      return this._reader.dynamic(root, options);
	    }
	    return this._reader.static(task.patterns, options);
	  }
	}
	stream.default = ProviderStream;
	return stream;
}

var sync$1 = {};

var sync = {};

var hasRequiredSync$1;

function requireSync$1 () {
	if (hasRequiredSync$1) return sync;
	hasRequiredSync$1 = 1;
	Object.defineProperty(sync, "__esModule", { value: true });
	const fsStat = requireOut$3();
	const fsWalk = requireOut$1();
	const reader_1 = requireReader();
	class ReaderSync extends reader_1.default {
	  constructor() {
	    super(...arguments);
	    this._walkSync = fsWalk.walkSync;
	    this._statSync = fsStat.statSync;
	  }
	  dynamic(root, options) {
	    return this._walkSync(root, options);
	  }
	  static(patterns, options) {
	    const entries = [];
	    for (const pattern of patterns) {
	      const filepath = this._getFullEntryPath(pattern);
	      const entry = this._getEntry(filepath, pattern, options);
	      if (entry === null || !options.entryFilter(entry)) {
	        continue;
	      }
	      entries.push(entry);
	    }
	    return entries;
	  }
	  _getEntry(filepath, pattern, options) {
	    try {
	      const stats = this._getStat(filepath);
	      return this._makeEntry(stats, pattern);
	    } catch (error) {
	      if (options.errorFilter(error)) {
	        return null;
	      }
	      throw error;
	    }
	  }
	  _getStat(filepath) {
	    return this._statSync(filepath, this._fsStatSettings);
	  }
	}
	sync.default = ReaderSync;
	return sync;
}

var hasRequiredSync;

function requireSync () {
	if (hasRequiredSync) return sync$1;
	hasRequiredSync = 1;
	Object.defineProperty(sync$1, "__esModule", { value: true });
	const sync_1 = requireSync$1();
	const provider_1 = requireProvider();
	class ProviderSync extends provider_1.default {
	  constructor() {
	    super(...arguments);
	    this._reader = new sync_1.default(this._settings);
	  }
	  read(task) {
	    const root = this._getRootDirectory(task);
	    const options = this._getReaderOptions(task);
	    const entries = this.api(root, task, options);
	    return entries.map(options.transform);
	  }
	  api(root, task, options) {
	    if (task.dynamic) {
	      return this._reader.dynamic(root, options);
	    }
	    return this._reader.static(task.patterns, options);
	  }
	}
	sync$1.default = ProviderSync;
	return sync$1;
}

var settings = {};

var hasRequiredSettings;

function requireSettings () {
	if (hasRequiredSettings) return settings;
	hasRequiredSettings = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
		const fs = require$$0$1;
		const os = require$$0$4;
		const CPU_COUNT = Math.max(os.cpus().length, 1);
		exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
		  lstat: fs.lstat,
		  lstatSync: fs.lstatSync,
		  stat: fs.stat,
		  statSync: fs.statSync,
		  readdir: fs.readdir,
		  readdirSync: fs.readdirSync
		};
		class Settings {
		  constructor(_options = {}) {
		    this._options = _options;
		    this.absolute = this._getValue(this._options.absolute, false);
		    this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
		    this.braceExpansion = this._getValue(this._options.braceExpansion, true);
		    this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
		    this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
		    this.cwd = this._getValue(this._options.cwd, process.cwd());
		    this.deep = this._getValue(this._options.deep, Infinity);
		    this.dot = this._getValue(this._options.dot, false);
		    this.extglob = this._getValue(this._options.extglob, true);
		    this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
		    this.fs = this._getFileSystemMethods(this._options.fs);
		    this.globstar = this._getValue(this._options.globstar, true);
		    this.ignore = this._getValue(this._options.ignore, []);
		    this.markDirectories = this._getValue(this._options.markDirectories, false);
		    this.objectMode = this._getValue(this._options.objectMode, false);
		    this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
		    this.onlyFiles = this._getValue(this._options.onlyFiles, true);
		    this.stats = this._getValue(this._options.stats, false);
		    this.suppressErrors = this._getValue(this._options.suppressErrors, false);
		    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
		    this.unique = this._getValue(this._options.unique, true);
		    if (this.onlyDirectories) {
		      this.onlyFiles = false;
		    }
		    if (this.stats) {
		      this.objectMode = true;
		    }
		    this.ignore = [].concat(this.ignore);
		  }
		  _getValue(option, value) {
		    return option === void 0 ? value : option;
		  }
		  _getFileSystemMethods(methods = {}) {
		    return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
		  }
		}
		exports.default = Settings; 
	} (settings));
	return settings;
}

var out;
var hasRequiredOut;

function requireOut () {
	if (hasRequiredOut) return out;
	hasRequiredOut = 1;
	const taskManager = requireTasks();
	const async_1 = requireAsync();
	const stream_1 = requireStream();
	const sync_1 = requireSync();
	const settings_1 = requireSettings();
	const utils = requireUtils$1();
	async function FastGlob(source, options) {
	  assertPatternsInput(source);
	  const works = getWorks(source, async_1.default, options);
	  const result = await Promise.all(works);
	  return utils.array.flatten(result);
	}
	(function(FastGlob2) {
	  FastGlob2.glob = FastGlob2;
	  FastGlob2.globSync = sync;
	  FastGlob2.globStream = stream;
	  FastGlob2.async = FastGlob2;
	  function sync(source, options) {
	    assertPatternsInput(source);
	    const works = getWorks(source, sync_1.default, options);
	    return utils.array.flatten(works);
	  }
	  FastGlob2.sync = sync;
	  function stream(source, options) {
	    assertPatternsInput(source);
	    const works = getWorks(source, stream_1.default, options);
	    return utils.stream.merge(works);
	  }
	  FastGlob2.stream = stream;
	  function generateTasks(source, options) {
	    assertPatternsInput(source);
	    const patterns = [].concat(source);
	    const settings = new settings_1.default(options);
	    return taskManager.generate(patterns, settings);
	  }
	  FastGlob2.generateTasks = generateTasks;
	  function isDynamicPattern(source, options) {
	    assertPatternsInput(source);
	    const settings = new settings_1.default(options);
	    return utils.pattern.isDynamicPattern(source, settings);
	  }
	  FastGlob2.isDynamicPattern = isDynamicPattern;
	  function escapePath(source) {
	    assertPatternsInput(source);
	    return utils.path.escape(source);
	  }
	  FastGlob2.escapePath = escapePath;
	  function convertPathToPattern(source) {
	    assertPatternsInput(source);
	    return utils.path.convertPathToPattern(source);
	  }
	  FastGlob2.convertPathToPattern = convertPathToPattern;
	  (function(posix2) {
	    function escapePath2(source) {
	      assertPatternsInput(source);
	      return utils.path.escapePosixPath(source);
	    }
	    posix2.escapePath = escapePath2;
	    function convertPathToPattern2(source) {
	      assertPatternsInput(source);
	      return utils.path.convertPosixPathToPattern(source);
	    }
	    posix2.convertPathToPattern = convertPathToPattern2;
	  })(FastGlob2.posix || (FastGlob2.posix = {}));
	  (function(win322) {
	    function escapePath2(source) {
	      assertPatternsInput(source);
	      return utils.path.escapeWindowsPath(source);
	    }
	    win322.escapePath = escapePath2;
	    function convertPathToPattern2(source) {
	      assertPatternsInput(source);
	      return utils.path.convertWindowsPathToPattern(source);
	    }
	    win322.convertPathToPattern = convertPathToPattern2;
	  })(FastGlob2.win32 || (FastGlob2.win32 = {}));
	})(FastGlob || (FastGlob = {}));
	function getWorks(source, _Provider, options) {
	  const patterns = [].concat(source);
	  const settings = new settings_1.default(options);
	  const tasks = taskManager.generate(patterns, settings);
	  const provider = new _Provider(settings);
	  return tasks.map(provider.read, provider);
	}
	function assertPatternsInput(input) {
	  const source = [].concat(input);
	  const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
	  if (!isValidSource) {
	    throw new TypeError("Patterns must be a string (non empty) or an array of strings");
	  }
	}
	out = FastGlob;
	return out;
}

var outExports = requireOut();
var fg = /*@__PURE__*/getDefaultExportFromCjs(outExports);

const defaultOptions = {
  hostname: "http://localhost/",
  dynamicRoutes: [],
  exclude: [],
  externalSitemaps: [],
  basePath: "",
  outDir: "dist",
  extensions: "html",
  changefreq: "daily",
  priority: 1,
  lastmod: /* @__PURE__ */ new Date(),
  readable: false,
  generateRobotsTxt: true,
  robots: [{
    userAgent: "*",
    allow: "/"
  }]
};
function resolveOptions(userOptions) {
  return Object.assign(
    {},
    defaultOptions,
    userOptions
  );
}
function getResolvedPath(file, resolvedOptions) {
  if (isAbsolute(resolvedOptions.outDir))
    return resolve(`${resolvedOptions.outDir}/${file}`);
  return resolve(`${ensurePrefix("./", resolvedOptions.outDir)}/${file}`);
}
function removeMaybeSuffix(suffix, str) {
  if (!str.endsWith(suffix))
    return str;
  return str.slice(0, -suffix.length);
}
var RobotCorrespondences = /* @__PURE__ */ ((RobotCorrespondences2) => {
  RobotCorrespondences2["userAgent"] = "User-agent";
  RobotCorrespondences2["allow"] = "Allow";
  RobotCorrespondences2["disallow"] = "Disallow";
  RobotCorrespondences2["crawlDelay"] = "Crawl-delay";
  RobotCorrespondences2["cleanParam"] = "Clean-param";
  return RobotCorrespondences2;
})(RobotCorrespondences || {});
function getRules(options) {
  const rules = [];
  options.forEach((rule) => {
    const keys = Object.keys(RobotCorrespondences).filter((key) => typeof rule[key] !== "undefined");
    keys.forEach((key) => {
      const values = Array.isArray(rule[key]) ? rule[key] : [rule[key]];
      values.forEach((value) => {
        rules.push({
          key: RobotCorrespondences[key],
          value
        });
      });
    });
  });
  return rules;
}
function getContent(rules, hostname, externalSitemaps) {
  return rules.map((rule) => `${rule.key}: ${String(rule.value).trim()}`).join("\n").concat(`

Sitemap: ${getFinalSitemapPath(hostname)}`).concat(externalSitemaps.map((s) => `
Sitemap: ${s.startsWith("http") ? s : getFinalSitemapPath(hostname, s)}`).join(""));
}
function getFinalSitemapPath(hostname, file = "/sitemap.xml") {
  return `${removeMaybeSuffix("/", hostname)}${ensurePrefix("/", file)}`;
}
function getRoutes(options) {
  const ext = typeof options.extensions === "string" ? [options.extensions] : options.extensions;
  const strExt = ext.map((e) => `**/*.${e}`);
  return [
    ...fg.sync(strExt, { cwd: options.outDir }).map((route) => {
      let r = route;
      ext.forEach((e) => {
        const regex = new RegExp(`index.${e}`, "g");
        r = r.replace(regex, "");
      });
      const parsedRoute = parse(r);
      return slash(join("/", parsedRoute.dir, parsedRoute.name));
    }),
    ...options.dynamicRoutes.map((route) => slash(join("/", join(parse(route).dir, parse(route).name))))
  ].filter((route) => !options.exclude.includes(route));
}
function getOptionByRoute(options, route) {
  if (options instanceof Date || typeof options === "string" || typeof options === "number")
    return options;
  const givenRoutes = Object.keys(options);
  if (givenRoutes.includes(route))
    return options[route];
  if (givenRoutes.includes("*"))
    return options["*"];
  return void 0;
}
function getFormattedSitemap(options, routes) {
  var _a;
  if (((_a = options.i18n) == null ? void 0 : _a.strategy) === "prefix_except_default") {
    return routes.map(prefixExceptDefaultLanguageFactory(
      options,
      {
        defaultLanguage: options.i18n.defaultLanguage || "en",
        languages: options.i18n.languages
      }
    ));
  }
  return routes.map((route) => {
    var _a2, _b, _c, _d;
    const hostNamePath = removeMaybeSuffix("/", options.hostname);
    const routePath = options.basePath ? ensurePrefix("/", options.basePath) + ensurePrefix("/", route) : ensurePrefix("/", route);
    const url = new URL(routePath, hostNamePath).href;
    const formattedSitemap = {
      url,
      changefreq: (_a2 = getOptionByRoute(options.changefreq, route)) != null ? _a2 : defaultOptions.changefreq,
      priority: (_b = getOptionByRoute(options.priority, route)) != null ? _b : defaultOptions.priority,
      lastmod: (_c = getOptionByRoute(options.lastmod, route)) != null ? _c : defaultOptions.lastmod
    };
    if (options.i18n) {
      const strategy = (_d = options.i18n.strategy) != null ? _d : "suffix";
      const languages = options.i18n.languages.map((str) => {
        var _a3;
        return {
          lang: str,
          url: str === ((_a3 = options.i18n) == null ? void 0 : _a3.defaultLanguage) ? url : new URL(strategy === "prefix" ? ensurePrefix("/", str) + routePath : removeMaybeSuffix("/", routePath) + ensurePrefix("/", str), hostNamePath).href
        };
      });
      return Object.assign(formattedSitemap, { links: options.i18n.defaultLanguage ? [...languages, { lang: "x-default", url }] : languages });
    }
    return formattedSitemap;
  });
}
function prefixExceptDefaultLanguageFactory(options, i18n) {
  const hostNamePath = removeMaybeSuffix("/", options.hostname);
  const useBasePath = ensurePrefix("/", ensureSuffix("/", options.basePath));
  const contextPath = removeMaybeSuffix("/", useBasePath);
  const defaultLanguage = i18n.defaultLanguage || "en";
  const locales = i18n.languages.filter((l) => l !== defaultLanguage);
  const localePrefixes = locales.map((lang) => {
    return [`${contextPath}/${lang}/`, `${contextPath}/${lang}`, lang];
  });
  return (route) => {
    var _a, _b, _c;
    let url;
    let pathWithoutLang;
    if (route === useBasePath) {
      url = ensureSuffix("/", new URL(useBasePath, hostNamePath).href);
      pathWithoutLang = "";
    } else {
      const locale = localePrefixes.find(
        ([
          prefix1,
          prefix2
        ]) => route.startsWith(prefix1) || route.startsWith(prefix2)
      );
      if (locale) {
        url = route.startsWith(locale[0]) ? route.replace(locale[0], "") : route.replace(locale[1], "");
        if (url === "") {
          pathWithoutLang = "";
          url = ensureSuffix("/", new URL(`${useBasePath}${locale[2]}`, hostNamePath).href);
        } else {
          pathWithoutLang = url[0] === "/" ? url.slice(1) : url;
          url = new URL(route, hostNamePath).href;
        }
      } else {
        pathWithoutLang = route.replace(useBasePath, "");
        url = new URL(route, hostNamePath).href;
      }
    }
    const trailingSlash = url.at(-1) === "/";
    let xDefaultHref = new URL(`${useBasePath}${pathWithoutLang}`, hostNamePath).href;
    if (trailingSlash)
      xDefaultHref = ensureSuffix("/", xDefaultHref);
    const links = [{
      hreflang: defaultLanguage,
      rel: "alternate",
      url: xDefaultHref
    }];
    for (const l of locales) {
      const href = new URL(`${useBasePath}${l}/${pathWithoutLang}`, hostNamePath).href;
      links.push({
        hreflang: l,
        rel: "alternate",
        url: trailingSlash ? ensureSuffix("/", href) : href
      });
    }
    links.push({
      hreflang: "x-default",
      rel: "alternate",
      url: xDefaultHref
    });
    return {
      url,
      changefreq: (_a = getOptionByRoute(options.changefreq, route)) != null ? _a : defaultOptions.changefreq,
      priority: (_b = getOptionByRoute(options.priority, route)) != null ? _b : defaultOptions.priority,
      lastmod: (_c = getOptionByRoute(options.lastmod, route)) != null ? _c : defaultOptions.lastmod,
      links
    };
  };
}
function generateSitemap$1(options = {}) {
  const resolvedOptions = resolveOptions(options);
  if (resolvedOptions.generateRobotsTxt) {
    const robotRules = getRules(resolvedOptions.robots);
    const robotContent = getContent(robotRules, resolvedOptions.hostname, resolvedOptions.externalSitemaps);
    writeFileSync(getResolvedPath("robots.txt", resolvedOptions), robotContent);
  }
  const routes = getRoutes(resolvedOptions);
  if (!routes.length)
    return;
  const formattedSitemap = getFormattedSitemap(resolvedOptions, routes);
  const stream = new distExports.SitemapStream({
    xmlns: resolvedOptions.xmlns
  });
  formattedSitemap.forEach((item) => stream.write(item));
  distExports.streamToPromise(stream).then((sitemap) => {
    const utfSitemap = sitemap.toString("utf-8");
    const formattedSitemap2 = resolvedOptions.readable ? format(utfSitemap) : utfSitemap;
    writeFileSync(getResolvedPath("sitemap.xml", resolvedOptions), formattedSitemap2);
  });
  stream.end();
}

function generateSitemap(options = {}) {
  generateSitemap$1(options);
}

export { generateSitemap as default };
