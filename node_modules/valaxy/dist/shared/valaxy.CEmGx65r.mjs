import process from 'node:process';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import os from 'node:os';
import path$1, { join, dirname, resolve, relative as relative$1 } from 'node:path';
import { consola } from 'consola';
import { colors } from 'consola/utils';
import fg from 'fast-glob';
import fs from 'fs-extra';
import matter from 'gray-matter';
import yaml, { CORE_SCHEMA } from 'js-yaml';
import { ensurePrefix, slash, uniq, objectEntries, isObject, isFunction, ensureSuffix } from '@antfu/utils';
import _debug from 'debug';
import path, { resolve as resolve$1, join as join$1, relative } from 'pathe';
import defu, { createDefu } from 'defu';
import { loadConfigFromFile as loadConfigFromFile$1, mergeConfig, searchForWorkspaceRoot, build as build$3, createServer as createServer$1 } from 'vite';
import { webcrypto } from 'node:crypto';
import { options } from 'floating-vue';
import { loadConfig } from 'define-config-ts';
import ora from 'ora';
import { spawn } from 'cross-spawn';
import { resolvePath } from 'mlly';
import { resolveGlobal } from 'resolve-global';
import { normalizeRepositoryUrl } from '@valaxyjs/utils';
import { readFile } from 'node:fs/promises';
import dayjs from 'dayjs';
import { Feed } from 'feed';
import MarkdownIt from 'markdown-it';
import { table, getBorderCharacters } from 'table';
import { createHooks } from 'hookable';
import generateSitemap from 'vite-ssg-sitemap';
import { build as build$2 } from 'vite-ssg/node';
import VueI18n from '@intlify/unplugin-vue-i18n/vite';
import UnheadVite from '@unhead/addons/vite';
import Components from 'unplugin-vue-components/vite';
import Layouts from 'vite-plugin-vue-layouts';
import { groupIconMdPlugin, groupIconVitePlugin } from 'vitepress-plugin-group-icons';
import { MarkdownItAsync } from 'markdown-it-async';
import { transformerNotationDiff, transformerNotationFocus, transformerNotationHighlight, transformerNotationErrorLevel, transformerCompactLineOptions } from '@shikijs/transformers';
import { createHighlighter, addClassToHast, isSpecialLang } from 'shiki';
import { cssI18nContainer } from 'css-i18n';
import anchorPlugin from 'markdown-it-anchor';
import attrsPlugin from 'markdown-it-attrs';
import { full } from 'markdown-it-emoji';
import footnotePlugin from 'markdown-it-footnote';
import imageFigures from 'markdown-it-image-figures';
import TaskLists from 'markdown-it-task-lists';
import { URL as URL$1 } from 'node:url';
import container from 'markdown-it-container';
import katex from 'katex';
import Markdown from 'unplugin-vue-markdown/vite';
import * as base64 from 'js-base64';
import { existsSync, readFileSync } from 'node:fs';
import { createJiti } from 'jiti';
import { transformerDirectives, transformerVariantGroup, presetWind4, presetAttributify, presetIcons, presetTypography } from 'unocss';
import pascalCase from 'pascalcase';
import { LRUCache } from 'lru-cache';
import { convert } from 'html-to-text';
import VueRouter from 'unplugin-vue-router/vite';
import { intro, confirm, select, outro } from '@clack/prompts';
import net from 'node:net';
import { exec } from 'node:child_process';
import * as readline from 'node:readline';
import qrcode from 'qrcode';
import ejs from 'ejs';

const EXCERPT_SEPARATOR = "<!-- more -->";
const PATHNAME_PROTOCOL_RE = /^pathname:\/\//;
const ALL_ROUTE = "/:all(.*)*";
const customElements = /* @__PURE__ */ new Set([
  // katex
  "annotation",
  "math",
  "menclose",
  "mfrac",
  "mglyph",
  "mi",
  "mlabeledtr",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mroot",
  "mrow",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msubsup",
  "msup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover",
  "semantics"
]);
const defaultViteConfig = {};

function getKeyMaterial(password) {
  const enc = new TextEncoder();
  return webcrypto.subtle.importKey(
    "raw",
    enc.encode(password),
    "PBKDF2",
    false,
    ["deriveBits", "deriveKey"]
  );
}
function getCryptoDeriveKey(keyMaterial, salt) {
  return webcrypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt,
      iterations: 1e5,
      hash: "SHA-256"
    },
    keyMaterial,
    {
      name: "AES-CBC",
      length: 256
    },
    true,
    ["encrypt", "decrypt"]
  );
}
async function encryptContent(content, options) {
  const { password, iv, salt } = options;
  const keyMaterial = await getKeyMaterial(password);
  const key = await getCryptoDeriveKey(keyMaterial, salt);
  const enc = new TextEncoder();
  const ciphertextData = await webcrypto.subtle.encrypt(
    {
      name: "AES-CBC",
      iv
    },
    key,
    enc.encode(content)
  );
  return String.fromCharCode(...new Uint8Array(ciphertextData));
}

function getGitTimestamp(file, type = "updated") {
  return new Promise((resolve, _reject) => {
    const params = ["log"];
    if (type === "updated")
      params.push("-1");
    params.push('--pretty="%ci"', file);
    if (type === "created")
      params.push("|", "tail", "-1");
    const child = spawn("git", params);
    let output = "";
    child.stdout.on("data", (d) => output += String(d));
    child.on("close", () => {
      resolve(+new Date(output));
    });
    child.on("error", () => {
      resolve(0);
    });
  });
}

const EXTERNAL_URL_RE = /^(?:[a-z]+:|\/\/)/i;
const LOCALE_PREFIX = "$locale:";

function tObject(data, lang) {
  if (data && typeof data === "object") {
    return data[lang] || Object.values(data)[0] || "";
  }
  return data;
}

function isExternal(str) {
  return EXTERNAL_URL_RE.test(str);
}
function isPath(name) {
  return name.startsWith("/") || /^\.\.?[/\\]/.test(name);
}
function transformObject(obj) {
  return `JSON.parse(${JSON.stringify(JSON.stringify(obj))})`;
}

const isInstalledGlobally = {};
async function resolveImportUrl(id) {
  return toAtFS(await resolveImportPath(id, true));
}
function toAtFS(path) {
  return `/@fs${ensurePrefix("/", slash(path))}`;
}
async function resolveImportPath(importName, ensure = false) {
  try {
    return await resolvePath(importName, {
      url: import.meta.url
    });
  } catch (error) {
    consola.log(error);
  }
  if (isInstalledGlobally.value) {
    try {
      return resolveGlobal(importName);
    } catch {
    }
  }
  if (ensure)
    throw new Error(`Failed to resolve package ${importName}`);
  else
    consola.warn(`Failed to resolve package ${importName}`);
}

async function mergeViteConfigs({ userRoot, themeRoot }, command) {
  const configEnv = {
    mode: "development",
    command
  };
  let resolvedConfig = {};
  const files = uniq([themeRoot, userRoot]).map((i) => join(i, "vite.config.ts"));
  const loadViteConfigPromiseArr = files.map(async (file) => {
    if (!await fs.exists(file))
      return;
    return loadConfigFromFile$1(configEnv, file);
  });
  const viteConfigs = await Promise.all(loadViteConfigPromiseArr);
  for (const viteConfig of viteConfigs) {
    if (!viteConfig?.config)
      continue;
    resolvedConfig = mergeConfig(resolvedConfig, viteConfig.config);
  }
  return resolvedConfig;
}
async function getIndexHtml({ clientRoot, themeRoot, userRoot, config }, rawHtml) {
  let main = rawHtml;
  let head = "";
  let body = "";
  if (config.siteConfig.favicon)
    head += `<link rel="icon" href="${config.siteConfig.favicon}">`;
  const roots = [userRoot, themeRoot];
  if (config.siteConfig.mode === "auto") {
    head += `
    <script>
    ;(function () {
      const prefersDark =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches
      const setting = localStorage.getItem('vueuse-color-scheme') || 'auto'
      if (setting === 'dark' || (prefersDark && setting !== 'light'))
        document.documentElement.classList.toggle('dark', true)
    })()
    <\/script>
  `;
    head += `<style type="text/css">
    :root { color-scheme: light dark; --va-c-bg: #fff; }
    html.dark { --va-c-bg: #000; }
    html { background-color: var(--va-c-bg); }
  </style>`;
  }
  if (config.siteConfig.lang) {
    head += `
    <script>
    const locale = localStorage.getItem('valaxy-locale') || '${config.siteConfig.lang}';
    document.documentElement.setAttribute('lang', locale);
    <\/script>
    `;
  }
  for (const root of roots) {
    const path = join(root, "index.html");
    if (!fs.existsSync(path))
      continue;
    const indexHtml = await fs.readFile(path, "utf-8");
    head += `
${(indexHtml.match(/<head>([\s\S]*?)<\/head>/i)?.[1] || "").trim()}`;
    body += `
${(indexHtml.match(/<body>([\s\S]*?)<\/body>/i)?.[1] || "").trim()}`;
  }
  main = main.replace("__ENTRY__", toAtFS(join(clientRoot, "main.ts"))).replace("<!-- head -->", head).replace("<!-- body -->", body);
  return main;
}

const clientDeps = [
  // https://cn.vite.dev/guide/dep-pre-bundling.html#the-why
  "dayjs",
  "dayjs/locale/en",
  "dayjs/locale/zh-cn",
  "dayjs/plugin/relativeTime",
  "dayjs/plugin/timezone",
  "dayjs/plugin/utc",
  "@unhead/schema-org/vue",
  "@unhead/vue",
  "defu",
  "katex",
  "nprogress",
  "unocss",
  // vue
  "vue",
  "vue-router",
  "vue-i18n",
  // dev
  "@vue/devtools-api",
  // will may be addons
  "fuse.js",
  "medium-zoom",
  "vanilla-lazyload",
  "valaxy > @vueuse/integrations/useFuse"
];
const EXCLUDE = [
  "@docsearch/css",
  "@docsearch/js",
  // exclude for @waline/client/dist/component(use @vueuse/core) import
  "@vueuse/core",
  "@vueuse/shared",
  "@unocss/reset",
  "unocss",
  // addon, todo add externals for addon
  // main field error
  "meting",
  // internal
  "valaxy",
  "virtual:valaxy-addons:empty",
  "@valaxyjs/devtools",
  "/@valaxyjs/config",
  "/@valaxyjs/context",
  "/@valaxyjs/addons",
  "/@valaxyjs/locales",
  "/@valaxyjs/styles",
  /**
   * unplugin-vue-router
   * exclude to avoid vite optimize, will make Symbol('loaderEntries') valid
   */
  "unplugin-vue-router/data-loaders/basic"
];
function createConfigPlugin(options) {
  const addonDeps = options.addons.map((i) => Object.keys(i.pkg.dependencies || {})).flat();
  const includedDeps = uniq([
    ...clientDeps,
    // remove theme deps, for primevue parse entry
    // ...themeDeps,
    // addon deps
    ...addonDeps
  ]).filter((i) => !EXCLUDE.includes(i));
  return {
    name: "valaxy:site",
    // before devtools
    enforce: "pre",
    async config(config) {
      const injection = {
        // root: options.userRoot,
        // can not transform valaxy/client/*.ts when use userRoot
        root: options.clientRoot,
        // cacheDir: join(options.userRoot, 'node_modules/.vite'),
        cacheDir: join(options.userRoot, "node_modules/.valaxy/cache"),
        publicDir: join(options.userRoot, "public"),
        define: getDefine(),
        resolve: {
          alias: await getAlias(options),
          dedupe: ["vue"]
        },
        optimizeDeps: {
          // do not entry node file
          entries: [resolve(options.clientRoot, "main.ts")],
          // must need it
          include: includedDeps,
          exclude: EXCLUDE
        },
        server: {
          fs: {
            allow: uniq([
              searchForWorkspaceRoot(options.clientRoot),
              searchForWorkspaceRoot(options.themeRoot),
              searchForWorkspaceRoot(options.userRoot),
              dirname(await resolveImportPath("katex/package.json", true))
            ])
          }
        }
      };
      if (isInstalledGlobally) {
        injection.resolve.alias.vue = `${resolveImportPath("vue/dist/vue.esm-browser.js", true)}`;
      }
      return mergeConfig(config, injection);
    },
    async transformIndexHtml(html) {
      html = await getIndexHtml(options, html);
      return {
        html,
        tags: []
      };
    }
  };
}
function getDefine(_options) {
  return {
    __VUE_PROD_DEVTOOLS__: false,
    __INTLIFY_PROD_DEVTOOLS__: false
  };
}
async function getAlias(options) {
  const alias = [
    /**
     * virtual module alias
     * `/` 开头无法 declare module 类型
     *
     * #valaxy/* => /@valaxyjs/*
     */
    { find: /^#valaxy\/(.*)/, replacement: "/@valaxyjs/$1" },
    { find: "~/", replacement: `${toAtFS(options.userRoot)}/` },
    { find: "valaxy/client/", replacement: `${toAtFS(options.clientRoot)}/` },
    { find: "valaxy/package.json", replacement: toAtFS(resolve(options.clientRoot, "../package.json")) },
    { find: /^valaxy$/, replacement: toAtFS(resolve(options.clientRoot, "index.ts")) },
    { find: "@valaxyjs/client/", replacement: `${toAtFS(options.clientRoot)}/` },
    // import theme
    { find: `valaxy-theme-${options.theme}/client`, replacement: `${toAtFS(resolve(options.themeRoot))}/client/index.ts` },
    { find: `valaxy-theme-${options.theme}/`, replacement: `${toAtFS(resolve(options.themeRoot))}/` },
    { find: `valaxy-theme-${options.theme}`, replacement: `${toAtFS(resolve(options.themeRoot))}/client/index.ts` }
  ];
  if (options.config.vue?.browserTemplateCompilation) {
    alias.push(
      { find: /^vue$/, replacement: await resolveImportPath("vue/dist/vue.esm-bundler.js", true) }
    );
  }
  options.addons.forEach((addon) => {
    alias.push({
      find: `${addon.name}/client/`,
      replacement: `${toAtFS(`${resolve(addon.root)}`)}/client/`
    });
    alias.push({
      find: `${addon.name}/App.vue`,
      replacement: `${toAtFS(resolve(addon.root))}/App.vue`
    });
    alias.push({
      find: addon.name,
      replacement: `${toAtFS(resolve(addon.root))}/client/index.ts`
    });
  });
  alias.push({
    find: /^valaxy-addon-(.*)$/,
    replacement: toAtFS(resolve(options.clientRoot, "./addons/index.ts"))
  });
  return alias;
}

const LOCAL_SEARCH_INDEX_ID = "@localSearchIndex";
const LOCAL_SEARCH_INDEX_REQUEST_PATH = `/${LOCAL_SEARCH_INDEX_ID}`;
async function localSearchPlugin(options) {
  const siteConfig = options.config.siteConfig;
  if (siteConfig.search?.provider !== "local") {
    return {
      name: "valaxy:local-search",
      resolveId(id) {
        if (id.startsWith(LOCAL_SEARCH_INDEX_ID)) {
          return LOCAL_SEARCH_INDEX_REQUEST_PATH;
        }
      },
      load(id) {
        if (id.startsWith(LOCAL_SEARCH_INDEX_REQUEST_PATH)) {
          return `export default '{}'`;
        }
      }
    };
  }
  return {
    name: "valaxy:local-search",
    config: () => {
      return {
        optimizeDeps: {
          include: [
            "valaxy > @vueuse/integrations/useFocusTrap",
            "valaxy > mark.js/src/vanilla.js",
            "valaxy > minisearch"
          ]
        }
        // async configureServer(_server) {
        //   server = _server
        //   await scanForBuild()
        //   onIndexUpdated()
        // },
        // resolveId(id) {
        //   if (id.startsWith(LOCAL_SEARCH_INDEX_ID)) {
        //     return `/${id}`
        //   }
        // },
      };
    }
  };
}

const logger = consola.create({});
const valaxyPrefix = colors.magenta("[valaxy]");
const vLogger = {
  success: (...args) => logger.success(valaxyPrefix, ...args),
  info: (...args) => logger.info(valaxyPrefix, ...args),
  ready: (...args) => logger.ready(valaxyPrefix, ...args)
};
async function callHookWithLog(hookName, valaxyApp) {
  const hookNameStr = `${colors.cyan("[HOOK]")} ${colors.magenta(hookName)}`;
  const s = ora(`${hookNameStr} calling...`).start();
  await valaxyApp.hooks.callHook(hookName);
  s.succeed(`${hookNameStr} done.`);
}

const POOL_SIZE_MULTIPLIER = 128;
let pool, poolOffset;
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    webcrypto.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    webcrypto.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function random(bytes) {
  fillPool((bytes |= 0));
  return pool.subarray(poolOffset - bytes, poolOffset)
}
function customRandom(alphabet, defaultSize, getRandom) {
  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1;
  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length);
  return (size = defaultSize) => {
    if (!size) return ''
    let id = '';
    while (true) {
      let bytes = getRandom(step);
      let i = step;
      while (i--) {
        id += alphabet[bytes[i] & mask] || '';
        if (id.length >= size) return id
      }
    }
  }
}
function customAlphabet(alphabet, size = 21) {
  return customRandom(alphabet, size, random)
}

const nanoid = customAlphabet("abcdefghijklmnopqrstuvwxyz", 10);
function attrsToLines(attrs) {
  attrs = attrs.replace(/^(?:\[.*?\])?.*?([\d,-]+).*/, "$1").trim();
  const result = [];
  if (!attrs)
    return [];
  attrs.split(",").map((v) => v.split("-").map((v2) => Number.parseInt(v2, 10))).forEach(([start, end]) => {
    if (start && end) {
      result.push(
        ...Array.from({ length: end - start + 1 }, (_, i) => start + i)
      );
    } else {
      result.push(start);
    }
  });
  return result.map((v) => ({
    line: v,
    classes: ["highlighted"]
  }));
}
async function highlight(theme, options, logger = console) {
  const {
    defaultHighlightLang: defaultLang = "txt",
    codeTransformers: userTransformers = []
  } = options;
  const highlighter = await createHighlighter({
    themes: typeof theme === "object" && "light" in theme && "dark" in theme ? [theme.light, theme.dark] : [theme],
    langs: [
      // load long time, about 3s
      // ...Object.keys(bundledLanguages),
      ...options.languages || [],
      ...Object.values(options.languageAlias || {})
    ],
    langAlias: options.languageAlias
  });
  await options?.shikiSetup?.(highlighter);
  const transformers = [
    transformerNotationDiff(),
    transformerNotationFocus({
      classActiveLine: "has-focus",
      classActivePre: "has-focused-lines"
    }),
    transformerNotationHighlight(),
    transformerNotationErrorLevel(),
    {
      name: "valaxy:add-class",
      pre(node) {
        addClassToHast(node, "vp-code");
      }
    },
    {
      name: "valaxy:clean-up",
      pre(node) {
        delete node.properties.tabindex;
        delete node.properties.style;
      }
    }
  ];
  const vueRE = /-vue$/;
  const lineNoStartRE = /=(\d*)/;
  const lineNoRE = /:(no-)?line-numbers(=\d*)?$/;
  const mustacheRE = /\{\{.*?\}\}/g;
  return [
    async (str, lang, attrs) => {
      const vPre = vueRE.test(lang) ? "" : "v-pre";
      lang = lang.replace(lineNoStartRE, "").replace(lineNoRE, "").replace(vueRE, "").toLowerCase() || defaultLang;
      try {
        if (!isSpecialLang(lang) && !highlighter.getLoadedLanguages().includes(lang)) {
          await highlighter.loadLanguage(lang);
        }
      } catch {
        logger.warn(
          colors.yellow(
            `
The language '${lang}' is not loaded, falling back to '${defaultLang}' for syntax highlighting.`
          )
        );
        lang = defaultLang;
      }
      const lineOptions = attrsToLines(attrs);
      const mustaches = /* @__PURE__ */ new Map();
      const removeMustache = (s) => {
        if (vPre)
          return s;
        return s.replace(mustacheRE, (match) => {
          let marker = mustaches.get(match);
          if (!marker) {
            marker = nanoid();
            mustaches.set(match, marker);
          }
          return marker;
        });
      };
      const restoreMustache = (s) => {
        mustaches.forEach((marker, match) => {
          s = s.replaceAll(marker, match);
        });
        return s;
      };
      str = removeMustache(str).trimEnd();
      const highlighted = highlighter.codeToHtml(str, {
        lang,
        transformers: [
          ...transformers,
          transformerCompactLineOptions(lineOptions),
          {
            name: "valaxy:v-pre",
            pre(node) {
              if (vPre)
                node.properties["v-pre"] = "";
            }
          },
          {
            name: "valaxy:empty-line",
            code(hast) {
              hast.children.forEach((span) => {
                if (span.type === "element" && span.tagName === "span" && Array.isArray(span.properties.class) && span.properties.class.includes("line") && span.children.length === 0) {
                  span.children.push({
                    type: "element",
                    tagName: "wbr",
                    properties: {},
                    children: []
                  });
                }
              });
            }
          },
          ...userTransformers
        ],
        meta: {
          __raw: attrs
        },
        ...typeof theme === "object" && "light" in theme && "dark" in theme ? { themes: theme, defaultColor: false } : { theme }
      });
      return restoreMustache(highlighted);
    },
    highlighter.dispose
  ];
}

//#region src/html-escape.ts
const htmlEscapeMap = {
	"&": "&amp;",
	"<": "&lt;",
	">": "&gt;",
	"'": "&#39;",
	"\"": "&quot;"
};
const htmlEscapeRegexp = /[&<>'"]/g;
/**
* Escape html chars
*/
const htmlEscape = (str) => str.replace(htmlEscapeRegexp, (char) => htmlEscapeMap[char]);

//#endregion
//#region src/resolve-title-from-token.ts
/**
* Resolve header title from markdown-it token
*
* Typically using the next token of `heading_open` token
*/
const resolveTitleFromToken = (token, { shouldAllowHtml, shouldEscapeText }) => {
	const children = token.children ?? [];
	const titleTokenTypes = [
		"text",
		"emoji",
		"code_inline"
	];
	if (shouldAllowHtml) titleTokenTypes.push("html_inline");
	const titleTokens = children.filter((item) => titleTokenTypes.includes(item.type) && !item.meta?.isPermalinkSymbol);
	return titleTokens.reduce((result, item) => {
		if (shouldEscapeText) {
			if (item.type === "code_inline" || item.type === "text") return `${result}${htmlEscape(item.content)}`;
		}
		return `${result}${item.content}`;
	}, "").trim();
};

//#endregion
//#region src/resolve-headers-from-tokens.ts
/**
* Resolve headers from markdown-it tokens
*/
const resolveHeadersFromTokens = (tokens, { level, shouldAllowHtml, shouldAllowNested, shouldEscapeText, slugify: slugify$1, format }) => {
	const headers = [];
	const stack = [];
	const push = (header) => {
		while (stack.length !== 0 && header.level <= stack[0].level) stack.shift();
		if (stack.length === 0) {
			headers.push(header);
			stack.push(header);
		} else {
			stack[0].children.push(header);
			stack.unshift(header);
		}
	};
	for (let i = 0; i < tokens.length; i += 1) {
		const token = tokens[i];
		if (token.type !== "heading_open") continue;
		if (token.level !== 0 && !shouldAllowNested) continue;
		const headerLevel = Number.parseInt(token.tag.slice(1), 10);
		if (!level.includes(headerLevel)) continue;
		const nextToken = tokens[i + 1];
		/* istanbul ignore if -- @preserve */
		if (!nextToken) continue;
		const title = resolveTitleFromToken(nextToken, {
			shouldAllowHtml,
			shouldEscapeText
		});
		const slug = token.attrGet("id") ?? slugify$1(title);
		push({
			level: headerLevel,
			title: format?.(title) ?? title,
			slug,
			link: `#${slug}`,
			children: []
		});
	}
	return headers;
};

//#endregion
//#region src/slugify.ts
const rControl = /[\u0000-\u001f]/g;
const rSpecial = /[\s~`!@#$%^&*()\-_+=[\]{}|\\;:"'“”‘’<>,.?/]+/g;
const rCombining = /[\u0300-\u036F]/g;
/**
* Default slugification function
*/
const slugify = (str) => str.normalize("NFKD").replace(rCombining, "").replace(rControl, "").replace(rSpecial, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "").replace(/^(\d)/, "_$1").toLowerCase();

//#region src/headers-plugin.ts
/**
* Get markdown headers info
*
* Extract them into env
*/
const headersPlugin = (md, { level = [2, 3], shouldAllowNested = false, slugify: slugify$1 = slugify, format } = {}) => {
	const render = md.renderer.render.bind(md.renderer);
	md.renderer.render = (tokens, options, env) => {
		env.headers = resolveHeadersFromTokens(tokens, {
			level,
			shouldAllowHtml: false,
			shouldAllowNested,
			shouldEscapeText: false,
			slugify: slugify$1,
			format
		});
		return render(tokens, options, env);
	};
};

//#region src/constants.ts
const TAG_NAME_SCRIPT = "script";
const TAG_NAME_STYLE = "style";
const TAG_NAME_TEMPLATE = "template";

//#endregion
//#region src/sfc-regexp.ts
const SCRIPT_SETUP_TAG_OPEN_REGEXP = /^<script\s+.*?\bsetup\b.*?>$/is;
/**
* Generate RegExp for sfc blocks
*/
const createSfcRegexp = ({ customBlocks }) => {
	const sfcTags = Array.from(new Set([
		TAG_NAME_SCRIPT,
		TAG_NAME_STYLE,
		...customBlocks
	])).join("|");
	return new RegExp(`^\\s*(?<content>(?<tagOpen><(?<type>${sfcTags})\\s?.*?>)(?<contentStripped>.*)(?<tagClose><\\/\\k<type>\\s*>))\\s*$`, "is");
};

//#endregion
//#region src/sfc-plugin.ts
/**
* Get Vue SFC blocks
*
* Extract them into env and avoid rendering them
*/
const sfcPlugin = (md, { customBlocks = [] } = {}) => {
	const sfcRegexp = createSfcRegexp({ customBlocks });
	const render = md.render.bind(md);
	md.render = (src, env = {}) => {
		env.sfcBlocks = {
			template: null,
			script: null,
			scriptSetup: null,
			scripts: [],
			styles: [],
			customBlocks: []
		};
		const rendered = render(src, env);
		env.sfcBlocks.template = {
			type: TAG_NAME_TEMPLATE,
			content: `<${TAG_NAME_TEMPLATE}>${rendered}</${TAG_NAME_TEMPLATE}>`,
			contentStripped: rendered,
			tagOpen: `<${TAG_NAME_TEMPLATE}>`,
			tagClose: `</${TAG_NAME_TEMPLATE}>`
		};
		return rendered;
	};
	const htmlBlockRule = md.renderer.rules.html_block;
	md.renderer.rules.html_block = (tokens, idx, options, env, self) => {
		/* istanbul ignore if -- @preserve */
		if (!env.sfcBlocks) return htmlBlockRule(tokens, idx, options, env, self);
		const token = tokens[idx];
		const content = token.content;
		const match = content.match(sfcRegexp);
		if (!match) return htmlBlockRule(tokens, idx, options, env, self);
		const sfcBlock = match.groups;
		if (sfcBlock.type === TAG_NAME_SCRIPT) {
			env.sfcBlocks.scripts.push(sfcBlock);
			if (SCRIPT_SETUP_TAG_OPEN_REGEXP.test(sfcBlock.tagOpen)) env.sfcBlocks.scriptSetup = sfcBlock;
			else env.sfcBlocks.script = sfcBlock;
		} else if (sfcBlock.type === TAG_NAME_STYLE) env.sfcBlocks.styles.push(sfcBlock);
		else env.sfcBlocks.customBlocks.push(sfcBlock);
		return "";
	};
};

//#region src/title-plugin.ts
/**
* Get markdown page title info
*
* Extract it into env
*/
const titlePlugin = (md) => {
	const render = md.renderer.render.bind(md.renderer);
	md.renderer.render = (tokens, options, env) => {
		const tokenIdx = tokens.findIndex((token) => token.tag === "h1");
		env.title = tokenIdx > -1 ? resolveTitleFromToken(tokens[tokenIdx + 1], {
			shouldAllowHtml: false,
			shouldEscapeText: false
		}) : "";
		return render(tokens, options, env);
	};
};

//#region src/create-render-headers.ts
const createRenderHeaders = ({ listTag, listClass, itemClass, linkTag, linkClass }) => {
	const listTagString = htmlEscape(listTag);
	const listClassString = listClass ? ` class="${htmlEscape(listClass)}"` : "";
	const itemTagString = "li";
	const itemClassString = itemClass ? ` class="${htmlEscape(itemClass)}"` : "";
	const linkTagString = htmlEscape(linkTag);
	const linkClassString = linkClass ? ` class="${htmlEscape(linkClass)}"` : "";
	const linkTo = (link) => linkTag === "router-link" ? ` to="${link}"` : ` href="${link}"`;
	const renderHeaders = (headers) => `\
<${listTagString}${listClassString}>\
${headers.map((header) => `\
<${itemTagString}${itemClassString}>\
<${linkTagString}${linkClassString}${linkTo(header.link)}>\
${header.title}\
</${linkTagString}>\
${header.children.length > 0 ? renderHeaders(header.children) : ""}\
</${itemTagString}>\
`).join("")}\
</${listTagString}>`;
	return renderHeaders;
};

//#endregion
//#region src/create-toc-block-rule.ts
/**
* Forked and modified from markdown-it-toc-done-right
*
* - remove the `inlineOptions` support
* - use markdown-it default renderer to render token whenever possible
*
* @see https://github.com/nagaozen/markdown-it-toc-done-right
*/
const createTocBlockRule = ({ pattern, containerTag, containerClass }) => (state, startLine, endLine, silent) => {
	if (state.sCount[startLine] - state.blkIndent >= 4) return false;
	const pos = state.bMarks[startLine] + state.tShift[startLine];
	const max = state.eMarks[startLine];
	const lineFirstToken = state.src.slice(pos, max).split(" ")[0];
	if (!pattern.test(lineFirstToken)) return false;
	if (silent) return true;
	state.line = startLine + 1;
	const tokenOpen = state.push("toc_open", containerTag, 1);
	tokenOpen.markup = "";
	tokenOpen.map = [startLine, state.line];
	if (containerClass) tokenOpen.attrSet("class", containerClass);
	const tokenBody = state.push("toc_body", "", 0);
	tokenBody.markup = lineFirstToken;
	tokenBody.map = [startLine, state.line];
	tokenBody.hidden = true;
	const tokenClose = state.push("toc_close", containerTag, -1);
	tokenClose.markup = "";
	tokenBody.map = [startLine, state.line];
	return true;
};

//#endregion
//#region src/toc-plugin.ts
/**
* Generate table of contents
*
* Forked and modified from markdown-it-toc-done-right:
*
* @see https://github.com/nagaozen/markdown-it-toc-done-right
*/
const tocPlugin = (md, { pattern = /^\[\[toc\]\]$/i, slugify: slugify$1 = slugify, format, level = [2, 3], shouldAllowNested = false, containerTag = "nav", containerClass = "table-of-contents", listTag = "ul", listClass = "", itemClass = "", linkTag = "a", linkClass = "" } = {}) => {
	md.block.ruler.before("heading", "toc", createTocBlockRule({
		pattern,
		containerTag,
		containerClass
	}), { alt: [
		"paragraph",
		"reference",
		"blockquote"
	] });
	const renderHeaders = createRenderHeaders({
		listTag,
		listClass,
		itemClass,
		linkTag,
		linkClass
	});
	md.renderer.rules.toc_body = (tokens) => renderHeaders(resolveHeadersFromTokens(tokens, {
		level,
		shouldAllowHtml: true,
		shouldAllowNested,
		shouldEscapeText: true,
		slugify: slugify$1,
		format
	}));
};

const indexRE = /(^|.*\/)index.md(.*)$/i;
function linkPlugin(md, externalAttrs, base) {
  md.renderer.rules.link_open = (tokens, idx, options, env, self) => {
    const token = tokens[idx];
    const hrefIndex = token.attrIndex("href");
    if (hrefIndex >= 0) {
      const hrefAttr = token.attrs[hrefIndex];
      const url = hrefAttr[1];
      const isExternal = EXTERNAL_URL_RE.test(url);
      if (isExternal) {
        Object.entries(externalAttrs).forEach(([key, val]) => {
          token.attrSet(key, val);
        });
        hrefAttr[1] = url.replace(PATHNAME_PROTOCOL_RE, "");
      } else if (
        // internal anchor links
        !url.startsWith("#") && !url.startsWith("mailto:") && !/\.(?!html|md)\w+($|\?)/i.test(url)
      ) {
        normalizeHref(hrefAttr, env);
      }
      hrefAttr[1] = hrefAttr[1].replace(/\bimport\.meta/g, "import%2Emeta").replace(/\bprocess\.env/g, "process%2Eenv");
    }
    return self.renderToken(tokens, idx, options);
  };
  function normalizeHref(hrefAttr, env) {
    let url = hrefAttr[1];
    const indexMatch = url.match(indexRE);
    if (indexMatch) {
      const [, path, hash] = indexMatch;
      url = path + hash;
    } else {
      let cleanUrl = url.replace(/[?#].*$/, "");
      if (cleanUrl.endsWith(".md")) {
        cleanUrl = cleanUrl.replace(
          /\.md$/,
          env.cleanUrls === "disabled" ? ".html" : ""
        );
      }
      if (env.cleanUrls === "disabled" && !cleanUrl.endsWith(".html") && !cleanUrl.endsWith("/")) {
        cleanUrl += ".html";
      }
      const parsed = new URL$1(url, "http://a.com");
      url = cleanUrl + parsed.search + parsed.hash;
    }
    if (!url.startsWith("/") && !/^\.\//.test(url))
      url = `./${url}`;
    pushLink(url.replace(/\.html$/, ""), env);
    if (url.startsWith("/"))
      url = `${base}${url}`.replace(/\/+/g, "/");
    hrefAttr[1] = decodeURI(url);
  }
  function pushLink(link, env) {
    const links = env.links || (env.links = []);
    links.push(link);
  }
}

function extractLang(info) {
  return info.trim().replace(/=(\d*)/, "").replace(/:(no-)?line-numbers(\{| |$|=\d*).*/, "").replace(/(-vue|\{| ).*$/, "").replace(/^vue-html$/, "template").replace(/^ansi$/, "");
}
function extractTitle(info, html = false) {
  if (html) {
    return info.replace(/<!--[\s\S]*?-->/g, "").match(/data-title="(.*?)"/)?.[1] || "";
  }
  return info.match(/\[(.*)\]/)?.[1] || extractLang(info) || "txt";
}
function getCodeHeightLimitStyle(options, env) {
  const codeHeightLimit = env.frontmatter?.codeHeightLimit || options?.siteConfig?.codeHeightLimit;
  if (codeHeightLimit === void 0 || codeHeightLimit <= 0)
    return "";
  return ` max-h-${codeHeightLimit}px`;
}
function preWrapperPlugin(md, options) {
  const fence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const [tokens, idx, _, env] = args;
    const token = tokens[idx];
    token.info = token.info.replace(/\[.*\]/, "");
    const active = / active( |$)/.test(token.info) ? " active" : "";
    token.info = token.info.replace(/ active$/, "").replace(/ active /, " ");
    const lang = extractLang(token.info);
    const rawCode = fence(...args);
    const codeHeightLimitClass = getCodeHeightLimitStyle(options, env);
    return `<div class="language-${lang}${active}${codeHeightLimitClass}"><button title="${options.codeCopyButtonTitle || "Copy code"}" class="copy"></button><span class="lang">${lang}</span>${rawCode}<button class="code-block-unfold-btn"></button></div>`;
  };
}

function createContainer(key, block = {}, md) {
  const classes = key;
  return [
    container,
    classes,
    {
      render(tokens, idx) {
        const token = tokens[idx];
        if (token.nesting === 1) {
          token.attrJoin("class", `${classes} custom-block`);
          const attrs = md.renderer.renderAttrs(token);
          const info = token.info.trim().slice(classes.length).trim();
          let iconTag = "";
          if (block.icon)
            iconTag = `<i class="icon ${block.icon}" ${block.color ? `style="color: ${block.color}"` : ""}></i>`;
          const title = info || `<VT content="blocks.${key}" />`;
          const titleClass = `custom-block-title${info ? "" : " custom-block-title-default"}`;
          if (classes === "details")
            return `<details ${attrs}><summary>${title}</summary>
`;
          return `<div ${attrs}><p class="${titleClass}">${iconTag}${title}</p>
`;
        } else {
          return classes === "details" ? "</details>\n" : "</div>\n";
        }
      }
    }
  ];
}
const defaultBlocksOptions = {
  tip: {
    text: "TIP"
  },
  warning: {
    text: "WARNING"
  },
  danger: {
    text: "DANGER"
  },
  info: {
    text: "INFO"
  },
  details: {
    text: "Details"
  }
};
function containerPlugin(md, containerOptions = {}) {
  const blockKeys = new Set(Object.keys(Object.assign({}, defaultBlocksOptions, containerOptions.blocks)));
  blockKeys.forEach((optionKey) => {
    const key = optionKey;
    const userOption = containerOptions.blocks?.[key] || {};
    const option = Object.assign({}, defaultBlocksOptions[key], userOption);
    md.use(...createContainer(optionKey, option, md));
  });
  md.use(container, "v-pre", {
    render: (tokens, idx) => tokens[idx].nesting === 1 ? `<div v-pre>
` : `</div>
`
  });
  md.use(container, "raw", {
    render: (tokens, idx) => tokens[idx].nesting === 1 ? `<div class="vp-raw">
` : `</div>
`
  });
  const languages = containerOptions.languages || ["zh-CN", "en"];
  languages.forEach((lang) => {
    md.use(container, lang, {
      render: (tokens, idx) => tokens[idx].nesting === 1 ? `<div lang="${lang}">
` : "</div>\n"
    });
  });
  md.use(...createCodeGroup(md));
}
function createCodeGroup(md) {
  return [
    container,
    "code-group",
    {
      render(tokens, idx) {
        if (tokens[idx].nesting === 1) {
          let tabs = "";
          let checked = "checked";
          for (let i = idx + 1; !(tokens[i].nesting === -1 && tokens[i].type === "container_code-group_close"); ++i) {
            const isHtml = tokens[i].type === "html_block";
            if (tokens[i].type === "fence" && tokens[i].tag === "code" || isHtml) {
              const title = extractTitle(
                isHtml ? tokens[i].content : tokens[i].info,
                isHtml
              );
              if (title) {
                tabs += `<input type="radio" name="group-${idx}" id="tab-${i}" ${checked}/>`;
                tabs += `<label data-title="${md.utils.escapeHtml(title)}" for="tab-${i}">${title}</label>`;
                if (checked && !isHtml)
                  tokens[i].info += " active";
                checked = "";
              }
            }
          }
          return `<div class="vp-code-group"><div class="tabs">${tabs}</div><div class="blocks">
`;
        }
        return `</div></div>
`;
      }
    }
  ];
}

function footnoteTooltipPlugin(md) {
  const originalFootnoteRef = md.renderer.rules.footnote_ref;
  const originalFootnoteOpen = md.renderer.rules.footnote_open;
  const originalFootnoteClose = md.renderer.rules.footnote_close;
  const originalFootnoteAnchor = md.renderer.rules.footnote_anchor;
  md.renderer.rules.footnote_ref = function(tokens, idx, options, env, self) {
    const originalCode = originalFootnoteRef(tokens, idx, options, env, self);
    const href = originalCode.match(/href="(.*?)"/)[0];
    const id = originalCode.match(/id="(.*?)"/)[0];
    return `<ValaxyFootnoteRef ${href} ${id}>${originalCode}</ValaxyFootnoteRef>`;
  };
  md.renderer.rules.footnote_open = function(tokens, idx, options, env, self) {
    const originalOpen = originalFootnoteOpen(tokens, idx, options, env, self);
    const id = originalOpen.match(/id="(.*?)"/)[0];
    return `<ValaxyFootnoteItem ${id}>${originalOpen}<ValaxyFootnoteContent>`;
  };
  md.renderer.rules.footnote_close = function(tokens, idx, options, env, self) {
    const originalClose = originalFootnoteClose(tokens, idx, options, env, self);
    return `</ValaxyFootnoteContent>${originalClose}</ValaxyFootnoteItem>`;
  };
  md.renderer.rules.footnote_anchor = function(tokens, idx, options, env, self) {
    const originalCode = originalFootnoteAnchor(tokens, idx, options, env, self);
    const href = originalCode.match(/href="(.*?)"/)[0];
    return `<ValaxyFootnoteAnchor ${href}>${originalCode}</ValaxyFootnoteAnchor>`;
  };
}

const RE = /\{([\d,-]+)\}/;
function highlightLinePlugin(md) {
  const fence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const [tokens, idx] = args;
    const token = tokens[idx];
    const attr = token.attrs && token.attrs[0];
    let lines = null;
    if (!attr) {
      const rawInfo = token.info;
      if (!rawInfo || !RE.test(rawInfo))
        return fence(...args);
      const langName = rawInfo.replace(RE, "").trim();
      token.info = langName;
      lines = RE.exec(rawInfo)[1];
    }
    if (!lines) {
      lines = attr[0];
      if (!lines || !/[\d,-]+/.test(lines))
        return fence(...args);
    }
    token.info += ` ${lines}`;
    return fence(...args);
  };
}

function isValidDelim(state, pos) {
  const max = state.posMax;
  let can_open = true;
  let can_close = true;
  const prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
  const nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
  if (prevChar === 32 || prevChar === 9 || /* \t */
  nextChar >= 48 && nextChar <= 57) {
    can_close = false;
  }
  if (nextChar === 32 || nextChar === 9)
    can_open = false;
  return {
    can_open,
    can_close
  };
}
function math_inline(state, silent) {
  let match, token, res, pos;
  if (state.src[state.pos] !== "$")
    return false;
  res = isValidDelim(state, state.pos);
  if (!res.can_open) {
    if (!silent)
      state.pending += "$";
    state.pos += 1;
    return true;
  }
  const start = state.pos + 1;
  match = start;
  while ((match = state.src.indexOf("$", match)) !== -1) {
    pos = match - 1;
    while (state.src[pos] === "\\") pos -= 1;
    if ((match - pos) % 2 === 1)
      break;
    match += 1;
  }
  if (match === -1) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (match - start === 0) {
    if (!silent)
      state.pending += "$$";
    state.pos = start + 1;
    return true;
  }
  res = isValidDelim(state, match);
  if (!res.can_close) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (!silent) {
    token = state.push("math_inline", "math", 0);
    token.markup = "$";
    token.content = state.src.slice(start, match);
  }
  state.pos = match + 1;
  return true;
}
function math_block(state, start, end, silent) {
  let firstLine;
  let lastLine;
  let next;
  let lastPos;
  let found = false;
  let pos = state.bMarks[start] + state.tShift[start];
  let max = state.eMarks[start];
  if (pos + 2 > max)
    return false;
  if (state.src.slice(pos, pos + 2) !== "$$")
    return false;
  pos += 2;
  firstLine = state.src.slice(pos, max);
  if (silent)
    return true;
  if (firstLine.trim().slice(-2) === "$$") {
    firstLine = firstLine.trim().slice(0, -2);
    found = true;
  }
  for (next = start; !found; ) {
    next++;
    if (next >= end)
      break;
    pos = state.bMarks[next] + state.tShift[next];
    max = state.eMarks[next];
    if (pos < max && state.tShift[next] < state.blkIndent) {
      break;
    }
    if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
      lastPos = state.src.slice(0, max).lastIndexOf("$$");
      lastLine = state.src.slice(pos, lastPos);
      found = true;
    }
  }
  state.line = next + 1;
  const token = state.push("math_block", "math", 0);
  token.block = true;
  token.content = (firstLine && firstLine.trim() ? `${firstLine}
` : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
  token.map = [start, state.line];
  token.markup = "$$";
  return true;
}
function math_plugin(md, options) {
  options = options || {};
  const katexInline = function(latex) {
    options.displayMode = false;
    try {
      return katex.renderToString(latex, options);
    } catch (error) {
      if (options.throwOnError) {
        throw error;
      }
      console.warn(error);
      return latex;
    }
  };
  const inlineRenderer = function(tokens, idx) {
    return katexInline(tokens[idx].content);
  };
  const katexBlock = function(latex) {
    options.displayMode = true;
    try {
      return `<p>${katex.renderToString(latex, options)}</p>`;
    } catch (error) {
      if (options.throwOnError) {
        throw error;
      }
      console.warn(error);
      return latex;
    }
  };
  const blockRenderer = function(tokens, idx) {
    return `${katexBlock(tokens[idx].content)}
`;
  };
  md.inline.ruler.after("escape", "math_inline", math_inline);
  md.block.ruler.after("blockquote", "math_block", math_block, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  md.renderer.rules.math_inline = inlineRenderer;
  md.renderer.rules.math_block = blockRenderer;
}

function lineNumberPlugin(md, enable = false) {
  const fence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const rawCode = fence(...args);
    const [tokens, idx] = args;
    const info = tokens[idx].info;
    if (
      // eslint-disable-next-line regexp/no-unused-capturing-group
      !enable && !/:line-numbers($| |=)/.test(info) || enable && /:no-line-numbers($| )/.test(info)
    ) {
      return rawCode;
    }
    let startLineNumber = 1;
    const matchStartLineNumber = info.match(/=(\d*)/);
    if (matchStartLineNumber && matchStartLineNumber[1])
      startLineNumber = Number.parseInt(matchStartLineNumber[1]);
    const code = rawCode.slice(
      rawCode.indexOf("<code>"),
      rawCode.indexOf("</code>")
    );
    const lines = code.split("\n");
    const lineNumbersCode = [...Array.from({ length: lines.length })].map(
      (_, index) => `<span class="line-number">${index + startLineNumber}</span><br>`
    ).join("");
    const lineNumbersWrapperCode = `<div class="line-numbers-wrapper" aria-hidden="true">${lineNumbersCode}</div>`;
    const finalCode = rawCode.replace(/<\/div>$/, `${lineNumbersWrapperCode}</div>`).replace(/"(language-[^"]*)"/, '"$1 line-numbers-mode"');
    return finalCode;
  };
}

const rawPathRegexp = /^(.+?(?:\.([a-z0-9]+))?)(#[\w-]+)?(?: ?\{(\d+(?:[,-]\d+)*)? ?(\S+)?\})? ?(?:\[(.+)\])?$/;
function rawPathToToken(rawPath) {
  const [
    filepath = "",
    extension = "",
    region = "",
    lines = "",
    lang = "",
    rawTitle = ""
  ] = (rawPathRegexp.exec(rawPath) || []).slice(1);
  const title = rawTitle || filepath.split("/").pop() || "";
  return { filepath, extension, region, lines, lang, title };
}
function dedent(text) {
  const lines = text.split("\n");
  const minIndentLength = lines.reduce((acc, line) => {
    for (let i = 0; i < line.length; i++) {
      if (line[i] !== " " && line[i] !== "	")
        return Math.min(i, acc);
    }
    return acc;
  }, Number.POSITIVE_INFINITY);
  if (minIndentLength < Number.POSITIVE_INFINITY)
    return lines.map((x) => x.slice(minIndentLength)).join("\n");
  return text;
}
function testLine(line, regexp, regionName, end = false) {
  const [full, tag, name] = regexp.exec(line.trim()) || [];
  return full && tag && name === regionName && tag.match(end ? /^[Ee]nd ?[rR]egion$/ : /^[rR]egion$/);
}
function findRegion(lines, regionName) {
  const regionRegexps = [
    /^\/\/ ?#?((?:end)?region) ([\w*-]+)$/,
    // javascript, typescript, java
    /^\/\* ?#((?:end)?region) ([\w*-]+) ?\*\/$/,
    // css, less, scss
    /^#pragma ((?:end)?region) ([\w*-]+)$/,
    // C, C++
    /^<!-- #?((?:end)?region) ([\w*-]+) -->$/,
    // HTML, markdown
    /^#(End Region) ([\w*-]+)$/,
    // Visual Basic
    /^::#(endregion) ([\w*-]+)$/,
    // Bat
    /^# ?((?:end)?region) ([\w*-]+)$/
    // C#, PHP, Powershell, Python, perl & misc
  ];
  let regexp = null;
  let start = -1;
  for (const [lineId, line] of lines.entries()) {
    if (regexp === null) {
      for (const reg of regionRegexps) {
        if (testLine(line, reg, regionName)) {
          start = lineId + 1;
          regexp = reg;
          break;
        }
      }
    } else if (testLine(line, regexp, regionName, true)) {
      return { start, end: lineId, regexp };
    }
  }
  return null;
}
function snippetPlugin(md, srcDir) {
  const parser = (state, startLine, endLine, silent) => {
    const CH = "<".charCodeAt(0);
    const pos = state.bMarks[startLine] + state.tShift[startLine];
    const max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4)
      return false;
    for (let i = 0; i < 3; ++i) {
      const ch = state.src.charCodeAt(pos + i);
      if (ch !== CH || pos + i >= max)
        return false;
    }
    if (silent)
      return true;
    const start = pos + 3;
    const end = state.skipSpacesBack(max, pos);
    const rawPath = state.src.slice(start, end).trim().replace(/^@/, srcDir).trim();
    const { filepath, extension, region, lines, lang, title } = rawPathToToken(rawPath);
    state.line = startLine + 1;
    const token = state.push("fence", "code", 0);
    token.info = `${lang || extension}${lines ? `{${lines}}` : ""}${title ? `[${title}]` : ""}`;
    const { realPath, path: _path } = state.env;
    const resolvedPath = path.resolve(path.dirname(realPath ?? _path), filepath);
    token.src = [resolvedPath, region.slice(1)];
    token.markup = "```";
    token.map = [startLine, startLine + 1];
    return true;
  };
  const fence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const [tokens, idx, , { includes }] = args;
    const token = tokens[idx];
    const [src, regionName] = token.src ?? [];
    if (!src)
      return fence(...args);
    if (includes)
      includes.push(src);
    const isAFile = fs.statSync(src).isFile();
    if (!fs.existsSync(src) || !isAFile) {
      token.content = isAFile ? `Code snippet path not found: ${src}` : `Invalid code snippet option`;
      token.info = "";
      return fence(...args);
    }
    let content = fs.readFileSync(src, "utf8");
    if (regionName) {
      const lines = content.split(/\r?\n/);
      const region = findRegion(lines, regionName);
      if (region) {
        content = dedent(
          lines.slice(region.start, region.end).filter((line) => !region.regexp.test(line.trim())).join("\n")
        );
      }
    }
    token.content = content;
    return fence(...args);
  };
  md.block.ruler.before("fence", "snippet", parser);
}

const defaultCodeTheme = { light: "github-light", dark: "github-dark" };
async function setupMarkdownPlugins(md, options, base = "/") {
  const mdOptions = options?.config.markdown || {};
  const theme = mdOptions.theme ?? defaultCodeTheme;
  const siteConfig = options?.config.siteConfig || {};
  if (mdOptions.preConfig)
    mdOptions.preConfig(md);
  md.use(highlightLinePlugin).use(preWrapperPlugin, { theme, siteConfig }).use(snippetPlugin, options?.userRoot).use(containerPlugin, {
    languages: siteConfig.languages,
    ...mdOptions?.container,
    blocks: {
      ...mdOptions.blocks,
      ...mdOptions.container?.blocks
    }
  }).use(cssI18nContainer, {
    languages: options?.config.siteConfig.languages
  }).use(
    linkPlugin,
    {
      target: "_blank",
      rel: "noreferrer",
      ...mdOptions.externalLinks
    },
    base
  );
  md.use(lineNumberPlugin, mdOptions.lineNumbers);
  if (!mdOptions.attrs?.disable)
    md.use(attrsPlugin, mdOptions.attrs);
  md.use(full).use(footnotePlugin).use(footnoteTooltipPlugin);
  md.use(anchorPlugin, {
    slugify,
    getTokensText: (tokens) => {
      return tokens.filter((t) => !["html_inline", "emoji"].includes(t.type)).map((t) => t.content).join("");
    },
    permalink: anchorPlugin.permalink.linkInsideHeader({
      symbol: "&ZeroWidthSpace;",
      renderAttrs: (slug, state) => {
        const idx = state.tokens.findIndex((token) => {
          const attrs = token.attrs;
          const id = attrs?.find((attr) => attr[0] === "id");
          return id && slug === id[1];
        });
        const title = state.tokens[idx + 1].content;
        return {
          "aria-label": `Permalink to "${title}"`
        };
      }
    }),
    ...mdOptions.anchor
  });
  md.use(headersPlugin, {
    level: [2, 3, 4, 5, 6],
    slugify,
    ...typeof mdOptions.headers === "boolean" ? void 0 : mdOptions.headers
  }).use(sfcPlugin, {
    ...mdOptions.sfc
  }).use(titlePlugin).use(tocPlugin, {
    slugify,
    ...mdOptions.toc
  });
  md.use(math_plugin, mdOptions.katex);
  const vanillaLazyload = options?.config.siteConfig.vanillaLazyload || { enable: false };
  md.use(imageFigures, {
    figcaption: true,
    // default web performance recommended settings
    lazy: true,
    async: true,
    // removeSrc and classes are required by vanilla-lazyload
    ...vanillaLazyload.enable ? {
      lazy: true,
      async: true,
      classes: "lazy"
      // when removeSrc, vite can not handle relative path
      // removeSrc in useVanillaLazyload onMounted
      // removeSrc: true,
    } : {},
    ...mdOptions.imageFigures
  });
  md.use(TaskLists);
  md.use(groupIconMdPlugin, {
    titleBar: { includeSnippet: true }
  });
  if (mdOptions.config)
    mdOptions.config(md);
  return md;
}

const version = "0.26.13";

const GLOBAL_STATE = {
  valaxyApp: void 0,
  server: void 0
};

class StateManager {
  /**
   * @zh 文章 ID 映射
   */
  idMap = /* @__PURE__ */ new Map();
}

class Valaxy {
  /**
   * version
   */
  static version = version;
  /**
   * file state
   */
  static state = new StateManager();
  constructor() {
  }
}

const KNOWN_EXTENSIONS = /* @__PURE__ */ new Set();
function treatAsHtml(filename) {
  if (KNOWN_EXTENSIONS.size === 0) {
    const extraExts = typeof process === "object" && process.env.VITE_EXTRA_EXTENSIONS || process.env?.VITE_EXTRA_EXTENSIONS || "";
    `3g2,3gp,aac,ai,apng,au,avif,bin,bmp,cer,class,conf,crl,css,csv,dll,doc,eps,epub,exe,gif,gz,ics,ief,jar,jpe,jpeg,jpg,js,json,jsonld,m4a,man,mid,midi,mjs,mov,mp2,mp3,mp4,mpe,mpeg,mpg,mpp,oga,ogg,ogv,ogx,opus,otf,p10,p7c,p7m,p7s,pdf,png,ps,qt,roff,rtf,rtx,ser,svg,t,tif,tiff,tr,ts,tsv,ttf,txt,vtt,wav,weba,webm,webp,woff,woff2,xhtml,xml,yaml,yml,zip${extraExts && typeof extraExts === "string" ? `,${extraExts}` : ""}`.split(",").forEach((ext2) => KNOWN_EXTENSIONS.add(ext2));
  }
  const ext = filename.split(".").pop();
  return ext == null || !KNOWN_EXTENSIONS.has(ext.toLowerCase());
}

function processIncludes(srcDir, src, file) {
  const includesRE = /<!--\s*@include:\s*(.*?)\s*-->/g;
  const rangeRE = /\{(\d*),(\d*)\}$/;
  return src.replace(includesRE, (m, m1) => {
    if (!m1.length)
      return m;
    const range = m1.match(rangeRE);
    range && (m1 = m1.slice(0, -range[0].length));
    const atPresent = m1[0] === "@";
    try {
      const includePath = atPresent ? path$1.join(srcDir, m1.slice(m1[1] === "/" ? 2 : 1)) : path$1.join(path$1.dirname(file), m1);
      let content = fs.readFileSync(includePath, "utf-8");
      if (range) {
        const [, startLine, endLine] = range;
        const lines = content.split(/\r?\n/);
        content = lines.slice(
          startLine ? Number.parseInt(startLine, 10) - 1 : void 0,
          endLine ? Number.parseInt(endLine, 10) : void 0
        ).join("\n");
      }
      content = `<!-- @included: ${m1} -->
${content}`;
      return processIncludes(srcDir, content, includePath);
    } catch (error) {
      return m;
    }
  });
}

const includedRE = /<!--\s*@included:\s*(.*?)\s*-->/g;
function createTransformIncludes(options) {
  const srcDir = options.userRoot;
  return (code, id) => {
    const fileOrig = id;
    return processIncludes(srcDir, code, fileOrig);
  };
}
function resolveTransformIncludes(code, id, options) {
  const includes = [];
  const dir = path.dirname(id);
  code = code.replace(includedRE, (m, m1) => {
    const atPresent = m1.startsWith("@");
    const includePath = atPresent ? path.resolve(options.userRoot, m1.slice(m1[1] === "/" ? 2 : 1)) : path.join(dir, m1);
    includes.push(slash(includePath));
    return "";
  });
  return {
    code,
    includes
  };
}

const matterOptions = {
  excerpt_separator: EXCERPT_SEPARATOR,
  engines: {
    yaml: {
      // Use the CORE_SCHEMA with more basic support to manually handle time (#409)
      parse: (str) => yaml.load(str, { schema: CORE_SCHEMA }),
      stringify: (data) => yaml.dump(data)
    }
  }
};

function transformMermaid(md) {
  md = md.replace(/^````txt\n```mermaid/gm, "````txt\n\\`\\`\\`mermaid");
  md = md.replace(/^```mermaid\s*?(\{.*?\})?\n([\s\S]+?)\n```/gm, (full, options = "", code = "") => {
    code = code.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    return `<ValaxyMermaid :code="'${encoded}'" v-bind="${options}" />`;
  });
  md = md.replace(/^````txt\n\\`\\`\\`mermaid/gm, "````txt\n```mermaid");
  return md;
}

async function createMarkdownPlugin(options) {
  const mdOptions = options?.config.markdown || {};
  const theme = mdOptions.theme ?? defaultCodeTheme;
  const transformIncludes = createTransformIncludes(options);
  const [highlight$1, dispose] = mdOptions.highlight ? [mdOptions.highlight, () => {
  }] : await highlight(theme, mdOptions, logger);
  return Markdown({
    include: [/\.md$/],
    wrapperClasses: "",
    // headEnabled: false,
    frontmatter: true,
    exportFrontmatter: false,
    frontmatterOptions: { grayMatterOptions: matterOptions },
    // v-pre
    escapeCodeTagInterpolation: true,
    markdownItOptions: {
      quotes: `""''`,
      html: true,
      xhtmlOut: true,
      linkify: true,
      highlight: highlight$1,
      ...mdOptions?.markdownItOptions
    },
    async markdownItSetup(mdIt) {
      mdIt.linkify.set({ fuzzyLink: false });
      await setupMarkdownPlugins(mdIt, options);
      options?.config.markdown?.markdownItSetup?.(mdIt);
      function initEnv(md2) {
        md2.core.ruler.push("valaxy_md_env", (state) => {
          Valaxy.state.idMap.set(state.env.id, {
            id: state.env.id,
            title: state.env.title,
            links: state.env.links,
            headers: state.env.headers,
            frontmatter: state.env.frontmatter
          });
        });
      }
      mdIt.use(initEnv);
    },
    transforms: {
      before(code, id) {
        code = transformMermaid(code);
        code = transformIncludes(code, id);
        return code;
      }
    },
    ...mdOptions
  });
}

function createFixPlugins(options) {
  const define = objectEntries(getDefine());
  return [
    {
      name: "valaxy:flags",
      enforce: "pre",
      transform(code, id) {
        if (id.match(/\.vue($|\?)/)) {
          const original = code;
          define.forEach(([from, to]) => {
            code = code.replace(new RegExp(from, "g"), to);
          });
          if (original !== code)
            return code;
        }
      }
    }
  ];
}

function createClientSetupPlugin({ clientRoot, themeRoot, userRoot }) {
  const setupEntry = slash(resolve(clientRoot, "setup"));
  return {
    name: "valaxy:setup",
    enforce: "pre",
    async transform(code, id) {
      if (id.startsWith(setupEntry)) {
        const name = id.slice(setupEntry.length + 1).replace(/\?.*$/, "");
        const imports = [];
        const injections = [];
        const setups = uniq([
          themeRoot,
          userRoot
        ]).map((i) => join(i, "setup", name));
        setups.forEach((path, idx) => {
          if (!existsSync(path))
            return;
          imports.push(`import __n${idx} from '${toAtFS(path)}'`);
          let fn = `__n${idx}`;
          if (/\binjection_return\b/.test(code))
            fn = `injection_return = ${fn}`;
          if (/\binjection_arg\b/.test(code))
            fn += "(injection_arg)";
          else
            fn += "()";
          injections.push(
            `// ${path}`,
            fn
          );
        });
        code = code.replace("/* __imports__ */", imports.join("\n"));
        code = code.replace("/* __injections__ */", injections.join("\n"));
        return code;
      }
      return null;
    }
  };
}

const jiti$1 = createJiti(import.meta.url);
function deepMerge(a, b, rootPath = "") {
  a = { ...a };
  Object.keys(b).forEach((key) => {
    if (isObject(a[key]))
      a[key] = deepMerge(a[key], b[key], rootPath ? `${rootPath}.${key}` : key);
    else if (Array.isArray(a[key]))
      a[key] = [...a[key], ...b[key]];
    else
      a[key] = b[key];
  });
  return a;
}
async function loadSetups(roots, name, arg, initial, merge = true) {
  let returns = initial;
  for (const root of roots) {
    const path = resolve(root, "setup", name);
    if (fs.existsSync(path)) {
      const setup = await jiti$1.import(path, { default: true });
      const result = await setup(arg);
      if (result !== null) {
        returns = merge ? deepMerge(returns, result) : result;
      }
    }
  }
  return returns;
}

const jiti = createJiti(import.meta.url);
async function createSafelist(options) {
  const { config } = options;
  const safeIcons = [
    "i-ri-clipboard-line",
    "i-ri-archive-line",
    "i-ri-folder-2-line",
    "i-ri-price-tag-3-line",
    "i-ri-cloud-line"
  ];
  const safelist = [
    "animate-fade-in",
    "m-auto",
    "text-left",
    "rotate-y-180",
    ...safeIcons,
    ...options.config.unocss?.safelist ?? []
  ];
  if (options.mode === "dev") {
    const { safelist: devtoolsSafelist = [] } = await import('@valaxyjs/devtools');
    safelist.push(
      ...devtoolsSafelist
    );
  }
  const siteConfig = config.siteConfig;
  if (config.markdown?.blocks) {
    const blocks = config.markdown.blocks;
    Object.entries(blocks).forEach(([_key, block]) => {
      if (block.icon)
        safelist.push(block.icon);
    });
  }
  if (siteConfig.social?.length)
    siteConfig.social.forEach((item) => safelist.push(item?.icon || ""));
  const methods = siteConfig.sponsor?.methods || [];
  if (methods.length)
    methods.forEach((item) => safelist.push(item?.icon || ""));
  return safelist;
}
async function createUnocssConfig(options) {
  const { config: pluginOptions } = options;
  const unocssConfig = {
    shortcuts: [
      ["flex-center", "flex items-center justify-center"],
      ["inline-flex-center", "inline-flex items-center justify-center"],
      ["btn", "px-4 py-1 rounded inline-block bg-$va-c-primary text-white cursor-pointer transition hover:bg-$va-c-primary-light disabled:cursor-default disabled:bg-gray-600 disabled:opacity-50"],
      ["va-card", "shadow hover:shadow-lg bg-$va-c-bg-light"]
    ],
    presets: [
      presetWind4(pluginOptions.unocssPresets?.wind4),
      presetAttributify(pluginOptions.unocssPresets?.attributify),
      presetIcons({
        scale: 1.2,
        // warn: true,
        ...pluginOptions.unocssPresets?.icons
      }),
      presetTypography(pluginOptions.unocssPresets?.typography)
      // web fonts is so big, so we disable it, let the user decide
      // presetWebFonts({
      //   fonts: {
      //     serif: [
      //       {
      //         name: 'Noto Serif SC',
      //         weights: [900],
      //       },
      //     ],
      //   },
      // }),
    ],
    rules: [
      // more see 'valaxy/client/styles/global/helper.scss'
      ["font-serif", {
        "font-family": "var(--va-font-serif)"
      }],
      ["font-sans", {
        "font-family": "var(--va-font-sans)"
      }],
      ["font-mono", {
        "font-family": "var(--va-font-mono)"
      }]
    ],
    transformers: [
      transformerDirectives(),
      transformerVariantGroup()
    ],
    safelist: await createSafelist(options)
  };
  return unocssConfig;
}
async function createUnocssPlugin(options) {
  const UnoCSS = await import('unocss/vite').then((r) => r.default);
  const { unocss: unoOptions } = options.config;
  const defaultConfig = await createUnocssConfig(options);
  const { themeRoot, clientRoot, roots } = options;
  const unoConfigFiles = ["uno.config.ts", "unocss.config.ts"];
  const configFiles = [];
  const dirs = [themeRoot, clientRoot];
  dirs.forEach(
    (dir) => unoConfigFiles.forEach(
      (file) => configFiles.push(resolve(dir, file))
    )
  );
  let config = {};
  const configDeps = [];
  for (const configFile of configFiles) {
    if (await fs.exists(configFile)) {
      const uConfig = await jiti.import(configFile, { default: true });
      config = defu(config, uConfig);
      configDeps.push(configFile);
    }
  }
  config = await loadSetups(roots, "unocss.ts", {}, config, true);
  return UnoCSS({
    configDeps,
    configFile: false,
    ...defu(unoOptions || {}, config, defaultConfig)
  });
}

function countPerformanceTime() {
  const start = performance.now();
  return () => {
    const end = performance.now();
    const duration = end - start;
    if (duration > 1e3)
      return `${(duration / 1e3).toFixed(2)}s`;
    return `${duration.toFixed(2)}ms`;
  };
}

const replaceArrMerge = createDefu((obj, key, value) => {
  if (key && obj[key] && Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = value;
    return true;
  }
});

async function loadConfigFromFile(name, options = {}) {
  const { config, configFile } = await loadConfig({
    name,
    cwd: options.cwd || process.cwd(),
    throwOnNotFound: false
  });
  let userConfig = config;
  if (typeof config === "function")
    userConfig = await config(options.valaxyOptions || {});
  return {
    config: userConfig,
    configFile
  };
}

const defaultSiteConfig = {
  mode: "auto",
  url: "/",
  lang: "en",
  languages: ["en", "zh-CN"],
  timezone: "",
  title: "Valaxy Blog",
  description: "A blog generated by Valaxy.",
  subtitle: "Next Generation Static Blog Framework.",
  author: {
    avatar: "https://valaxy.site/valaxy-logo.png",
    email: "i@valaxy.site",
    link: "https://valaxy.site",
    name: "VALAXY Developer",
    status: {
      emoji: "\u{1F30C}",
      message: "The moonlight is beautiful."
    }
  },
  favicon: "/favicon.svg",
  feed: {
    name: "",
    favicon: "/favicon.svg"
  },
  social: [],
  orderBy: "date",
  lastUpdated: false,
  license: {
    enabled: true,
    language: "",
    type: "by-nc-sa"
  },
  sponsor: {
    enable: true,
    description: "\u8FD9\u662F\u5173\u4E8E\u8D5E\u52A9\u7684\u4E00\u4E9B\u63CF\u8FF0",
    methods: []
  },
  search: {
    enable: false,
    provider: "fuse"
  },
  fuse: {
    dataPath: "valaxy-fuse-list.json",
    options: {
      keys: []
    }
  },
  comment: {
    enable: false
  },
  frontmatter: {
    time_warning: 180 * 24 * 60 * 60 * 1e3
  },
  cdn: {
    prefix: "https://unpkg.com/"
  },
  mediumZoom: {
    enable: false,
    selector: "",
    options: {}
  },
  vanillaLazyload: {
    enable: false,
    options: {}
  },
  floatingVue: options,
  statistics: {
    enable: false,
    readTime: {
      speed: {
        cn: 300,
        en: 100
      }
    }
  },
  pageSize: 7,
  encrypt: {
    enable: false,
    algorithm: "AES-CBC",
    salt: webcrypto.getRandomValues(new Uint8Array(16)),
    iv: webcrypto.getRandomValues(new Uint8Array(16))
  },
  redirects: {
    useVueRouter: true,
    rules: []
  }
};
function defineSiteConfig(config) {
  return config;
}
async function resolveSiteConfigFromRoot(root) {
  return loadConfigFromFile("site", {
    cwd: root
  });
}
async function resolveSiteConfig(root) {
  const endCount = countPerformanceTime();
  const { config: userSiteConfig, configFile: siteConfigFile } = await resolveSiteConfigFromRoot(root);
  const duration = endCount();
  if (userSiteConfig && siteConfigFile)
    consola.success(`Resolve ${colors.cyan("siteConfig")} from ${colors.dim(siteConfigFile)} ${colors.yellow(duration)}`);
  return {
    siteConfig: userSiteConfig,
    siteConfigFile
  };
}

const defaultValaxyConfig = {
  siteConfig: defaultSiteConfig,
  theme: "yun",
  themeConfig: {
    pkg: {
      name: "",
      version: ""
    }
  },
  build: {
    ssgForPagination: false
  },
  deploy: {},
  // markdown: {
  //   excerpt: '<!-- more -->',
  // },
  runtimeConfig: {
    addons: {},
    redirects: {
      useVueRouter: true,
      redirectRoutes: []
    }
  },
  modules: {
    rss: {
      enable: true,
      fullText: false,
      extractImagePathsFromHTML: true
    }
  },
  features: {
    katex: true
  },
  vite: {
    build: {
      emptyOutDir: true
      // cssCodeSplit: false,
    }
  },
  vue: {
    browserTemplateCompilation: true
  },
  devtools: true
};
function defineValaxyConfig(config) {
  return config;
}
const defineConfig = defineValaxyConfig;
async function resolveValaxyConfigFromRoot(root, options) {
  const c = await loadConfigFromFile("valaxy", {
    cwd: root,
    valaxyOptions: options
  });
  return c;
}
const mergeValaxyConfig = createDefu((obj, key, value) => {
  if (isFunction(obj[key]) && isFunction(value)) {
    obj[key] = function(...args) {
      obj[key].call(this, ...args);
      value.call(this, ...args);
    };
    return true;
  }
  if (key === "themeConfig") {
    obj[key] = replaceArrMerge(value, obj[key]);
    return true;
  }
  if (key === "vite") {
    obj[key] = mergeConfig(obj[key], value);
    return true;
  }
});
async function resolveValaxyConfig(options) {
  const configRoot = options.userRoot || process.cwd();
  const endCount = countPerformanceTime();
  const { config: userValaxyConfig, configFile } = await resolveValaxyConfigFromRoot(configRoot);
  const duration = endCount();
  if (configFile && userValaxyConfig && Object.keys(userValaxyConfig).length !== 0)
    consola.success(`Resolve ${colors.cyan("userValaxyConfig")} from ${colors.dim(configFile)} ${colors.yellow(duration)}`);
  const theme = options.theme || userValaxyConfig?.theme || "yun";
  return {
    config: userValaxyConfig,
    configFile,
    theme
  };
}

function defineValaxyAddon(addonFunc) {
  return addonFunc;
}
const defineAddon = defineValaxyAddon;
async function resolveAddonsConfig(addons, options) {
  let valaxyConfig = {};
  for (const addon of addons) {
    const addonConfigPath = path$1.resolve(addon.root, "valaxy.config.ts");
    if (!await fs.exists(addonConfigPath))
      continue;
    const { config, configFile } = await resolveValaxyConfigFromRoot(addon.root, options);
    if (!config)
      continue;
    addon.configFile = configFile;
    valaxyConfig = mergeValaxyConfig(config, valaxyConfig);
  }
  return valaxyConfig;
}

async function resolveThemeConfigFromRoot(root) {
  return loadConfigFromFile("theme", {
    cwd: root
  });
}
async function resolveUserThemeConfig(options) {
  let { config: userThemeConfig, configFile: themeConfigFile } = await resolveThemeConfigFromRoot(options.userRoot);
  if (userThemeConfig && themeConfigFile)
    logger.info(`Resolve ${colors.cyan("themeConfig")} from ${colors.dim(themeConfigFile)}`);
  if (options?.themeRoot) {
    const { config: defaultThemeConfig } = await resolveThemeConfigFromRoot(options.themeRoot);
    userThemeConfig = replaceArrMerge(userThemeConfig || {}, defaultThemeConfig);
  }
  return {
    themeConfig: userThemeConfig,
    themeConfigFile
  };
}
function defineValaxyTheme(theme) {
  return theme;
}
const defineTheme = defineValaxyTheme;

const cache$1 = /* @__PURE__ */ new Map();
const cacheTheme = /* @__PURE__ */ new Map();
function escapeRegExp(str) {
  return str.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
function isEagerChunk(id, getModuleInfo) {
  if (id.includes("node_modules") && !CSS_LANGS_RE.test(id) && staticImportedByEntry(id, getModuleInfo, cache$1)) {
    return true;
  }
}
function staticImportedByEntry(id, getModuleInfo, cache2, entryRE = null, importStack = []) {
  if (cache2.has(id)) {
    return !!cache2.get(id);
  }
  if (importStack.includes(id)) {
    cache2.set(id, false);
    return false;
  }
  const mod = getModuleInfo(id);
  if (!mod) {
    cache2.set(id, false);
    return false;
  }
  if (entryRE ? entryRE.test(id) : mod.isEntry) {
    cache2.set(id, true);
    return true;
  }
  const someImporterIs = mod.importers.some(
    (importer) => staticImportedByEntry(
      importer,
      getModuleInfo,
      cache2,
      entryRE,
      importStack.concat(id)
    )
  );
  cache2.set(id, someImporterIs);
  return someImporterIs;
}
function getRollupOptions(options) {
  const excludedModules = [
    "/@siteData",
    "node_modules/@vueuse/core/",
    "node_modules/@vueuse/shared/",
    "node_modules/vue/",
    "node_modules/vue-demi/",
    options.clientRoot
  ];
  const themeEntryRE = new RegExp(
    `^${escapeRegExp(
      path$1.resolve(options.themeRoot, "index.ts").replace(/\\/g, "/")
    )}`
  );
  const assetsDir = "assets";
  const rollupOptions = {
    ...options.config.vite?.build?.rollupOptions,
    external: [],
    // important so that each page chunk and the index export things for each
    // other
    preserveEntrySignatures: "allow-extension",
    output: {
      assetFileNames: `${assetsDir}/[name].[hash].[ext]`,
      entryFileNames: `${assetsDir}/[name].[hash].js`,
      chunkFileNames() {
        return `${assetsDir}/[name].[hash].js`;
      },
      manualChunks(id, ctx) {
        if (id.startsWith("\0vite")) {
          return "framework";
        }
        if (id.includes("plugin-vue:export-helper")) {
          return "framework";
        }
        if (id.includes("virtual:group-icons.css")) {
          return "group-icons";
        }
        const libs = [
          "@vueuse/motion",
          "dayjs",
          "vue-i18n",
          "vue-router",
          "nprogress",
          "pinia"
        ];
        for (const lib of libs) {
          if (id.includes(lib)) {
            return `chunks/${lib}`;
          }
        }
        if (isEagerChunk(id, ctx.getModuleInfo) && /@vue\/(runtime|shared|reactivity)/.test(id)) {
          return "framework";
        }
        if ((id.startsWith(options.themeRoot) || !excludedModules.some((i) => id.includes(i))) && staticImportedByEntry(
          id,
          ctx.getModuleInfo,
          cacheTheme,
          themeEntryRE
        )) {
          return "theme";
        }
      }
    }
  };
  return rollupOptions;
}

async function getModuleRoot(name, entry) {
  if (!name)
    return "";
  if (isPath(name)) {
    if (entry) {
      const isFile = fs.lstatSync(entry).isFile();
      return resolve$1(isFile ? dirname(entry) : entry, name);
    } else {
      throw new Error(`entry is required when ${name} is path`);
    }
  } else {
    return resolve$1(dirname(await resolveImportPath(`${name}/package.json`) || ""));
  }
}

async function parseAddons(addons, userRoot = process.cwd()) {
  const spinner = ora(`Resolve ${colors.cyan("addons")} from ${colors.dim(userRoot)}`).start();
  const resolvers = {};
  const mergeResolver = (resolver) => {
    if (resolver)
      resolvers[resolver.name] = defu(resolvers[resolver.name] || {}, resolver);
  };
  if (Array.isArray(addons)) {
    for (const addon of addons) {
      if (typeof addon === "string") {
        mergeResolver(await readAddonModule(addon, { cwd: userRoot }));
        continue;
      }
      if (typeof addon === "object")
        mergeResolver(defu(await readAddonModule(addon.name, { cwd: userRoot }), addon || {}));
    }
  }
  spinner.succeed();
  const resolvedAddons = Object.values(resolvers).filter((item) => item.enable);
  resolvedAddons.forEach((addon, i) => {
    const repoUrl = addon.pkg.repository?.url || addon.pkg.repository;
    const displayUrl = typeof repoUrl === "string" ? normalizeRepositoryUrl(repoUrl) : repoUrl;
    console.log(`  ${i === resolvedAddons.length - 1 ? "\u2514\u2500" : "\u251C\u2500"} ${colors.yellow(addon.name)} ${colors.blue(`v${addon.pkg?.version}`)}${addon.global ? colors.cyan(" (global)") : ""} ${colors.dim(addon.pkg.homepage || displayUrl || "")}`);
  });
  return resolvedAddons;
}
async function readAddonModule(name, options = {}) {
  const root = await getAddonRoot(name, options.cwd || process.cwd());
  const packageJSONPath = resolve$1(root, "./package.json");
  if (!await fs.exists(packageJSONPath)) {
    logger.error(`No addon named ${name} found`);
    return;
  }
  const packageJSON = await fs.readJSON(packageJSONPath);
  const resolver = {
    enable: true,
    name: packageJSON.name,
    global: !!packageJSON.global,
    root,
    options: {},
    props: {},
    pkg: packageJSON
  };
  return resolver;
}
async function getAddonRoot(name, entry) {
  const addonModule = name.startsWith("valaxy-addon") || name.startsWith(".") ? name : `valaxy-addon-${name}`;
  return await getModuleRoot(addonModule, entry);
}

function handleRoute(route) {
  if (route === "/")
    return "/index";
  if (route.endsWith("/"))
    return route.slice(0, -1);
  return route;
}
function collectRedirects(redirectRules) {
  if (!redirectRules)
    return [];
  const redirects = [];
  for (const rule of redirectRules) {
    if (Array.isArray(rule.from)) {
      for (const from of rule.from) {
        redirects.push({
          from: handleRoute(from),
          to: handleRoute(rule.to)
        });
      }
    } else {
      redirects.push({
        from: handleRoute(rule.from),
        to: handleRoute(rule.to)
      });
    }
  }
  return redirects;
}
async function writeRedirectFiles(route, filePath) {
  await fs.ensureFile(filePath);
  await fs.writeFile(filePath, `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="refresh" content="0; url=${route}">
  <link rel="canonical" href="${route}">
</head>
  <script>
    window.location.href = '${route}' + window.location.search + window.location.hash
  <\/script>
</html>
  `);
}

async function getThemeRoot(name, entry) {
  const themeModule = name.startsWith("valaxy-theme") || name.startsWith(".") ? name : `valaxy-theme-${name}`;
  return await getModuleRoot(themeModule, entry);
}

const debug$1 = _debug("valaxy:options");
async function processSiteConfig(options) {
  const { config, themeRoot, theme } = options;
  const siteConfig = config.siteConfig;
  siteConfig.url = ensureSuffix("/", siteConfig.url || "");
  siteConfig.cdn.prefix = ensureSuffix("/", siteConfig.cdn.prefix || "");
  const themePkgPath = resolve$1(themeRoot, "package.json");
  try {
    config.themeConfig.pkg = await fs.readJson(themePkgPath, "utf-8");
  } catch (e) {
    console.error(`valaxy-theme-${theme} doesn't have package.json`);
  }
}
async function processValaxyOptions(valaxyOptions, valaxyConfig) {
  const { clientRoot, themeRoot, userRoot } = valaxyOptions;
  const addons = await parseAddons(valaxyConfig.addons || [], valaxyOptions.userRoot);
  const addonsValaxyConfig = await resolveAddonsConfig(addons, valaxyOptions);
  valaxyConfig = mergeValaxyConfig(valaxyConfig, addonsValaxyConfig);
  const rollupOptions = getRollupOptions(valaxyOptions);
  defaultValaxyConfig.vite.build.rollupOptions = rollupOptions;
  const config = replaceArrMerge(valaxyConfig, defaultValaxyConfig);
  valaxyOptions.config = {
    ...config,
    runtimeConfig: {
      addons: {},
      redirects: {
        useVueRouter: true,
        redirectRoutes: []
      }
    }
  };
  valaxyOptions.addons = addons;
  addons.forEach((addon) => {
    valaxyOptions.config.runtimeConfig.addons[addon.name] = addon;
  });
  const addonRoots = addons.map(({ root }) => root);
  const addonNames = addons.map(({ name }) => name);
  valaxyOptions.addonRoots = addonRoots;
  valaxyOptions.roots = uniq([clientRoot, themeRoot, ...addonRoots, userRoot]);
  const external = valaxyOptions.config.vite?.build?.rollupOptions?.external || [];
  valaxyOptions.config.vite.build.rollupOptions.external = external.filter((name) => !addonNames.includes(name));
  await processSiteConfig(valaxyOptions);
  return valaxyOptions;
}
async function resolveOptions(options = { userRoot: process.cwd() }, mode = "dev") {
  const pkgRoot = dirname(await resolveImportPath("valaxy/package.json", true));
  const clientRoot = resolve$1(pkgRoot, "client");
  const userRoot = resolve$1(options.userRoot || process.cwd());
  consola.start(`Resolve ${colors.magenta("valaxy")} config ...`);
  const [resolvedValaxy, resolvedSite, resolvedTheme, pages] = await Promise.all([
    resolveValaxyConfig(options),
    resolveSiteConfig(options.userRoot),
    // resolveThemeConfig(options),
    resolveThemeConfigFromRoot(options.userRoot),
    fg(["**.md"], {
      cwd: resolve$1(userRoot, "pages"),
      ignore: ["**/node_modules"]
    })
  ]);
  let { config: userValaxyConfig, configFile, theme } = resolvedValaxy;
  const themeRoot = await getThemeRoot(theme, options.userRoot);
  const { siteConfig, siteConfigFile } = resolvedSite;
  const { config: themeConfig, configFile: themeConfigFile } = resolvedTheme;
  const redirects = collectRedirects(siteConfig.redirects?.rules);
  userValaxyConfig = replaceArrMerge({ siteConfig }, { themeConfig }, userValaxyConfig);
  let valaxyOptions = {
    mode,
    pkgRoot,
    tempDir: resolve$1(userRoot, ".valaxy"),
    clientRoot,
    userRoot,
    themeRoot,
    addonRoots: [],
    roots: [],
    theme,
    config: {
      ...userValaxyConfig,
      runtimeConfig: {
        addons: {},
        redirects: {
          useVueRouter: true,
          redirectRoutes: []
        }
      }
    },
    configFile: configFile || "",
    siteConfigFile: siteConfigFile || "",
    themeConfigFile: themeConfigFile || "",
    pages: pages.sort(),
    addons: [],
    redirects,
    env: {
      id: "",
      links: []
    }
  };
  debug$1(valaxyOptions);
  const themeValaxyConfig = await resolveThemeValaxyConfig(valaxyOptions);
  const valaxyConfig = mergeValaxyConfig(userValaxyConfig, themeValaxyConfig);
  valaxyOptions = await processValaxyOptions(valaxyOptions, valaxyConfig);
  fs.ensureDirSync(valaxyOptions.tempDir);
  return valaxyOptions;
}
async function resolveThemeValaxyConfig(options) {
  const endCount = countPerformanceTime();
  const { config: themeValaxyConfig } = await resolveValaxyConfigFromRoot(options.themeRoot, options);
  const duration = endCount();
  if (themeValaxyConfig)
    consola.success(`Resolve ${colors.cyan("valaxy.config.ts")} from ${colors.blue(`theme(${options.theme})`)} ${colors.yellow(duration)}`);
  return themeValaxyConfig;
}

const templateAddons = {
  id: "/@valaxyjs/addons",
  async getContent(options) {
    const globalAddonComponents = options.addons.filter((v) => v.global).filter((v) => fs.existsSync(join$1(v.root, "./App.vue")));
    const spliceImportName = (str) => `Addon${pascalCase(str)}App`;
    const imports = globalAddonComponents.map((addon) => `import ${spliceImportName(addon.name)} from "${addon.name}/App.vue"`).join("\n");
    const components = globalAddonComponents.map((addon) => `{ component: ${spliceImportName(addon.name)}, props: ${JSON.stringify(addon.props)} }`).join(",");
    return `${imports}
export default [${components}]`;
  }
};

function createBlogTemplate(name) {
  return {
    id: `/@valaxyjs/blog/${name}s`,
    async getContent({ userRoot }) {
      const root = path$1.resolve(userRoot, "pages", "collections");
      if (!await fs.pathExists(root)) {
        return `export default []`;
      }
      const isDir = (file) => fs.statSync(path$1.join(root, file)).isDirectory();
      const files = fs.readdirSync(root).filter((file) => isDir(file)).map((file) => path$1.join(root, file, "index.ts"));
      const imports = [];
      const getImportedName = (idx) => `__valaxy_${name}_${idx + 1}`;
      files.forEach((file, idx) => {
        const importedName = getImportedName(idx);
        imports.push(`import ${importedName} from '${toAtFS(file)}'`);
      });
      imports.push(`export default [${files.map((_, idx) => getImportedName(idx)).join(", ")}]`);
      return imports.join("\n");
    }
  };
}
const configs = [
  "collection"
];
const templateBlogs = configs.map(createBlogTemplate);

function isProd() {
  return process.env.NODE_ENV === "production";
}
function setEnv(env = "development") {
  process.env.NODE_ENV = env;
  consola.level = isProd() ? 2 : 3;
  logger.level = consola.level;
}
function setEnvProd() {
  return setEnv("production");
}
function setTimezone(timezone) {
  process.env.TZ = timezone;
}
async function isPagesDirExist(root) {
  const exist = await fs.exists(path$1.resolve(root, "pages"));
  if (!exist)
    logger.error(`No pages directory found in ${root}`);
  return exist;
}

const templateConfig = {
  id: "/@valaxyjs/config",
  async getContent(options) {
    const routes = options.redirects.map((redirect) => {
      return {
        path: redirect.from,
        redirect: redirect.to
      };
    });
    options.config.runtimeConfig.redirects = {
      useVueRouter: isProd() ? options.config.siteConfig.redirects.useVueRouter : true,
      redirectRoutes: routes
    };
    return `export default ${JSON.stringify(JSON.stringify(options.config))}`;
  }
};

const templateLocales = {
  id: "/@valaxyjs/locales",
  async getContent({ roots, config }) {
    const imports = [
      'import { createDefu } from "defu"',
      'const messages = { "zh-CN": {}, en: {} }',
      `
  const replaceArrMerge = createDefu((obj, key, value) => {
    if (key && obj[key] && Array.isArray(obj[key]) && Array.isArray(value)) {
      obj[key] = value
      return true
    }
  })
  `
    ];
    const languages = config.siteConfig.languages || ["zh-CN", "en"];
    roots.forEach((root, i) => {
      languages.forEach((lang) => {
        const langYml = `${root}/locales/${lang}.yml`;
        if (fs.existsSync(langYml) && fs.readFileSync(langYml, "utf-8")) {
          const varName = lang.replace("-", "") + i;
          imports.unshift(`import ${varName} from "${toAtFS(langYml)}"`);
          imports.push(`messages['${lang}'] = replaceArrMerge(${varName}, messages['${lang}'])`);
        }
      });
    });
    imports.push("export default messages");
    return imports.join("\n");
  }
};

const templateStyles = {
  id: "/@valaxyjs/styles",
  async getContent({ clientRoot, roots, config }) {
    function resolveUrlOfClient(name) {
      return toAtFS(join(clientRoot, name));
    }
    const imports = [];
    if (config.features?.katex) {
      imports.push(`import "${await resolveImportUrl("katex/dist/katex.min.css")}"`);
      imports.push(`import "${resolveUrlOfClient("styles/third/katex.scss")}"`);
    }
    for (const root of roots) {
      const styles = [
        join(root, "styles", "index.ts"),
        join(root, "styles", "index.css"),
        join(root, "styles", "index.scss")
      ];
      for (const style of styles) {
        if (existsSync(style)) {
          imports.push(`import "${toAtFS(style)}"`);
          continue;
        }
      }
    }
    imports.unshift(`import "${await resolveImportUrl("@unocss/reset/tailwind-compat.css")}"`);
    return imports.join("\n");
  }
};

const templates = [
  templateAddons,
  templateConfig,
  templateLocales,
  templateStyles,
  ...templateBlogs
];

const buildHooks = [
  "build:before",
  "build:after"
];
function createValaxyNode(options) {
  const hooks = createHooks();
  if (typeof options.config.hooks === "object") {
    Object.keys(options.config.hooks).forEach((name) => {
      const hookName = name;
      const hook = options.config.hooks[hookName];
      if (typeof hook !== "function")
        return;
      if (buildHooks.includes(hookName)) {
        if (options.mode === "build")
          hooks.hook(hookName, hook);
      } else {
        hooks.hook(hookName, hook);
      }
    });
  }
  const valaxyNode = {
    version,
    hooks,
    hook: hooks.hook,
    options
  };
  options.addons.forEach((addon) => {
    if (typeof addon.setup === "function")
      addon.setup(valaxyNode);
  });
  return valaxyNode;
}

function handleCodeHeightLimit(mainContentMd, options, codeHeightLimit) {
  if (typeof codeHeightLimit !== "number" || codeHeightLimit <= 0)
    return mainContentMd;
  const siteConfigLimit = options.config.siteConfig.codeHeightLimit;
  mainContentMd = mainContentMd.replaceAll(/<div.+class="language-\w+">/g, (matchStr) => {
    if (siteConfigLimit !== void 0 && siteConfigLimit > 0)
      matchStr = matchStr.replace(/\d+/, codeHeightLimit.toString());
    else matchStr = `${matchStr.slice(0, 5)}style="max-height: ${codeHeightLimit}px;"${matchStr.slice(5)}`;
    return matchStr;
  });
  return mainContentMd;
}
function createTransformCodeBlock(options) {
  return (code, id) => {
    const fileInfo = Valaxy.state.idMap.get(id);
    return handleCodeHeightLimit(code, options, fileInfo?.frontmatter.codeHeightLimit);
  };
}

function createScanDeadLinks(options) {
  const srcDir = path.resolve(options.userRoot, "pages");
  const { ignoreDeadLinks } = options.config.build;
  const publicDir = options.config.vite?.publicDir || "public";
  return (code, id) => {
    const fileInfo = Valaxy.state.idMap.get(id);
    const { links = [] } = fileInfo || {};
    const fileOrig = id;
    const file = id;
    const deadLinks = [];
    const recordDeadLink = (url) => {
      deadLinks.push({ url, file: path.relative(srcDir, fileOrig) });
    };
    function shouldIgnoreDeadLink(url) {
      if (!ignoreDeadLinks)
        return false;
      if (ignoreDeadLinks === true)
        return true;
      if (ignoreDeadLinks === "localhostLinks")
        return url.replace(EXTERNAL_URL_RE, "").startsWith("//localhost");
      return ignoreDeadLinks.some((ignore) => {
        if (typeof ignore === "string")
          return url === ignore;
        if (ignore instanceof RegExp)
          return ignore.test(url);
        if (typeof ignore === "function")
          return ignore(url);
        return false;
      });
    }
    if (links) {
      const dir = path.dirname(file);
      for (let url of links) {
        const { pathname } = new URL(url, "http://a.com");
        if (!treatAsHtml(pathname))
          continue;
        url = url.replace(/[?#].*$/, "").replace(/\.(html|md)$/, "");
        if (url.endsWith("/"))
          url += `index`;
        const resolved = decodeURIComponent(
          slash(
            url.startsWith("/") ? url.slice(1) : path.relative(srcDir, path.resolve(dir, url))
          )
          // /index => /
        ).replace(/\/index$/, "");
        if (!options.pages.includes(resolved) && !fs.existsSync(path.resolve(dir, publicDir, `${resolved}.html`)) && !shouldIgnoreDeadLink(url)) {
          recordDeadLink(url);
        }
      }
    }
    return deadLinks;
  };
}

function createTransformEncrypt(options) {
  const { config: { siteConfig: { encrypt } } } = options;
  return async (code, id, pageData) => {
    const { frontmatter = {} } = pageData;
    if (encrypt.enable) {
      let getValaxyDecryptTemplate = function(options2) {
        return [
          "<ClientOnly>",
          `<ValaxyDecrypt :encrypted-content="${options2.encryptedContent}" hint="${options2.hint || ""}" />`,
          "</ClientOnly>"
        ].join("");
      };
      const encryptRegexp = /<!-- valaxy-encrypt-start:(?<password>\w+) -->(?<content>.*?)<!-- valaxy-encrypt-end -->/gs;
      const encryptCommentRegexp = /((<!-- valaxy-encrypt-start:\w+ -->)|(<!-- valaxy-encrypt-end -->))/g;
      if (frontmatter.password) {
        code = code.replaceAll(encryptCommentRegexp, "");
      } else {
        const partiallyEncryptedContents = [];
        for (const matchArr of code.matchAll(encryptRegexp)) {
          partiallyEncryptedContents.push(
            await encryptContent(matchArr.groups.content, {
              password: matchArr.groups.password,
              iv: encrypt.iv,
              salt: encrypt.salt
            })
          );
        }
        let i = 0;
        if (partiallyEncryptedContents.length) {
          frontmatter.partiallyEncryptedContents = partiallyEncryptedContents;
          code = code.replaceAll(encryptRegexp, () => {
            const partiallyEncryptedContents2 = `$partiallyEncryptedContents`;
            const content = `${partiallyEncryptedContents2}[${i++}]`;
            return getValaxyDecryptTemplate({
              encryptedContent: content,
              hint: frontmatter.password_hint || ""
            });
          });
        }
      }
      if (frontmatter.password) {
        const templateStart = code.indexOf("<template>");
        const templateEnd = code.lastIndexOf("</template>");
        const content = code.slice(templateStart + 10, templateEnd);
        const encryptedContent = await encryptContent(content, {
          password: frontmatter.password,
          iv: encrypt.iv,
          salt: encrypt.salt
        });
        frontmatter.encryptedContent = encryptedContent;
        frontmatter.encrypt = true;
        delete frontmatter.password;
        const encryptedContentStr = "$encryptedContent";
        code = code.replace(content, getValaxyDecryptTemplate({
          encryptedContent: encryptedContentStr,
          hint: frontmatter.password_hint
        }));
        const scriptSetupStart = code.lastIndexOf("<script setup>");
        const scriptSetupEnd = code.lastIndexOf("<\/script>");
        const scriptSetupContent = code.slice(scriptSetupStart + 14, scriptSetupEnd);
        code = code.replace(scriptSetupContent, "");
      }
      if (frontmatter.gallery_password) {
        const encryptedPhotos = await encryptContent(JSON.stringify(frontmatter.photos), {
          password: frontmatter.gallery_password,
          iv: encrypt.iv,
          salt: encrypt.salt
        });
        frontmatter.encryptedPhotos = encryptedPhotos;
        delete frontmatter.gallery_password;
        delete frontmatter.photos;
      }
    }
    return code;
  };
}

function transformFootnoteTooltip(code, _id) {
  const footnoteContentMap = /* @__PURE__ */ new Map();
  return code.replace(/<ValaxyFootnoteItem id="(.*?)">(.*?)<\/ValaxyFootnoteItem>/gs, (_, id, content) => {
    const tooltipContent = content.match(/<ValaxyFootnoteContent>(.*?)<\/ValaxyFootnoteContent>/s)[1].replace(/<ValaxyFootnoteAnchor.*?>(.*?)<\/ValaxyFootnoteAnchor>/gs, "");
    const itemContent = content.replace(/<ValaxyFootnoteContent>(.*?)<\/ValaxyFootnoteContent>/gs, (_2, content2) => content2).replace(/<ValaxyFootnoteAnchor.*?>(.*?)<\/ValaxyFootnoteAnchor>/gs, (_2, anchor) => anchor);
    footnoteContentMap.set(id, tooltipContent);
    return itemContent;
  }).replace(/<ValaxyFootnoteRef href="#(.*?)".*?>(.*?)<\/ValaxyFootnoteRef>/gs, (_, href, content) => {
    return `<ValaxyFootnoteTooltip>${content}<template #popper>${footnoteContentMap.get(href)}</template></ValaxyFootnoteTooltip>`;
  });
}

function transformHexoTags(code, id) {
  if (code.includes("{%") && code.includes("%}")) {
    consola.error(
      `${`${id}
`}        Please ${colors.red("remove")} ${colors.cyan("{% %}")}, because it conflicts with ${colors.yellow("markdown-it-attrs")}.`
    );
  }
  code = code.replaceAll("{%", "\\{\\%");
  code = code.replaceAll("%}", "\\%\\}");
  return code;
}

function genProvideCode(name, data) {
  return [
    `const $${name} = ${transformObject(data)}`,
    `route.meta.$${name} = $${name}`,
    `provide('valaxy:${name}', $${name})`
  ];
}
const encryptedKeys = ["encryptedContent", "partiallyEncryptedContents", "encryptedPhotos"];
function injectPageDataCode(pageData) {
  const vueContextImports = [
    `import { provide } from 'vue'`,
    `import { useRoute, useRouter } from 'vue-router'`,
    "const { data: pageData } = usePageData()",
    "const router = useRouter()",
    "const route = useRoute()",
    // $frontmatter contain runtime added data, will be deleted (for example, $frontmatter.partiallyEncryptedContents)
    `const $frontmatter = Object.assign(route.meta.frontmatter || {}, pageData.value?.frontmatter || {})
    router.currentRoute.value.data = pageData.value

    provide('valaxy:frontmatter', $frontmatter)
    `
  ];
  for (const key of encryptedKeys) {
    if (pageData.frontmatter[key]) {
      vueContextImports.push(...genProvideCode(key, pageData.frontmatter[key]));
    }
  }
  return vueContextImports;
}
function createTransformMarkdown(options) {
  const loaderVuePath = path$1.resolve(options.clientRoot, "templates", "loader.vue");
  const loaderVue = fs.readFileSync(loaderVuePath, "utf-8");
  return (code, id, pageData) => {
    const isDev = options.mode === "dev";
    if (!isDev) {
      delete pageData.filePath;
    }
    const dataCode = injectPageDataCode(pageData);
    const imports = [
      ...dataCode,
      isDev ? `globalThis.$pageData = pageData` : "",
      "globalThis.$frontmatter = $frontmatter"
    ];
    encryptedKeys.forEach((key) => {
      delete pageData.frontmatter[key];
    });
    const pagePath = pageData.relativePath.slice("/pages".length - 1, -".md".length);
    const customDataLoader = loaderVue.replace("/relativePath", pagePath.endsWith("index") ? pagePath.replace(/\/index$/, "") : pagePath).replace("// custom basic loader", `return ${transformObject(pageData)}`);
    code = customDataLoader + code;
    const scriptSetupStart = code.indexOf("<script setup>");
    if (scriptSetupStart !== -1)
      code = code.slice(0, scriptSetupStart + "<script setup>".length) + imports.join("\n") + code.slice(scriptSetupStart + 14);
    else
      code = `<script setup>
${imports.join("\n")}
<\/script>
${code}`;
    const injectA = code.indexOf("<template>") + "<template>".length;
    const injectB = code.lastIndexOf("</template>");
    let body = code.slice(injectA, injectB).trim();
    if (body.startsWith("<div>") && body.endsWith("</div>"))
      body = body.slice(5, -6);
    code = `${code.slice(0, injectA)}
${getValaxyMain(body)}
${code.slice(injectB)}`;
    return code;
  };
}

function getHeadMetaContent(head, name) {
  if (!head || !head.length)
    return void 0;
  const meta = head.find(([tag, attrs = {}]) => {
    return tag === "meta" && attrs.name === name && attrs.content;
  });
  return meta && meta[1].content;
}
function inferDescription(frontmatter) {
  const { description, head } = frontmatter;
  if (description !== void 0)
    return description;
  return head && getHeadMetaContent(head, "description") || "";
}
async function generatePageData(code, id, options) {
  const fileInfo = Valaxy.state.idMap.get(id);
  const relativePath = path.relative(options.userRoot, id);
  const fm = JSON.parse(JSON.stringify(fileInfo?.frontmatter));
  const pageData = {
    title: fm.title || fileInfo?.title || "",
    titleTemplate: fm.titleTemplate,
    description: inferDescription(fm),
    frontmatter: fm,
    // not be used
    headers: fileInfo?.headers || [],
    relativePath,
    filePath: id
  };
  pageData.lastUpdated = await getGitTimestamp(id);
  return pageData;
}

const debug = _debug("valaxy:md");
const cache = new LRUCache({ max: 128 });
function generateSlots() {
  const slots = [
    "main-header",
    "main-header-after",
    "main-nav",
    "main-content-before",
    "main-content",
    "main-content-after",
    "main-nav-before",
    "main-nav-after",
    "comment",
    "footer",
    "aside",
    "aside-custom"
  ];
  const slotsText = slots.map((s) => `<template #${s}><slot name="${s}" /></template>`).join("");
  return slotsText;
}
function getValaxyMain(mainContentMd) {
  const pageComponent = "ValaxyMain";
  return `
<${pageComponent} :frontmatter="$frontmatter">
  <template #main-content-md>${mainContentMd}</template>
  ${generateSlots()}
  <slot />
</${pageComponent}>
`;
}
async function createMarkdownToVueRenderFn(options, _viteConfig) {
  options.pages = options.pages.map((p) => p.replace(/\.md$/, "").replace(/\/index$/, ""));
  const transformCodeBlock = createTransformCodeBlock(options);
  const transformMarkdown = createTransformMarkdown(options);
  const transformEncrypt = createTransformEncrypt(options);
  const scanDeadLinks = createScanDeadLinks(options);
  const srcDir = options.userRoot;
  const isBuild = options.mode === "build";
  return async (code, id) => {
    const file = id;
    const relativePath = path.relative(srcDir, file);
    const deadLinks = scanDeadLinks(code, id);
    const cacheKey = JSON.stringify({ code, id });
    if (isBuild) {
      const cacheKey2 = JSON.stringify({ code, id });
      const cached = cache.get(cacheKey2);
      if (cached) {
        debug(`[cache hit] ${relativePath}`);
        return cached;
      }
    }
    const start = Date.now();
    const pageData = await generatePageData(code, id, options);
    code = transformHexoTags(code, id);
    const data = resolveTransformIncludes(code, id, options);
    const includes = data.includes;
    code = data.code;
    code = transformCodeBlock(code, id);
    code = await transformEncrypt(code, id, pageData);
    code = transformFootnoteTooltip(code);
    code = transformMarkdown(code, id, pageData);
    debug(`[render] ${file} in ${Date.now() - start}ms.`);
    const result = {
      code,
      pageData,
      deadLinks,
      includes
    };
    if (isBuild)
      cache.set(cacheKey, result);
    Valaxy.state.idMap.delete(id);
    return result;
  };
}

const nullVue = 'import { defineComponent } from "vue"; export default defineComponent({ render: () => null });';
function generateAppVue(root) {
  const appVue = join$1(root, "App.vue");
  if (!fs.existsSync(appVue))
    return nullVue;
  const scripts = [
    `import AppVue from "${toAtFS(appVue)}"`,
    "export default AppVue"
  ];
  return scripts.join("\n");
}
async function createValaxyPlugin(options, serverOptions = {}) {
  let { config: valaxyConfig } = options;
  const valaxyPrefix = "/@valaxy";
  let hasDeadLinks = false;
  let markdownToVue;
  return [
    {
      name: "valaxy:loader",
      enforce: "pre",
      async configResolved(resolvedConfig) {
        markdownToVue = await createMarkdownToVueRenderFn(
          options);
      },
      configureServer(server) {
        if (options.configFile) {
          server.watcher.add(options.configFile);
        }
        server.watcher.add([
          options.clientRoot,
          options.themeRoot,
          options.userRoot
        ]);
      },
      resolveId(id) {
        if (id.startsWith(valaxyPrefix))
          return id;
        return null;
      },
      async load(id) {
        const template = templates.find((t) => t.id === id);
        if (template) {
          return {
            code: await template.getContent.call(this, options),
            map: { mappings: "" }
          };
        }
        if (id === "/@valaxyjs/context") {
          return `export default ${JSON.stringify(JSON.stringify({
            userRoot: options.userRoot
            // clientRoot: options.clientRoot,
          }))}`;
        }
        if (id === "/@valaxyjs/AppVue")
          return generateAppVue(options.clientRoot);
        if (id === "/@valaxyjs/UserAppVue")
          return generateAppVue(options.userRoot);
        if (id === "/@valaxyjs/ThemeAppVue")
          return generateAppVue(options.themeRoot);
        if (id.startsWith(valaxyPrefix)) {
          return {
            code: "",
            map: { mappings: "" }
          };
        }
      },
      async transform(code, id) {
        if (id.endsWith(".md")) {
          const { code: newCode, deadLinks, includes } = await markdownToVue(code, id);
          if (deadLinks.length) {
            hasDeadLinks = true;
            consola.error(`Dead links found in ${id}`);
            consola.error(deadLinks);
          }
          if (includes.length) {
            includes.forEach((i) => {
              this.addWatchFile(i);
            });
          }
          return newCode;
        }
      },
      renderStart() {
        if (hasDeadLinks && !(valaxyConfig.ignoreDeadLinks || valaxyConfig.build.ignoreDeadLinks))
          throw new Error("One or more pages contain dead links.");
      },
      /**
       * handle config hmr
       * @param ctx
       */
      async handleHotUpdate(ctx) {
        const { file, server, read } = ctx;
        const reloadConfigAndEntries = (config) => {
          serverOptions.onConfigReload?.(config, options.config);
          Object.assign(options.config, config);
          valaxyConfig = config;
          const moduleIds = ["/@valaxyjs/config", "/@valaxyjs/context"];
          const moduleEntries = [
            ...Array.from(moduleIds).map((id) => server.moduleGraph.getModuleById(id))
          ].filter((item) => !!item);
          return moduleEntries;
        };
        const configFiles = [options.configFile];
        if (configFiles.includes(file)) {
          const { config } = await resolveOptions({ userRoot: options.userRoot });
          return reloadConfigAndEntries(config);
        }
        if (file === options.siteConfigFile) {
          const { siteConfig } = await resolveSiteConfig(options.userRoot);
          valaxyConfig.siteConfig = replaceArrMerge(siteConfig, defaultSiteConfig);
          return reloadConfigAndEntries(valaxyConfig);
        }
        if (file === options.themeConfigFile) {
          const { themeConfig } = await resolveUserThemeConfig(options);
          const pkg = valaxyConfig.themeConfig.pkg;
          themeConfig.pkg = pkg;
          valaxyConfig.themeConfig = themeConfig;
          return reloadConfigAndEntries(valaxyConfig);
        }
        if (file === resolve$1(options.themeRoot, "valaxy.config.ts")) {
          const themeValaxyConfig = await resolveThemeValaxyConfig(options);
          const valaxyConfig2 = mergeValaxyConfig(options.config, themeValaxyConfig);
          const { config } = await processValaxyOptions(options, valaxyConfig2);
          return reloadConfigAndEntries(config);
        }
        if (file.endsWith(".md")) {
          const endCount = countPerformanceTime();
          const content = await read();
          const { code, pageData } = await markdownToVue(content, file);
          const path = `/${relative(`${options.userRoot}/pages`, file)}`;
          const payload = {
            path,
            pageData
          };
          server.hot.send({
            type: "custom",
            event: "valaxy:pageData",
            data: payload
          });
          vLogger.success(`${colors.yellow("[HMR]")} ${file} ${colors.dim(`updated in ${endCount()}`)}`);
          ctx.read = () => code;
        }
      }
    }
    // {
    //   // we need post encrypt html
    //   name: 'valaxy:encrypt:post',
    //   enforce: 'pre',
    //   async transform(code, id) {
    //     if (id.endsWith('.md'))
    //       code = await transformEncrypt(code, id)
    //     return code
    //   },
    // },
  ];
}

function count(content) {
  const cn = (content.match(/[\u4E00-\u9FA5]/g) || []).length;
  const en = (content.replace(/[\u4E00-\u9FA5]/g, "").match(/[\w\u0392-\u03C9\u0400-\u04FF]+|[\u4E00-\u9FFF\u3400-\u4DBF\uF900-\uFAFF\u3040-\u309F\uAC00-\uD7AF\u0400-\u04FF]+|[\u00E4\u00C4\u00E5\u00C5\u00F6\u00D6]+/g) || []).length;
  return {
    cn,
    en
  };
}
function readTime({ cn, en }, options) {
  const readingTime = cn / (options.speed.cn || 300) + en / (options.speed.en || 100);
  return readingTime < 1 ? 1 : Math.ceil(readingTime);
}
function wordCount({ cn, en }) {
  const num = cn + en;
  if (num < 1e3)
    return num.toString();
  return `${Math.round(num / 100) / 10}k`;
}
function statistics(content, options) {
  const countData = count(content);
  return {
    countData,
    wordCount: wordCount(countData),
    readingTime: readTime(countData, options.readTime)
  };
}
function presetStatistics({
  route,
  options
}) {
  const absolutePath = route.components.get("default") || "";
  if (existsSync(absolutePath)) {
    const file = readFileSync(absolutePath, "utf-8");
    const { wordCount: wordCount2, readingTime } = statistics(file, {
      readTime: Object.assign({
        speed: {
          cn: 300,
          en: 100
        }
      }, options.readTime)
    });
    if (route.meta.frontmatter) {
      if (!route.meta.frontmatter.wordCount)
        route.meta.frontmatter.wordCount = wordCount2;
      if (!route.meta.frontmatter.readingTime)
        route.meta.frontmatter.readingTime = readingTime;
    }
  }
}

function getExcerptByType(excerpt = "", type = "html", mdIt) {
  switch (type) {
    case "ai":
    case "md":
      return excerpt;
    case "html":
      return mdIt.render(excerpt);
    case "text":
      return convert(mdIt.render(excerpt));
    default:
      return excerpt;
  }
}
async function createRouterPlugin(valaxyApp) {
  const { options } = valaxyApp;
  const { roots, config: valaxyConfig } = options;
  const mdIt = new MarkdownItAsync({ html: true });
  await setupMarkdownPlugins(mdIt, options);
  return VueRouter({
    extensions: [".vue", ".md"],
    routesFolder: roots.map((root) => `${root}/pages`),
    dts: resolve$1(options.tempDir, "typed-router.d.ts"),
    ...valaxyConfig.router,
    /**
     * @experimental See https://github.com/posva/unplugin-vue-router/issues/43
     * we need get frontmatter before route, so write it in extendRoute
     */
    async extendRoute(route) {
      const defaultFrontmatter = JSON.parse(JSON.stringify(valaxyConfig.siteConfig.frontmatter)) || {};
      if (route.meta && route.meta.frontmatter) {
        const { frontmatter: _, otherMeta } = route.meta;
        route.meta = otherMeta;
      }
      route.addToMeta({
        frontmatter: defaultFrontmatter
      });
      if (route.fullPath === "/" || route.fullPath === "/page") {
        route.addToMeta({
          layout: "home"
        });
      }
      if (["/posts", "/posts/"].includes(route.fullPath)) {
        route.addToMeta({
          layout: "posts"
        });
      } else if (route.fullPath.startsWith("/posts/")) {
        if (route.children.length === 0) {
          route.addToMeta({
            layout: "post"
          });
        }
      } else if (route.fullPath.startsWith("/collections/")) {
        if (route.fullPath.split("/").length > 3) {
          route.addToMeta({
            layout: "collection"
          });
        }
      }
      const path = route.components.get("default") || "";
      if (path.endsWith(".md")) {
        const md = fs.readFileSync(path, "utf-8");
        const { data, excerpt, content } = matter(md, matterOptions);
        const mdFm = data;
        const lastUpdated = options.config.siteConfig.lastUpdated;
        delete mdFm.password;
        if (mdFm.gallery_password) {
          delete mdFm.gallery_password;
          delete mdFm.photos;
        }
        if (!mdFm.date)
          mdFm.date = (await fs.stat(path)).mtime;
        if (lastUpdated) {
          if (!mdFm.updated)
            mdFm.updated = (await fs.stat(path)).ctime;
        }
        if (mdFm.from) {
          if (Array.isArray(mdFm.from)) {
            mdFm.from.forEach((from) => {
              options.redirects.push({
                from,
                to: route.fullPath
              });
            });
          } else {
            options.redirects.push({
              from: mdFm.from,
              to: route.fullPath
            });
          }
        }
        const excludeKeys = [
          "albums",
          "excerpt",
          "girls",
          "links",
          "photos"
          // @TODO defineBasicLoader for page
          // 'projects',
        ];
        const routerFM = {
          ...mdFm,
          // 主题有新的字段需要主动设置
          // @TODO 添加文档和配置项，或者反过来允许用户自行优化
          tags: typeof mdFm.tags === "string" ? [mdFm.tags] : mdFm.tags
        };
        excludeKeys.forEach((key) => {
          delete routerFM[key];
        });
        route.addToMeta({
          frontmatter: routerFM,
          excerpt: mdFm.excerpt || (excerpt ? getExcerptByType(excerpt, mdFm.excerpt_type || defaultFrontmatter.excerpt_type, mdIt) : "")
        });
        if (data.layout) {
          route.addToMeta({
            layout: data.layout
          });
        }
        if (!route.meta.frontmatter?.updated)
          route.meta.frontmatter.updated = mdFm.date;
        if (valaxyConfig.siteConfig.statistics.enable) {
          presetStatistics({
            options: valaxyConfig.siteConfig.statistics,
            route
          });
        }
        const ctx = {
          route,
          data,
          excerpt,
          content,
          path
        };
        valaxyConfig.extendMd?.(ctx);
      }
      await valaxyApp.hooks.callHook("vue-router:extendRoute", route);
      return valaxyConfig.router?.extendRoute?.(route);
    },
    async beforeWriteFiles(root) {
      await valaxyApp.hooks.callHook("vue-router:beforeWriteFiles", root);
    }
  });
}

async function ViteValaxyPlugins(valaxyApp, serverOptions = {}) {
  const { options } = valaxyApp;
  const { roots, config: valaxyConfig } = options;
  const MarkdownPlugin = await createMarkdownPlugin(options);
  const ValaxyPlugin = await createValaxyPlugin(options, serverOptions);
  const componentsDirs = roots.map((root) => `${root}/components`).concat(["src/components", "components"]);
  const vuePlugin = await import('@vitejs/plugin-vue').then(
    (r) => r.default({
      include: /\.(?:vue|md)$/,
      exclude: [],
      ...valaxyConfig.vue,
      template: {
        ...valaxyConfig.vue?.template,
        compilerOptions: {
          ...valaxyConfig.vue?.template?.compilerOptions,
          isCustomElement: (tag) => {
            let is = customElements.has(tag);
            valaxyConfig.vue?.isCustomElement?.forEach((fn) => {
              is = is || fn(tag);
            });
            return is;
          }
        }
      }
    })
  );
  const plugins = [
    MarkdownPlugin,
    ValaxyPlugin,
    vuePlugin,
    createConfigPlugin(options),
    createClientSetupPlugin(options),
    UnheadVite(),
    // https://github.com/posva/unplugin-vue-router
    await createRouterPlugin(valaxyApp),
    // https://github.com/JohnCampionJr/vite-plugin-vue-layouts
    Layouts({
      layoutsDirs: roots.map((root) => `${root}/layouts`),
      ...valaxyConfig.layouts
    }),
    // https://github.com/antfu/unplugin-vue-components
    Components({
      extensions: ["vue", "md"],
      // allow auto import and register components used in markdown
      include: [/\.vue$/, /\.vue\?vue/, /\.md$/],
      /**
       * 默认排除 components/.exclude
       * `/[\\/]node_modules[\\/]/, ` 不要排除 node_modules/valaxy/client/components 下的组件
       */
      exclude: [/[\\/]\.git[\\/]/, /[\\/]\.exclude[\\/]/],
      // allow override
      allowOverrides: true,
      /**
       * override: user -> theme -> client
       *
       * latter override former
       */
      dirs: componentsDirs,
      dts: resolve$1(options.tempDir, "components.d.ts"),
      ...valaxyConfig.components
    }),
    // https://github.com/antfu/unocss
    // UnocssPlugin,
    await createUnocssPlugin(options),
    // ...MarkdownPlugin,
    // https://github.com/intlify/bundle-tools/tree/main/packages/unplugin-vue-i18n
    VueI18n({
      runtimeOnly: true,
      compositionOnly: true,
      fullInstall: true,
      include: roots.map((root) => `${root}/locales/**`)
    }),
    createFixPlugins(),
    // localSearch
    await localSearchPlugin(options)
  ];
  if (valaxyConfig.visualizer) {
    try {
      const visualizer = (await import('rollup-plugin-visualizer')).visualizer;
      plugins.push(
        visualizer({
          open: true,
          gzipSize: true,
          ...valaxyConfig.visualizer
        })
      );
    } catch (e) {
      console.error(e);
      consola.error("Failed to load rollup-plugin-visualizer");
      consola.error("Please install `rollup-plugin-visualizer` to enable the feature");
      console.log();
      consola.info("pnpm add -D rollup-plugin-visualizer");
      console.log();
    }
  }
  const builtinCustomIcon = {
    nodejs: "vscode-icons:file-type-node",
    playwright: "vscode-icons:file-type-playwright",
    typedoc: "vscode-icons:file-type-typedoc",
    eslint: "vscode-icons:file-type-eslint"
  };
  const groupIconPlugin = groupIconVitePlugin({
    customIcon: {
      ...builtinCustomIcon,
      ...valaxyConfig.groupIcons?.customIcon
    },
    defaultLabels: [
      ...valaxyConfig.groupIcons?.defaultLabels || [],
      ...Object.keys(builtinCustomIcon),
      ...Object.keys(valaxyConfig.groupIcons?.customIcon || {})
    ]
  });
  plugins.push(groupIconPlugin);
  return plugins;
}

async function build$1(valaxyApp, viteConfig = defaultViteConfig) {
  const inlineConfig = mergeConfig(viteConfig, {
    ...defaultViteConfig,
    plugins: await ViteValaxyPlugins(valaxyApp)
  });
  await build$3(inlineConfig);
}
async function ssgBuild(valaxyApp, viteConfig = {}) {
  const { options } = valaxyApp;
  const defaultConfig = {
    ...defaultViteConfig,
    plugins: await ViteValaxyPlugins(valaxyApp),
    ssr: {
      // TODO: workaround until they support native ESM
      noExternal: ["workbox-window", /vue-i18n/, "@vue/devtools-api"]
    }
  };
  defaultConfig.ssgOptions = {
    script: "async",
    formatting: "minify",
    beastiesOptions: {
      preload: "swap",
      // reduceInlineStyles: false,
      ...options.config.beastiesOptions || {}
    },
    onFinished() {
      generateSitemap(
        {
          hostname: options.config.siteConfig.url
        }
      );
    }
    // dirStyle default it flat
    // dirStyle: 'nested',
  };
  if (options.config.build.ssgForPagination) {
    defaultConfig.ssgOptions.includedRoutes = (paths, _routes) => {
      const newPaths = paths;
      const posts = paths.filter((path) => path.startsWith("/posts/"));
      const pageNumber = Math.ceil(posts.length / options.config.siteConfig.pageSize);
      consola.info(`Generate ${colors.yellow(pageNumber)} pages for pagination.`);
      for (let i = 1; i <= pageNumber; i++)
        newPaths.push(`/page/${i}`);
      if (!options.config.vite?.ssgOptions?.includeAllRoutes)
        return newPaths.filter((path) => !path.split("/").some((p) => p.startsWith(":")));
      else
        return newPaths;
    };
  }
  const inlineConfig = mergeConfig(defaultConfig, viteConfig);
  await build$2({}, inlineConfig);
}
async function postProcessForSSG(options) {
  const { userRoot } = options;
  const indexPath = resolve(userRoot, "dist/index.html");
  if (fs.existsSync(indexPath)) {
    consola.info("post process for ssg...");
    const indexFile = await fs.readFile(indexPath, "utf-8");
    const htmlTag = "</html>";
    if (!indexFile.endsWith(htmlTag)) {
      consola.warn("fix incomplete index.html...");
      const htmlTagStart = indexFile.lastIndexOf(htmlTag);
      await fs.writeFile(indexPath, indexFile.slice(0, htmlTagStart + htmlTag.length), "utf-8");
    }
  }
  if (!options.config.siteConfig.redirects?.useVueRouter)
    await generateClientRedirects(options);
}
async function generateClientRedirects(options) {
  consola.info("generate client redirects...");
  const outputPath = resolve(options.userRoot, "dist");
  const redirectRules = collectRedirects(options.redirects);
  const task = redirectRules.map(async (rule) => {
    const fromPath = join(outputPath, `${rule.from}.html`);
    const toPath = join(outputPath, `${rule.to}.html`);
    const routeExist = await fs.pathExists(toPath);
    if (!routeExist)
      throw new Error(`the route of '${rule.to}' not exists`);
    await writeRedirectFiles(rule.to, fromPath);
  });
  await Promise.all(task);
}

function defineValaxyModule(module) {
  return module;
}
function setupModules(node, modules) {
  modules.forEach((module) => {
    module.setup?.(node);
  });
}

const NODE_I18N = {
  /**
   * node 读取的 locales 数据
   */
  locales: {}
};
function loadLocalesYml(localesPath) {
  const locales = {};
  if (fs.existsSync(localesPath)) {
    const files = fs.readdirSync(localesPath);
    files.forEach((file) => {
      if (file.endsWith(".yml") || file.endsWith(".yaml")) {
        const lang = file.replace(/\.ya?ml$/, "");
        const filePath = `${localesPath}/${file}`;
        try {
          const content = fs.readFileSync(filePath, "utf-8");
          const data = yaml.load(content);
          locales[lang] = data || {};
        } catch (e) {
          console.error(`Error loading locale file: ${filePath}`, e);
        }
      }
    });
  }
  NODE_I18N.locales = locales;
  return locales;
}
function nodeT(key, lang) {
  if (key.startsWith(LOCALE_PREFIX)) {
    key = key.slice(LOCALE_PREFIX.length);
  }
  const data = NODE_I18N.locales[lang] || {};
  const keys = key.split(".");
  let result = data;
  for (const k of keys) {
    result = result?.[k];
    if (result === void 0)
      return "";
  }
  return result || "";
}

function commonOptions(args) {
  return args.positional("root", {
    default: ".",
    type: "string",
    describe: "root folder of your source files"
  });
}

const isWindows = os.platform() === "win32";
async function generateFuseList(options) {
  consola.start(`Generate List for Fuse Search by (${colors.cyan("fuse.js")}) ...`);
  const pattern = path$1.resolve(options.userRoot, options.config.siteConfig.fuse.pattern || "pages/**/*.md");
  const finalPattern = isWindows ? fg.convertPathToPattern(pattern) : pattern;
  const files = await fg(finalPattern);
  if (files.length > 0) {
    consola.success(`Found ${colors.dim(files.length.toString())} markdown files for fuse search.`);
  } else {
    consola.warn(`No markdown files found for fuse search. Please check your fuse pattern: ${colors.dim(finalPattern)}`);
  }
  loadLocalesYml(path$1.resolve(options.userRoot, "locales"));
  const globalAuthor = nodeT(options.config.siteConfig.author.name, options.config.siteConfig.lang || "en");
  const posts = [];
  for await (const i of files) {
    const raw = fs.readFileSync(i, "utf-8");
    const { data, excerpt, content } = matter(raw, matterOptions);
    const fmData = data;
    if (fmData.draft) {
      consola.warn(`Ignore draft post: ${colors.dim(i)}`);
      continue;
    }
    if (fmData.hide)
      continue;
    if (fmData.password)
      continue;
    const extendKeys = options.config.fuse?.extendKeys || [];
    const relativeLink = path$1.join(options.config.vite?.base || "/", path$1.relative(path$1.resolve(options.userRoot, "pages"), i)).replace(/\\/g, "/");
    const link = i.endsWith("index.md") ? relativeLink.replace(/\/index\.md$/, "") : relativeLink.replace(/\.md$/, "");
    const fuseListItem = {
      title: fmData.title || "",
      tags: (typeof fmData.tags === "string" ? [fmData.tags] : fmData.tags) || [],
      categories: (typeof fmData.categories === "string" ? [fmData.categories] : fmData.categories) || [],
      author: fmData.author || globalAuthor,
      excerpt: excerpt || content.slice(0, 100),
      // encode for chinese url, replace for windows path
      link: encodeURI(link)
    };
    if (options.config.siteConfig.fuse.options.keys?.includes("content")) {
      fuseListItem.content = content;
    }
    extendKeys.forEach((key) => {
      fuseListItem[key] = fmData[key] || "";
    });
    posts.push(fuseListItem);
  }
  return posts;
}
async function execFuse(options) {
  consola.info("Start generate fuse list...");
  const fuseList = await generateFuseList(options);
  await fs.ensureDir("./dist");
  const publicFolder = path$1.resolve(options.userRoot, "public");
  const publicFuseFile = path$1.resolve(publicFolder, options.config.siteConfig.fuse.dataPath);
  const publicRelativeFile = path$1.join("public", options.config.siteConfig.fuse.dataPath);
  await fs.ensureFile(publicFuseFile);
  fs.writeJSONSync(publicFuseFile, fuseList);
  consola.success(`Generate fuse list in ${colors.dim(publicFolder)}`);
  const distFolder = path$1.resolve(options.userRoot, "dist");
  const distFuseFile = path$1.resolve(distFolder, options.config.siteConfig.fuse.dataPath);
  await fs.ensureDir(distFolder);
  fs.writeJSONSync(distFuseFile, fuseList);
  consola.success(`Generate fuse list in ${colors.dim(distFolder)}`);
  try {
    const gitignorePath = path$1.resolve(options.userRoot, ".gitignore");
    const gitignore = await fs.readFile(gitignorePath, "utf-8");
    const ignorePath = publicRelativeFile.replace(/\\/g, "/");
    if (!gitignore.includes(ignorePath)) {
      await fs.appendFile(gitignorePath, `
# valaxy fuse
${ignorePath}
`);
      consola.success(`Add ${colors.dim(ignorePath)} to ${colors.dim(".gitignore")}`);
    }
  } catch {
  }
}
function registerFuseCommand(cli) {
  cli.command(
    "fuse [root]",
    "generate fuse list for search",
    (args) => commonOptions(args).strict().help(),
    async ({ root }) => {
      setEnvProd();
      const options = await resolveOptions({ userRoot: root }, "build");
      await execFuse(options);
    }
  );
}
const fuseModule = defineValaxyModule({
  extendCli(cli) {
    registerFuseCommand(cli);
  },
  setup(node) {
    node.hook("build:before", async () => {
      await execFuse(node.options);
    });
  }
});

async function getCreatedTime(file) {
  return await getGitTimestamp(file, "created") || (await fs.stat(file)).ctime;
}
async function getUpdatedTime(file) {
  return await getGitTimestamp(file, "created") || (await fs.stat(file)).mtime;
}

const markdown = MarkdownIt({
  html: true,
  breaks: true,
  linkify: true
});
async function extractImagePathsFromHTML(htmlPath, DOMAIN) {
  const imageMap = /* @__PURE__ */ new Map();
  try {
    if (!await fs.exists(htmlPath))
      return imageMap;
    const html = await fs.readFile(htmlPath, "utf-8");
    const imgRegex = /<img[^>]+src="([^"]+)"[^>]*>/g;
    let match;
    while ((match = imgRegex.exec(html)) !== null) {
      const src = match[1];
      const assetMatch = src.match(/\/assets\/(.+)\.([a-zA-Z0-9]+)\.([a-z0-9]+)$/);
      if (assetMatch) {
        const [, basename, , ext] = assetMatch;
        const originalName = `${basename}.${ext}`;
        imageMap.set(originalName, `${DOMAIN}${src}`);
        imageMap.set(`./${originalName}`, `${DOMAIN}${src}`);
        consola.debug(`[RSS] Mapped image: ${originalName} -> ${DOMAIN}${src}`);
      }
    }
    if (imageMap.size > 0) {
      const uniqueImageCount = imageMap.size / 2;
      consola.info(`[RSS] Extracted ${uniqueImageCount} image(s) from ${htmlPath}`);
    }
  } catch (error) {
    consola.debug(`Failed to extract image paths from ${htmlPath}:`, error);
  }
  return imageMap;
}
async function build(options) {
  const s = ora("RSS Generating ...").start();
  const { config } = options;
  const siteConfig = config.siteConfig;
  const lang = siteConfig.lang || "en";
  if (!siteConfig.url || siteConfig.url === "/") {
    consola.error("You must set `url` (like `https://example.com`) in `site.config.ts` to generate rss.");
    return;
  }
  const siteUrl = siteConfig.url;
  const author = {
    name: siteConfig.author?.name,
    email: siteConfig.author?.email,
    link: siteConfig.author?.link
  };
  const ccVersion = siteConfig.license?.type === "zero" ? "1.0" : "4.0";
  const feedNameMap = {
    atom: siteConfig.feed?.name ? `${siteConfig.feed?.name}.atom` : "atom.xml",
    json: `${siteConfig.feed?.name || "feed"}.json`,
    rss: `${siteConfig.feed?.name || "feed"}.xml`
  };
  const feedLinks = {};
  Object.keys(feedNameMap).forEach((key) => {
    feedLinks[key] = `${siteUrl}${feedNameMap[key]}`;
  });
  const title = tObject(siteConfig.title, lang);
  const description = tObject(siteConfig.description, lang);
  const feedOptions = {
    title: title || "Valaxy Blog",
    description,
    id: siteUrl || "valaxy",
    link: siteUrl,
    copyright: `CC ${siteConfig.license?.type?.toUpperCase()} ${ccVersion} ${(/* @__PURE__ */ new Date()).getFullYear()} \xA9 ${siteConfig.author?.name}`,
    feedLinks
  };
  const DOMAIN = siteConfig.url.slice(0, -1);
  const files = await fg(`${options.userRoot}/pages/posts/**/*.md`);
  const posts = await getPosts({
    author,
    files,
    DOMAIN
  }, options);
  if (!posts)
    return;
  const authorAvatar = siteConfig.author?.avatar || "/favicon.svg";
  feedOptions.author = author;
  feedOptions.image = isExternal(authorAvatar) ? siteConfig.author?.avatar : `${DOMAIN}${ensurePrefix("/", authorAvatar)}`;
  feedOptions.favicon = `${DOMAIN}${siteConfig.feed?.favicon || siteConfig.favicon}`;
  s.succeed("RSS Generated.");
  await writeFeed(feedOptions, posts, options, feedNameMap);
}
async function getPosts(params, options) {
  const { config } = options;
  const siteConfig = config.siteConfig;
  const lang = siteConfig.lang || "en";
  const { files, author, DOMAIN } = params;
  const readFilePromises = files.map(async (i) => {
    const raw = await readFile(i, "utf-8");
    const { data, content, excerpt } = matter(raw, matterOptions);
    return { data, content, excerpt, path: i };
  });
  const rawPosts = await Promise.all(readFilePromises);
  const filteredPosts = rawPosts.filter((p) => {
    const { data } = p;
    if (data.password)
      return false;
    if (data.draft) {
      return false;
    }
    if (data.hide)
      return false;
    return true;
  });
  const posts = [];
  for (const rawPost of filteredPosts) {
    const { data, path, content, excerpt } = rawPost;
    if (!data.date)
      data.date = await getCreatedTime(path);
    if (siteConfig.lastUpdated) {
      if (!data.updated)
        data.updated = await getUpdatedTime(path);
    }
    const fullText = options.config.modules.rss.fullText;
    const rssContent = fullText ? content : excerpt || content.slice(0, 100);
    const relativePath = relative$1(join(options.userRoot, "pages"), path);
    const urlPath = relativePath.replace(/\\/g, "/").replace(/\.md$/, "");
    const link = `${DOMAIN}/${urlPath}`;
    const extractImages = options.config.modules.rss.extractImagePathsFromHTML;
    let imageMap = /* @__PURE__ */ new Map();
    if (extractImages) {
      let htmlPath = resolve(options.userRoot, "dist", `${urlPath}.html`);
      if (urlPath.endsWith("/index")) {
        const withoutIndex = urlPath.slice(0, -6);
        const alternativePath = resolve(options.userRoot, "dist", `${withoutIndex}.html`);
        if (await fs.exists(alternativePath)) {
          htmlPath = alternativePath;
        }
      }
      imageMap = await extractImagePathsFromHTML(htmlPath, DOMAIN);
    }
    let html = markdown.render(rssContent);
    html = html.replace(/src="([^"]+)"/g, (_fullMatch, src) => {
      if (imageMap.has(src)) {
        return `src="${imageMap.get(src)}"`;
      }
      if (src.startsWith("http://") || src.startsWith("https://")) {
        return _fullMatch;
      }
      if (src.startsWith("/")) {
        return `src="${DOMAIN}${src}"`;
      }
      const postDirUrl = `${DOMAIN}/${urlPath.split("/").slice(0, -1).join("/")}`;
      const cleanSrc = src.startsWith("./") ? src.slice(2) : src;
      return `src="${postDirUrl}/${cleanSrc}"`;
    });
    if (data.image?.startsWith("/"))
      data.image = DOMAIN + data.image;
    const tip = `<br/><p>${lang === "zh-CN" ? `\u8BBF\u95EE <a href="${link}" target="_blank">${link}</a> ${fullText ? "\u67E5\u770B\u539F\u6587" : "\u9605\u8BFB\u5168\u6587"}\u3002` : `Visit <a href="${link}" target="_blank">${link}</a> to ${fullText ? "view original article" : "read more"}.`}</p>`;
    const item = {
      ...data,
      title: tObject(data.title, lang),
      description: tObject(data.description, lang),
      date: new Date(data.date),
      // RSS pubDate / JSON date_published
      published: new Date(data.date),
      // Atom published (first publish time)
      content: html + tip,
      author: [author],
      id: data.id || link,
      link,
      // Add updated field for Atom feed (if exists)
      // Atom: <updated> (last modified time)
      // JSON Feed: date_modified
      ...data.updated && { updated: new Date(data.updated) }
    };
    posts.push(item);
  }
  const orderBy = siteConfig.orderBy || "date";
  const useUpdatedTime = orderBy === "updated";
  posts.sort((a, b) => {
    const aTime = useUpdatedTime ? a.updated || a.date : a.date;
    const bTime = useUpdatedTime ? b.updated || b.date : b.date;
    return +bTime - +aTime;
  });
  return posts;
}
async function writeFeed(feedOptions, posts, options, feedNameMap) {
  const feed = new Feed(feedOptions);
  posts.forEach((item) => feed.addItem(item));
  await fs.ensureDir(dirname(`./dist/${feedNameMap.atom}`));
  const path = resolve(options.userRoot, "./dist");
  const publicFolder = resolve(options.userRoot, "public");
  const { config } = options;
  const siteConfig = config.siteConfig;
  const now = dayjs().format("YYYY-MM-DD HH:mm:ss zzz");
  const tableData = [
    [`${colors.yellow("RSS Feed Files")} \u{1F4E1} ${colors.dim(now)}`, "", ""],
    [colors.bold("Site Url"), "", colors.cyan(siteConfig.url)],
    ["Type", "Folder", "Path"]
  ];
  const types = ["rss", "atom", "json"];
  for (const type of types) {
    let data = "";
    const distFeedPath = `${path}/${feedNameMap[type]}`;
    if (type === "rss")
      data = feed.rss2();
    else if (type === "atom")
      data = feed.atom1();
    else if (type === "json")
      data = feed.json1();
    await fs.writeFile(distFeedPath, data, "utf-8");
    consola.debug(`[${colors.cyan(type)}] dist: ${colors.dim(distFeedPath)}`);
    tableData.push([colors.cyan(type), colors.yellow("dist"), colors.dim(distFeedPath)]);
    const publicFeedPath = resolve(publicFolder, feedNameMap[type]);
    const publicRelativeFile = join("public", feedNameMap[type]);
    await fs.writeFile(publicFeedPath, data, "utf-8");
    consola.debug(`[${colors.cyan(type)}] public: ${colors.dim(publicFeedPath)}`);
    tableData.push(["", colors.green("public"), colors.dim(publicFeedPath)]);
    try {
      const gitignorePath = resolve(options.userRoot, ".gitignore");
      const gitignore = await fs.readFile(gitignorePath, "utf-8");
      const ignorePath = publicRelativeFile.replace(/\\/g, "/");
      if (!gitignore.includes(ignorePath)) {
        await fs.appendFile(gitignorePath, `
# valaxy rss
${ignorePath}
`);
        consola.success(`Add ${colors.dim(ignorePath)} to ${colors.dim(".gitignore")}`);
      }
    } catch {
    }
  }
  console.log(table(tableData, {
    columns: [
      { alignment: "center" },
      { alignment: "right" },
      { alignment: "left" }
    ],
    spanningCells: [
      { col: 0, row: 0, colSpan: 3 },
      { col: 0, row: 1, colSpan: 2 },
      { col: 0, row: 3, rowSpan: 2, verticalAlignment: "middle" },
      { col: 0, row: 5, rowSpan: 2, verticalAlignment: "middle" },
      { col: 0, row: 7, rowSpan: 2, verticalAlignment: "middle" }
    ],
    border: getBorderCharacters("norc")
  }));
}

const rssModule = defineValaxyModule({
  /**
   * valaxy rss
   * @param cli
   */
  extendCli(cli) {
    cli.command(
      "rss [root]",
      "generate rss feed",
      (args) => commonOptions(args).strict().help(),
      async ({ root }) => {
        setEnvProd();
        const options = await resolveOptions({ userRoot: root }, "build");
        await build(options);
      }
    );
  },
  setup(node) {
    node.hook("build:after", async () => {
      console.log();
      await build(node.options);
    });
  }
});

function getServerInfoText(msg) {
  return `${valaxyPrefix} ${colors.gray(msg)}`;
}
async function createServer(valaxyApp, viteConfig = {}, serverOptions = {}) {
  process.env.EDITOR = process.env.EDITOR || "code";
  const { options } = valaxyApp;
  const plugins = await ViteValaxyPlugins(valaxyApp, serverOptions);
  const enableDevtools = options.config.devtools;
  const vitePlugins = [
    ...plugins
  ];
  if (enableDevtools) {
    vitePlugins.push(
      (await import('vite-plugin-vue-devtools')).default(),
      (await import('@valaxyjs/devtools')).default({
        userRoot: options.userRoot
      })
    );
  }
  const mergedViteConfig = mergeConfig(
    viteConfig,
    {
      plugins: vitePlugins
    }
  );
  const server = await createServer$1(mergedViteConfig);
  return server;
}

function printInfo(options, port, remote) {
  const themeVersion = colors.blue(`v${options.config.themeConfig?.pkg?.version}`) || "unknown";
  console.log();
  console.log(`  ${colors.bold("\u{1F30C} Valaxy")}  ${colors.blue(`v${version}`)}`);
  console.log();
  console.log(`${colors.dim("  \u{1FA90} theme  ")} > ${options.theme ? colors.green(options.theme) : colors.gray("none")} (${themeVersion})`);
  console.log(`  ${colors.dim("\u{1F4C1}")} ${colors.dim(path$1.resolve(options.userRoot))}`);
  if (port) {
    console.log();
    console.log(`${colors.dim("  Preview   ")} > ${colors.cyan(`http://localhost:${colors.bold(port)}/`)}`);
    if (remote) {
      Object.values(os.networkInterfaces()).forEach(
        (v) => (v || []).filter((details) => details.family === "IPv4" && !details.address.includes("127.0.0.1")).forEach(({ address }) => {
          console.log(`${colors.dim("  Network   ")} > ${colors.blue(`http://${address}:${colors.bold(port)}/`)}`);
        })
      );
    }
    console.log();
    const restart = `${colors.underline("r")}${colors.dim("estart")}`;
    const edit = `${colors.underline("e")}${colors.dim("dit")}`;
    const open = `${colors.underline("o")}${colors.dim("pen")}`;
    const qr = `${colors.underline("q")}${colors.dim("r")}`;
    const divider = `${colors.dim(" | ")}`;
    console.log(`${colors.dim("  shortcuts ")} > ${restart}${divider}${open}${divider}${qr}${divider}${edit}`);
  }
  console.log();
}
const serverSpinner = ora(`${valaxyPrefix} creating server ...`);
async function initServer(valaxyApp, viteConfig) {
  if (GLOBAL_STATE.server) {
    vLogger.info("close server...");
    await GLOBAL_STATE.server.close();
  }
  const { options } = valaxyApp;
  serverSpinner.start();
  const viteConfigs = mergeConfig(
    await mergeViteConfigs(options, "serve"),
    viteConfig
  );
  try {
    GLOBAL_STATE.server = await createServer(valaxyApp, viteConfigs, {
      async onConfigReload(newConfig, config, force = false) {
        if (force) {
          vLogger.info(`${colors.yellow("force")} reload the server`);
          initServer(valaxyApp, viteConfig);
        }
        let reload = false;
        if (newConfig.theme !== config.theme)
          reload = true;
        if (reload)
          initServer(valaxyApp, viteConfig);
      }
    });
    const server = GLOBAL_STATE.server;
    await server.listen();
    serverSpinner.succeed(`${valaxyPrefix} ${colors.green("server ready.")}`);
    return server;
  } catch (e) {
    consola.error("failed to start server. error:\n");
    console.error(e);
    process.exit(1);
  }
}
if (import.meta.hot) {
  await import.meta.hot.data.stopping;
  let reload = async () => {
    consola.info("HMR: Stop Server");
    await GLOBAL_STATE.server?.close();
  };
  import.meta.hot.on("vite:beforeFullReload", () => {
    const stopping = reload();
    reload = () => Promise.resolve();
    if (import.meta.hot)
      import.meta.hot.data.stopping = stopping;
  });
}

async function execBuild({ ssg, root, output, log }) {
  setEnvProd();
  if (!isPagesDirExist(root))
    process.exit(0);
  const userRoot = path$1.resolve(root);
  const options = await resolveOptions({ userRoot }, "build");
  setTimezone(options.config.siteConfig.timezone);
  printInfo(options);
  const valaxyApp = createValaxyNode(options);
  await callHookWithLog("options:resolved", valaxyApp);
  const modules = [];
  if (options.config.siteConfig.search.provider === "fuse")
    modules.push(fuseModule);
  if (options.config.modules.rss.enable)
    modules.push(rssModule);
  setupModules(
    valaxyApp,
    modules
  );
  const valaxyViteConfig = mergeConfig(await mergeViteConfigs(options, "build"), options.config.vite || {});
  const viteConfig = mergeConfig(
    valaxyViteConfig,
    {
      // avoid load userRoot/vite.config.ts repeatedly
      configFile: path$1.resolve(options.clientRoot, "vite.config.ts"),
      build: {
        // make out dir empty, https://vitejs.dev/config/#build-emptyoutdir
        emptyOutDir: true,
        outDir: path$1.resolve(options.userRoot, output)
      },
      logLevel: log
    }
  );
  await callHookWithLog("config:init", valaxyApp);
  await callHookWithLog("build:before", valaxyApp);
  consola.box("\u{1F320} Start building...");
  try {
    if (ssg) {
      consola.info(`use ${colors.yellow("vite-ssg")} to do ssg build...`);
      try {
        await ssgBuild(valaxyApp, viteConfig);
        await postProcessForSSG(options);
      } catch (e) {
        consola.error("[vite-ssg] An internal error occurred.");
        console.log(e);
      }
    } else {
      consola.info("use vite do spa build...");
      await build$1(valaxyApp, viteConfig);
    }
  } catch (e) {
    console.log(e);
  } finally {
    await callHookWithLog("build:after", valaxyApp);
  }
}
function registerBuildCommand(cli) {
  cli.command(
    "build [root]",
    "build your blog to static content",
    (args) => commonOptions(args).option("ssg", {
      alias: "s",
      type: "boolean",
      // https://github.com/antfu/vite-ssg/pull/219
      // to be true, when vite-ssg export build
      default: false,
      describe: "static site generate"
    }).option("output", {
      alias: "o",
      type: "string",
      default: "dist",
      describe: "output dir"
    }).option("log", {
      default: "warn",
      type: "string",
      choices: ["error", "warn", "info", "silent"],
      describe: "log level"
    }).strict().help(),
    async ({ ssg, root, output, log }) => {
      await execBuild({ ssg, root, output, log });
    }
  );
}

async function cleanDist() {
  const distDir = path$1.join(process.cwd(), "dist");
  const cacheDir = path$1.join(process.cwd(), ".valaxy");
  consola.box("\u{1F9F9} Starting clean...");
  if (await fs.exists(distDir)) {
    consola.info("dist directory exists, removing...");
    try {
      await fs.rm(distDir, { recursive: true, force: true });
      consola.success("dist directory has been successfully removed.");
    } catch (error) {
      consola.error("Failed to remove dist directory.");
      consola.error(error);
    }
  } else {
    consola.info("No dist directory found, nothing to clean.");
  }
  if (await fs.exists(cacheDir)) {
    consola.info(".valaxy cache directory exists, removing...");
    try {
      await fs.rm(cacheDir, { recursive: true, force: true });
      consola.success(".valaxy cache directory has been successfully removed.");
    } catch (error) {
      consola.error("Failed to remove .valaxy cache directory.");
      consola.error(error);
    }
  } else {
    consola.info("No .valaxy cache directory found, nothing to clean.");
  }
}
function registerCleanCommand(cli) {
  cli.command(
    "clean",
    "Clean the dist folder and cache",
    () => {
    },
    async () => {
      await cleanDist();
    }
  );
}

function registerDebugCommand(cli) {
  cli.command("debug", "Debug your blog", async () => {
    console.log();
    consola.log("  Operating System:", colors.green(os.platform()));
    consola.log("  Node.JS Version:", colors.green(process.version));
    consola.log("  Valaxy Version:", colors.cyan(`v${version}`));
  });
}

function registerDeployCommand(cli) {
  cli.command("deploy", "deploy your blog to the cloud", async () => {
    intro("Deploying Your Blog");
    const shouldBuild = await confirm({
      message: "Do you want to build your blog before deploying?"
    });
    if (shouldBuild) {
      await execBuild({ ssg: true, root: process.cwd(), output: "dist", log: "info" });
    }
    const deployType = await select({
      message: "Where do you want to deploy?",
      options: [
        { label: "GitHub Pages", value: "gh-pages", hint: "You need install `gh-pages` dependencies." },
        { label: "Your Own Server", value: "server" }
      ]
    });
    if (deployType === "gh-pages") {
      let isGhPagesInstalled = false;
      try {
        await import('gh-pages');
        isGhPagesInstalled = true;
      } catch (e) {
        console.error(e);
        const installGhPages = await confirm({
          message: "Do you want to install `gh-pages` now?"
        });
        if (installGhPages) {
          await import('@antfu/install-pkg').then((i) => i.installPackage("gh-pages", { dev: true }));
          isGhPagesInstalled = true;
        } else {
          outro("Please install `gh-pages` before deploying to GitHub Pages.");
        }
      }
      if (isGhPagesInstalled) {
        const { publish } = await import('gh-pages');
        await publish("dist", {
          branch: "gh-pages",
          message: "chore: deploy by valaxy"
        });
        outro("Done!");
      }
    }
  });
}

async function findFreePort(start) {
  if (await isPortFree(start))
    return start;
  return await findFreePort(start + 1);
}
function isPortFree(port) {
  return new Promise((resolve) => {
    const server = net.createServer((socket) => {
      socket.write("Echo server\r\n");
      socket.pipe(socket);
    });
    server.listen(port, "0.0.0.0");
    server.on("error", () => {
      resolve(false);
    });
    server.on("listening", () => {
      server.close();
      resolve(true);
    });
  });
}

const SHORTCUTS = [
  {
    key: "r",
    description: "restart",
    async action(server, createDevServer) {
      await server.close();
      setTimeout(async () => {
        await createDevServer();
      }, 100);
    }
  },
  {
    key: "o",
    description: "open",
    async action(server) {
      const { default: openBrowser } = await import('open');
      openBrowser(`http://localhost:${server.config.server.port}/`);
    }
  },
  {
    key: "q",
    description: "qr",
    action(server) {
      const addresses = Object.values(os.networkInterfaces()).flat().filter((details) => details?.family === "IPv4" && !details.address.includes("127.0.0.1"));
      const port = server.config.server.port;
      const remoteUrl = `http://${addresses[0]?.address || "localhost"}:${port}`;
      qrcode.toString(remoteUrl, { type: "terminal" }, (err, qrCode) => {
        if (err)
          throw err;
        console.log(qrCode);
      });
    }
  },
  {
    key: "e",
    description: "edit",
    action() {
      exec(`code "${process.cwd()}"`, (err) => {
        if (err)
          console.error("Failed to open editor", err);
      });
    }
  }
];
function bindShortcuts(server, createDevServer) {
  if (!server.httpServer || process.env.CI) {
    console.log("restart server to enable shortcuts", server.httpServer, process.stdin.isTTY, process.env.CI);
    return;
  }
  process.stdin.resume();
  process.stdin.setEncoding("utf8");
  readline.emitKeypressEvents(process.stdin);
  if (process.stdin.isTTY)
    process.stdin.setRawMode(true);
  async function onKeyPress(str, key) {
    if (key.ctrl && key.name === "c") {
      process.exit();
    } else {
      const shortcut = SHORTCUTS.find((shortcut2) => shortcut2.key === str);
      if (!shortcut)
        return;
      try {
        await shortcut.action(server, createDevServer);
      } catch (error) {
        console.error(colors.red("Error executing shortcut:"), key, error);
      }
    }
  }
  process.stdin.on("keypress", onKeyPress);
  server.httpServer.on("close", () => {
    process.stdin.off("keypress", onKeyPress);
  });
}

async function startValaxyDev({
  root = process.cwd(),
  port,
  remote,
  log,
  open
}) {
  setEnv();
  if (!isPagesDirExist(root))
    process.exit(0);
  port = port || await findFreePort(4859);
  const resolvedOptions = await resolveOptions({ userRoot: root });
  setTimezone(resolvedOptions.config.siteConfig.timezone);
  const valaxyApp = createValaxyNode(resolvedOptions);
  GLOBAL_STATE.valaxyApp = valaxyApp;
  const viteConfig = mergeConfig({
    // initial vite config
    ...defaultViteConfig,
    // avoid load userRoot/vite.config.ts repeatedly
    configFile: path$1.resolve(resolvedOptions.clientRoot, "vite.config.ts"),
    server: {
      watch: {
        // watch theme updated
        ignored: [`!${resolvedOptions.themeRoot}/**`, `${resolvedOptions.userRoot}/**.md`]
      },
      port,
      strictPort: true,
      open,
      host: remote ? "0.0.0.0" : "localhost"
    },
    logLevel: log
  }, resolvedOptions.config.vite || {});
  const server = await initServer(valaxyApp, viteConfig);
  printInfo(resolvedOptions, port, remote);
  return server;
}
function registerDevCommand(cli) {
  cli.command(
    "* [root]",
    "Start a local server for Valaxy",
    (args) => commonOptions(args).option("port", {
      alias: "p",
      type: "number",
      describe: "port"
    }).option("open", {
      alias: "o",
      default: false,
      type: "boolean",
      describe: "open in browser"
    }).option("remote", {
      default: true,
      type: "boolean",
      describe: "listen public host and enable remote control"
    }).option("log", {
      default: "info",
      type: "string",
      choices: ["error", "warn", "info", "silent"],
      describe: "log level"
    }).strict().help(),
    async ({ root, port, open, remote, log }) => {
      let server;
      const createDevServer = async () => {
        server = await startValaxyDev({
          root,
          open,
          port,
          remote,
          log
        });
        bindShortcuts(server, createDevServer);
      };
      createDevServer();
    }
  );
}

const userRoot = process.cwd();
const defaultPostTemplate = `---
layout: <%=layout%>
title: <%=title%>
date: <%=date%>
---
`;

async function getTemplate(layout) {
  const { clientRoot, themeRoot } = await resolveOptions({ userRoot });
  const roots = [userRoot, themeRoot, clientRoot];
  for (const root of roots) {
    const scaffoldPath = path$1.resolve(root, "scaffolds", `${layout}.md`);
    if (await fs.exists(scaffoldPath))
      return readFile(scaffoldPath, "utf-8");
  }
  return false;
}

async function create(params) {
  const pagesPath = resolve(userRoot, params.path || "pages");
  let counter = 0;
  while (true) {
    const postFileName = `${params.title}${counter ? `-${counter}` : ""}`;
    const postFilePath = params.folder ? join(postFileName, "index.md") : `${postFileName}.md`;
    const targetPath = resolve(pagesPath, "posts", postFilePath);
    if (!await fs.exists(targetPath)) {
      await fs.ensureDir(dirname(targetPath));
      const content = await genLayoutTemplate(params);
      try {
        await fs.writeFile(targetPath, content, "utf-8");
        consola.success(`[valaxy new]: successfully generated file ${colors.magenta(targetPath)}`);
      } catch (e) {
        console.log(e);
        consola.error(`[valaxy new]: failed to write file ${targetPath}`);
        consola.warn(`You should run ${colors.green("valaxy new")} in your valaxy project root directory.`);
      }
      return targetPath;
    }
    counter++;
  }
}
async function genLayoutTemplate({
  date,
  title,
  layout = "post"
}) {
  let template = await getTemplate(layout);
  if (!template)
    template = defaultPostTemplate;
  const dateFormat = "YYYY-MM-DD HH:mm:ss";
  return ejs.render(template, { title, layout, date: date ? dayjs().format(dateFormat) : "" });
}

function registerNewCommand(cli) {
  cli.command(
    "new <title>",
    "Draft a new post",
    (args) => {
      args.usage("$0 <title> -p [path] -l [layout]").positional("title", {
        describe: "The title of the new post",
        required: true
      }).option("folder", {
        alias: "f",
        type: "boolean",
        default: false,
        describe: "Generate a new post in a folder"
      }).option("path", {
        alias: "p",
        type: "string",
        describe: "the path to generate new post. Customize the path of post to generate"
      }).option("layout", {
        alias: "l",
        type: "string",
        default: "post"
      }).option("date", {
        alias: "d",
        type: "boolean",
        default: true,
        describe: "Generate post with the current date"
      }).strict().help();
    },
    async ({ title, folder, path, date, layout }) => {
      await create({
        title,
        date,
        layout,
        path,
        folder
      });
    }
  );
}

const cli = yargs(hideBin(process.argv)).scriptName("valaxy").usage("$0 [args]").version(version).showHelpOnFail(false).alias("h", "help").alias("v", "version");
registerDevCommand(cli);
registerBuildCommand(cli);
registerNewCommand(cli);
registerCleanCommand(cli);
registerDeployCommand(cli);
registerDebugCommand(cli);
cli.help();
const modules = [
  fuseModule,
  rssModule
];
modules.forEach((module) => {
  module.extendCli?.(cli);
});
function run() {
  cli.parse();
}

export { mergeValaxyConfig as A, resolveValaxyConfig as B, ALL_ROUTE as C, customElements as D, EXCERPT_SEPARATOR as E, defaultViteConfig as F, GLOBAL_STATE as G, version as H, processValaxyOptions as I, resolveOptions as J, resolveThemeValaxyConfig as K, createValaxyPlugin as L, getServerInfoText as M, createServer as N, encryptContent as O, PATHNAME_PROTOCOL_RE as P, getGitTimestamp as Q, isExternal as R, isPath as S, transformObject as T, isInstalledGlobally as U, ViteValaxyPlugins as V, resolveImportUrl as W, toAtFS as X, resolveImportPath as Y, startValaxyDev as a, build$1 as b, cli as c, registerDevCommand as d, getIndexHtml as e, defineValaxyAddon as f, generateClientRedirects as g, defineAddon as h, resolveAddonsConfig as i, defaultSiteConfig as j, defineSiteConfig as k, resolveSiteConfigFromRoot as l, mergeViteConfigs as m, resolveSiteConfig as n, resolveThemeConfigFromRoot as o, postProcessForSSG as p, resolveUserThemeConfig as q, run as r, ssgBuild as s, defineValaxyTheme as t, defineTheme as u, loadConfigFromFile as v, defaultValaxyConfig as w, defineValaxyConfig as x, defineConfig as y, resolveValaxyConfigFromRoot as z };
